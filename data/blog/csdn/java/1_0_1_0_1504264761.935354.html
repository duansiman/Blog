
        <div class="markdown_views"><h1 id="一设计模式的分类">一、设计模式的分类</h1>

<p><strong>设计模式可以分为三大类：</strong></p>



<h4 id="1-创建型模式">(1) <strong>创建型模式</strong></h4>

<ol>
<li>抽象工厂模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52471559">http://blog.csdn.net/oDeviloo/article/details/52471559</a></li>
<li>生成器模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52684935">http://blog.csdn.net/oDeviloo/article/details/52684935</a></li>
<li>工厂方法模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52464359">http://blog.csdn.net/oDeviloo/article/details/52464359</a></li>
<li>原型模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52760783">http://blog.csdn.net/oDeviloo/article/details/52760783</a></li>
<li>单例模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52388833">http://blog.csdn.net/oDeviloo/article/details/52388833</a></li>
</ol>



<h4 id="2-结构型模式">(2) <strong>结构型模式</strong></h4>

<ol>
<li>适配器模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52535105">http://blog.csdn.net/oDeviloo/article/details/52535105</a></li>
<li>桥接模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52816069">http://blog.csdn.net/oDeviloo/article/details/52816069</a></li>
<li>组合模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52839170">http://blog.csdn.net/oDeviloo/article/details/52839170</a></li>
<li>装饰者模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52488283">http://blog.csdn.net/oDeviloo/article/details/52488283</a></li>
<li>外观模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52918773">http://blog.csdn.net/oDeviloo/article/details/52918773</a></li>
<li>享元模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52458677">http://blog.csdn.net/oDeviloo/article/details/52458677</a></li>
<li>代理模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52420690">http://blog.csdn.net/oDeviloo/article/details/52420690</a></li>
</ol>



<h4 id="3-行为模式">(3) <strong>行为模式</strong></h4>

<ol>
<li>职责链模式：<a href="http://blog.csdn.net/oDeviloo/article/details/53022407">http://blog.csdn.net/oDeviloo/article/details/53022407</a></li>
<li>命令模式：<a href="http://blog.csdn.net/oDeviloo/article/details/53081455">http://blog.csdn.net/oDeviloo/article/details/53081455</a></li>
<li>解释器模式：<a href="http://blog.csdn.net/oDeviloo/article/details/53184547">http://blog.csdn.net/oDeviloo/article/details/53184547</a></li>
<li>迭代器模式：<a href="http://blog.csdn.net/odeviloo/article/details/53292643">http://blog.csdn.net/odeviloo/article/details/53292643</a></li>
<li>中介者模式：<a href="http://blog.csdn.net/odeviloo/article/details/53292575">http://blog.csdn.net/odeviloo/article/details/53292575</a></li>
<li>备忘录模式：<a href="http://blog.csdn.net/oDeviloo/article/details/53408610">http://blog.csdn.net/oDeviloo/article/details/53408610</a></li>
<li>观察者模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52507234">http://blog.csdn.net/oDeviloo/article/details/52507234</a></li>
<li>状态模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52600518">http://blog.csdn.net/oDeviloo/article/details/52600518</a></li>
<li>策略模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52610961">http://blog.csdn.net/oDeviloo/article/details/52610961</a></li>
<li>模板方法模式：<a href="http://blog.csdn.net/oDeviloo/article/details/52671340">http://blog.csdn.net/oDeviloo/article/details/52671340</a></li>
<li>访问者模式：<a href="http://blog.csdn.net/oDeviloo/article/details/53462758">http://blog.csdn.net/oDeviloo/article/details/53462758</a></li>
</ol>

<p></p><center> <br />
<img src="http://img.blog.csdn.net/20160831101113992" alt="设计模式之间关系" title="" /> <br />
图片出处《设计模式》一书</center><p></p>

<h1 id="二设计模式六大原则">二、设计模式六大原则</h1>



<h2 id="1-单一职责原则">1. 单一职责原则</h2>

<p><font color="green"><strong>定义：</strong></font>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。如果一个类包含多种职责，就应该把类拆分。</p>

<p><font color="red"><strong>场景：</strong></font>如果类A有两个职责：d1，d2。当职责d1需要修改时，可能会导致原本运行正常的职责d2功能产生问题。</p>

<p><font color="green"><strong>方案：</strong></font>如果一个类包含多种职责，就应该把类拆分。分别建立两个类A、B，让A负责d1，B负责d2。当需要修改某一职责，那么将不会对另外一个功能产生影响。</p>



<h2 id="2-里氏替换原则">2. 里氏替换原则</h2>

<p><font color="green"><strong>定义：</strong></font>这一原则与继承紧密相关。如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。所有引用基类的地方必须能透明地使用其子类的对象。</p>

<p><font color="red"><strong>场景：</strong></font>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 我们需要完成一个两数相减的功能，由类A来负责。</span>
class A{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b){
        <span class="hljs-keyword">return</span> a-b;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Client{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        A a = <span class="hljs-keyword">new</span> A();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"100-50="</span>+a.func1(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>));
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"100-80="</span>+a.func1(<span class="hljs-number">100</span>, <span class="hljs-number">80</span>));
    }
} </code></pre>



<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">运行结果：

100-50</span>=<span class="hljs-string">50

100-80=20</span></code></pre>

<p>如果我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。</p>

<p>那么类B则要完成两个功能： <br />
 - 两数相减 <br />
 - 两数相加，然后再加100</p>

<p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p>



<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">A</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> func1(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b){
        <span class="hljs-keyword">return</span> a+b;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> func2(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b){
        <span class="hljs-keyword">return</span> func1(a,b)+<span class="hljs-number">100</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args){
        B b = <span class="hljs-keyword">new</span> B();
        System.out.println(<span class="hljs-string">"100-50="</span>+b.func1(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>));
        System.out.println(<span class="hljs-string">"100-80="</span>+b.func1(<span class="hljs-number">100</span>, <span class="hljs-number">80</span>));
        System.out.println(<span class="hljs-string">"100+20+100="</span>+b.func2(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>));
    }
} </code></pre>



<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">类B完成后，运行结果：

100-50</span>=<span class="hljs-string">150

100-80=180

100+20+100=220</span></code></pre>

<p><font color="green"><strong>方案：</strong></font>当使用继承时，遵循里氏替换原则。子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>

<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。</li>
</ul>



<h2 id="3-依赖倒置原则">3. 依赖倒置原则</h2>

<p><font color="green"><strong>定义：</strong></font>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>

<p><font color="red"><strong>场景：</strong></font>类A的方法依赖类B，如果需要A通过C来实现同样的功能，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>



<pre class="prettyprint"><code class=" hljs cs">
class Book{
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"书中的故事"</span>;
    }
}

class Mother{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">narrate</span>(Book book){
        System.<span class="hljs-keyword">out</span>.println(book.getContent());
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Client{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        Mother mother = <span class="hljs-keyword">new</span> Mother();
        mother.narrate(<span class="hljs-keyword">new</span> Book());
    }
} </code></pre>



<pre class="prettyprint"><code class=" hljs ">运行结果：

书中的故事</code></pre>

<p>假如有一天，我们不是给书而是给一份报纸，让这位母亲读下报纸上的事。报纸代码如下：</p>



<pre class="prettyprint"><code class=" hljs cs">class Newspaper{
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"报纸上的新闻"</span>;
    }
} </code></pre>

<p>我们会发现一个问题，我们需要修改原来的narrate，将入参修改。或者，我们可以新建一个方法。但是，这样也需要修改Mother的代码。使用面向接口编程，会很好的解决这个问题</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">narrate</span>(Newspaper papper){
        System.<span class="hljs-keyword">out</span>.println(papper.getContent());
}</code></pre>

<p><font color="green"><strong>方案：</strong></font>通过面向接口编程，将方法的参数类型设置为接口。而之前的具体实现类来实现接口中的方法。</p>



<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">IReader</span>{</span>
    <span class="hljs-keyword">public</span> String getContent(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"书中的故事"</span>;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Newspaper</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">IReader</span>{</span>
    <span class="hljs-keyword">public</span> String getContent(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"报纸上的新闻"</span>;
    }
} 

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mother</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> narrate(IReader reader){
        System.out.println(reader.getContent());
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args){
        Mother mother = <span class="hljs-keyword">new</span> Mother();
        mother.narrate(<span class="hljs-keyword">new</span> Book());
        mother.narrate(<span class="hljs-keyword">new</span> Newspaper());
    }
}</code></pre>



<h2 id="4-接口隔离原则">4. 接口隔离原则</h2>

<p><font color="green"><strong>定义：</strong></font>实现类不应该依赖它不需要实现接口具体方法的接口。</p>

<p><font color="red"><strong>场景：</strong></font>接口A需要实现方法a、b、c，具体实现类B实现方法a、b，实现类C实现a、c。所以B,C需要实现它们不需要的方法。</p>

<p><font color="green"><strong>方案：</strong></font>将接口A继续拆分为独立的几个接口，类B和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>



<h2 id="5-迪米特法则最少知道原则">5. 迪米特法则(最少知道原则)</h2>

<p><font color="green"><strong>定义：</strong></font>一个对象应该对其他对象保持最少的了解。也就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>

<p><font color="red"><strong>场景：</strong></font>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 总公司员工</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Employee {
}

<span class="hljs-comment">// 子公司员工</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ChildEmployee {
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ChildEmployeeService {
    <span class="hljs-comment">// 输出所有子公司员工</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllChildEmployee</span>() {
        List&lt;ChildEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;ChildEmployee&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">30</span>; i++){
            ChildEmployee emp = <span class="hljs-keyword">new</span> ChildEmployee();
            list.add(emp);
        }

        <span class="hljs-keyword">for</span> (ChildEmployee childEmployee : list) {
            System.<span class="hljs-keyword">out</span>.println(childEmployee);
        }
    }

}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> EmployeeService {
    <span class="hljs-comment">// 输出所有总公司员工</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span>() {
        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            list.add(emp);
        }

        <span class="hljs-keyword">for</span> (Employee employee : list) {
            System.<span class="hljs-keyword">out</span>.println(employee);
        }
    }

    <span class="hljs-comment">// 输出所有公司员工</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEmployee</span>() {
        <span class="hljs-comment">// 输出所有子公司员工</span>
        List&lt;ChildEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;ChildEmployee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
            ChildEmployee emp = <span class="hljs-keyword">new</span> ChildEmployee();
            list.add(emp);
        }

        <span class="hljs-keyword">for</span> (ChildEmployee childEmployee : list) {
            System.<span class="hljs-keyword">out</span>.println(childEmployee);
        }

        <span class="hljs-comment">// 输出所有总公司员工</span>
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            list2.add(emp);
        }

        <span class="hljs-keyword">for</span> (Employee employee : list2) {
            System.<span class="hljs-keyword">out</span>.println(employee);
        }
    }
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Test {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        EmployeeService e = <span class="hljs-keyword">new</span> EmployeeService();
        e.printEmployee();
    }
}</code></pre>

<p>现在这个设计的主要问题出在EmployeeService中，根据迪米特法则，只与直接的朋友发生通信，而ChildEmployee类和EmployeeService类并不应该有直接关系，从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，而和分公司员工的相关操作应该交给分公司来处理。</p>

<p><font color="green"><strong>方案：</strong></font>软件编程的总的原则：低耦合，高内聚。尽量降低类与类之间的耦合。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 修改EmployeeService类printEmployee方法，让总公司调用子公司的业务方法来实习和子公司员工的解耦合</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEmployee</span>(ChildEmployeeService service) {
        <span class="hljs-comment">// 输出所有子公司员工</span>
        service.printAllChildEmployee();

        <span class="hljs-comment">// 输出所有总公司员工</span>
        List&lt;Employee&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Employee&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) {
            Employee emp = <span class="hljs-keyword">new</span> Employee();
            list2.add(emp);
        }

        <span class="hljs-keyword">for</span> (Employee employee : list2) {
            System.<span class="hljs-keyword">out</span>.println(employee);
        }
 }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Test {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        EmployeeService e = <span class="hljs-keyword">new</span> EmployeeService();
        e.printEmployee(<span class="hljs-keyword">new</span> ChildEmployeeService());
    }
}</code></pre>



<h2 id="6-开闭原则">6. 开闭原则</h2>

<p><font color="green"><strong>定义：</strong></font>对扩展开放，对修改关闭</p>

<p><font color="red"><strong>场景：</strong></font>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误</p>

<p><font color="green"><strong>方案：</strong></font>当软件需要变化时，不应该通过修改已有的代码来实现变化，而是尽量通过扩展原有代码。这是为了使程序的扩展性好，易于维护和升级。</p></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
