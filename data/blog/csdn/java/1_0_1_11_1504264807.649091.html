
<p>1、类级别的延迟加载</p><p> 1、<br /> <br />  是通过session.load方法实现的<br />  <br />  在映射文件中：<br />  <br />   &lt;class name="cn.itcast.hibernate717.lazy.Customer" table="customer" catalog="test" lazy="true"&gt;<br />   <br />   lazy表示延迟加载<br />   <br /> 2、   当映射文件中，class元素的属性lazy为false时，session.load将不采用延迟加载的策略<br />    <br /> 3、<br /> <br />  Session session = HibernateSessionFactory.getSession();<br />  Customer customer = (Customer)session.load(Customer.class, 2);//customer是一个代理对象<br />  System.out.println(customer.getId());//加载ID的时候，是不发出sql语句的    标示符<br />  System.out.println(customer.getName());//加载一般属性的时候，发出sql语句<br />  session.close();<br />  <br /> 4、类级别的延迟加载只针对一般属性起作用<br /> <br /> <br /> 5、当获取一般属性的值时，才要发出sql语句去加载这个值<br />  </p><p>2、属性级别的延迟加载  (JPA)</p><p> </p><p>3、集合的延迟加载</p><p> lazy    <br /> <br />  true    在加载集合中的数据的时候，发出sql语句  Iterator&lt;Orders&gt; iterator = ordersSet.iterator();<br />  <br />  <br />  false   在加载类级别的对象时就会发出sql语句   Customer customer = (Customer)session.get(Customer.class, 2);<br />  <br />    发出两条sql语句   <br />    <br />        1、查询customer表<br />        2、查询order表<br />  <br />  <br />  extra    更进一步的延迟加载策略<br />  <br />    在执行ordersSet.size()时，只会提取出这个表中的行数，属性的值是不提取出来的<br />    <br />    <br />    <br /> 当类的延迟加载为true时，并且执行的是session.load方法时，这个时候，集合的延迟加载设置成lazy="false"是不起作用的<br />    <br />    </p><p>4、单端的延迟加载</p><p><br /> 在加载多的一方时怎么样去加载一的一方：<br /> <br />  在many-to-one中，把lazy设置成false时，<br />  <br />      在得到Order时，就把customer的数据也加载出来了<br />      <br />      如果lazy设置成proxy时<br />      <br />      在得到order对象时，是不会加载customer对象中的数据，只有当customer执行get方法时，才要发出sql语句去加载其属性</p><p><br />说明一点：</p><p> 发出sql语句只能在session的环境下进行<br /> <br /> <br />总结：</p><p> 1、类级别的延迟加载<br /> <br />  在加载一个对象的时候，采取的加载策略<br />  <br />  <br /> 2、关联级别的延迟加载<br /> <br />  在加载一个对象时，这个对象关联的对象的延迟加载策略<br /> <br /> <br /> <br /> <br /> 延迟加载是hibernate为了提升性能的一种方式<br /></p>   &#13;
