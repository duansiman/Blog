

<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
近段时间以来，通过接触有关海量数据处理和搜索引擎的诸多技术，常常见识到不少精妙绝伦的架构图。除了每每感叹于每幅图表面上的绘制的精细之外，更为架构图背后所隐藏的设计思想所叹服。个人这两天一直在搜集各大型网站的架构设计图，一为了一饱眼福，领略各类大型网站架构设计的精彩之外，二来也可供闲时反复琢磨体会，何乐而不为呢?特此，总结整理了诸如国外<strong>wikipedia，Facebook，Yahoo！，YouTube，MySpace，Twitter</strong>，国内如<strong>优酷网</strong>等大型网站的技术架构（本文重点分析优酷网的技术架构），以飨读者。</p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    本文着重凸显每一幅图的精彩之处与其背后含义，而图的说明性文字则从简从略。ok，好好享受此番架构盛宴吧。当然，若有任何建议或问题，欢迎不吝指正。谢谢。</p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
 </p>&#13;
<h3 style="margin:10px 0px; font-size:16px; color:rgb(102,102,102); font-family:Verdana">&#13;
<a target="_blank" name="t0" id="t0"></a><span style="line-height:1.5">1、WikiPedia 技术架构</span></h3>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
 <img src="http://images.cnitblog.com/blog/34296/201302/21110842-5cfe7148f045455b8dd6207bcecc0368.png" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
 </p>&#13;
<ol dir="ltr" style="padding-left:50px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<li style="list-style-type:decimal">来自wikipedia的数据：峰值每秒钟3万个 <acronym title="HyperText Transfer Protocol">HTTP</acronym> 请求 每秒钟 <acronym title="Third Generation Mobile standard">3G</acronym><strong>bit</strong>流量, 近乎<strong>375MB</strong> 350 台 <acronym title="Personal Computer">PC</acronym> 服务器。</li><li style="list-style-type:decimal">GeoDNSA ：40-line patch for BIND to add geographical filters support to the existent views in BIND", 把用户带到最近的服务器。GeoDNS 在 WikiPedia 架构中担当重任当然是由 WikiPedia 的内容性质决定的--面向各个国家，各个地域。</li><li style="list-style-type:decimal">负载均衡：LVS，请看下图：</li></ol>&#13;
<h3 style="margin:10px 0px; font-size:16px; color:rgb(102,102,102); font-family:Verdana">&#13;
<a target="_blank" name="t1" id="t1"></a><span style="line-height:1.5">2、Facebook 架构</span></h3>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
<img src="http://images.cnitblog.com/blog/34296/201302/21110910-b694454de69b4156b2757977f3a9a852.png" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
Facebook 搜索功能的架构示意图</p>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    细心的读者一定能发现，上副架构图之前出现在此文之中：从几幅架构图中偷得半点海里数据处理经验。本文与前文最大的不同是，前文只有几幅，此文系列将有上百幅架构图，任您尽情观赏。</p>&#13;
<ul style="list-style-position:initial; margin:0px 0px 10px 45px; padding-left:0px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif">&#13;
<li style="list-style:inherit!important">&#13;
<h3 style="margin:10px 0px; font-size:16px; color:rgb(102,102,102); font-family:Verdana">&#13;
<a target="_blank" name="t2" id="t2"></a><span style="line-height:1.5">4、twitter技术架构</span></h3>&#13;
</li></ul>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21110930-b817b74d680a42059a9a37952d7c805b.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:1.5; margin:10px auto">                                                     <span style="line-height:1.5">twitter的整体架构设计图</span></p>&#13;
</blockquote>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    twitter平台大致由twitter.com、手机以及第三方应用构成，如下图所示（其中流量主要以手机和第三方为主要来源）：</p>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21110939-03f8dc7cd03544a984b1c8a8c132b80d.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
</blockquote>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    缓存在大型web项目中起到了举足轻重的作用，毕竟数据越靠近CPU存取速度越快。下图是twitter的缓存架构图：</p>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
<img src="http://images.cnitblog.com/blog/34296/201302/21111007-e952e77db09c4ac49c80ba239b449270.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    关于缓存系统，还可以看看下幅图：</p>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p dir="ltr" style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21111020-15fec898cce84c2e82149fd04ebd4940.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
</blockquote>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
 </p>&#13;
<ul style="list-style-position:initial; margin:0px 0px 10px 45px; padding-left:0px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif">&#13;
<li style="list-style:inherit!important">&#13;
<h3 style="margin:10px 0px; font-size:16px; color:rgb(102,102,102); font-family:Verdana">&#13;
<a target="_blank" name="t3" id="t3"></a><span style="line-height:1.5">6、Amazon技术架构</span></h3>&#13;
</li></ul>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21111033-fe179ce501eb40d9b81d6cdca3a746bb.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p dir="ltr" style="line-height:1.5; margin:10px auto">                                    Amazon的Dynamo Key-Value存储架构图</p>&#13;
</blockquote>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    可能有读者并不熟悉Amazon，它现在已经是全球商品品种最多的网上零售商和全球第2大互联网公司。而之前它仅仅是一个小小的网上书店。ok，下面，咱们来见识下它的架构。</p>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    Dynamo是亚马逊的key-value模式的存储平台，可用性和扩展性都很好，性能也不错：读写访问中99.9%的响应时间都在300ms内。按分布式系统常用的哈希算法切分数据，分放在不同的node上。Read操作时，也是根据key的哈希值寻找对应的node。Dynamo使用了 Consistent Hashing算法，node对应的不再是一个确定的hash值，而是一个hash值范围，key的hash值落在这个范围内，则顺时针沿ring找，碰到的第一个node即为所需。</p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    Dynamo对Consistent Hashing算法的改进在于：它放在环上作为一个node的是一组机器（而不是memcached把一台机器作为node），这一组机器是通过同步机制保证数据一致的。</p>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    下图是分布式存储系统的示意图，读者可观摩之：</p>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p dir="ltr" style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21111043-3ec08545b1754b98919e1022aadfa6ec.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
</blockquote>&#13;
<p dir="ltr" style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    Amazon的云架构图如下：</p>&#13;
<blockquote dir="ltr" style="border:2px solid rgb(239,239,239); color:rgb(51,51,51); margin-left:25px; padding:5px 10px; margin-top:10px; margin-bottom:10px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<p style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21111058-c7b436a717e345358f1afa56fe49a777.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p dir="ltr" style="line-height:1.5; margin:10px auto">                                           Amazon的云架构图</p>&#13;
</blockquote>&#13;
<ul dir="ltr" style="list-style-position:initial; margin:0px 0px 10px 45px; padding-left:0px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif">&#13;
<li style="list-style:inherit!important">&#13;
<h3 style="margin:10px 0px; font-size:16px; color:rgb(102,102,102); font-family:Verdana">&#13;
<a target="_blank" name="t4" id="t4"></a><span style="line-height:1.5">7、优酷网的技术架构</span></h3>&#13;
</li></ul>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    从一开始，优酷网就自建了一套CMS来解决前端的页面显示，各个模块之间分离得比较恰当，前端可扩展性很好，UI的分离，让开发与维护变得十分简单和灵活，下图是优酷前端的模块调用关系：</p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
<img src="http://images.cnitblog.com/blog/34296/201302/21111111-5c7d14f7a8c04f018cd80b1b8204a722.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    这样，就根据module、method及params来确定调用相对独立的模块，显得非常简洁。下图是优酷的前端局部架构图：</p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
<img src="http://images.cnitblog.com/blog/34296/201302/21111123-3fe94dec33584450a161867190ff3579.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:19.5px; margin:10px auto; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">&#13;
    优酷的数据库架构也是经历了许多波折，从一开始的单台MySQL服务器（Just Running）到简单的MySQL主从复制、SSD优化、垂直分库、水平sharding分库。</p>&#13;
<ol style="padding-left:50px; color:rgb(75,75,75); font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px; line-height:19.5px">&#13;
<ol style="padding-left:50px">&#13;
<li style="list-style-type:decimal"><strong>简单的MySQL主从复制。</strong><br />&#13;
MySQL的主从复制解决了数据库的读写分离，并很好的提升了读的性能，其原来图如下：<img src="http://images.cnitblog.com/blog/34296/201302/21111136-cef8e55ff5a2446b9e7542e952b0e90b.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></li><li style="list-style-type:decimal">&#13;
<p style="line-height:1.5; margin:10px auto"><img src="http://images.cnitblog.com/blog/34296/201302/21111148-ab84a468a1fb42d88bc0237683461caf.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:1.5; margin:10px auto">但是，主从复制也带来其他一系列性能瓶颈问题：</p>&#13;
<ol style="padding-left:50px">&#13;
<li style="list-style-type:decimal">写入无法扩展</li><li style="list-style-type:decimal">写入无法缓存</li><li style="list-style-type:decimal">复制延时</li><li style="list-style-type:decimal">锁表率上升</li><li style="list-style-type:decimal">表变大，缓存率下降</li></ol>&#13;
<p style="line-height:1.5; margin:10px auto">那问题产生总得解决的，这就产生下面的优化方案。</p>&#13;
</li><li style="list-style-type:decimal">&#13;
<p style="line-height:1.5; margin:10px auto"> <strong>MySQL垂直分区</strong></p>&#13;
<p style="line-height:1.5; margin:10px auto">    如果把业务切割得足够独立，那把不同业务的数据放到不同的数据库服务器将是一个不错的方案，而且万一其中一个业务崩溃了也不会影响其他业务的正常进行，并且也起到了负载分流的作用，大大提升了数据库的吞吐能力。经过垂直分区后的数据库架构图如下：<img src="http://images.cnitblog.com/blog/34296/201302/21111216-533a024bea8042ecb2599a6b2c0b1855.gif" alt="" style="border:0px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="line-height:1.5; margin:10px auto">    然而，尽管业务之间已经足够独立了，但是有些业务之间或多或少总会有点联系，如用户，基本上都会和每个业务相关联，况且这种分区方式，也不能解决单张表数据量暴涨的问题，因此为何不试试水平sharding呢？</p>&#13;
</li><li style="list-style-type:decimal">&#13;
<p style="line-height:1.5; margin:10px auto"> <strong>MySQL水平分片（Sharding）</strong></p>&#13;
<p style="line-height:1.5; margin:10px auto">    这是一个非常好的思路，将用户按一定规则（按id哈希）分组，并把该组用户的数据存储到一个数据库分片中，即一个sharding，这样随着用户数量的增加，只要简单地配置一台服务器即可，原理图如下：<img src="http://images.cnitblog.com/blog/34296/201302/21111227-3d80f5adc9924fa2ac5d784b8d92c2d6.gif" alt="" style="border:0px" /></p>&#13;
<p style="line-height:1.5; margin:10px auto">  如何来确定某个用户所在的shard呢，可以建一张用户和shard对应的数据表，每次请求先从这张表找用户的shard id，再从对应shard中查询相关数据，如下图所示：<img src="http://images.cnitblog.com/blog/34296/201302/21111238-ee4659b011fa41778a6d34f1e1a9a11c.gif" alt="" style="border:0px" /> &#13;
   但是，优酷是如何解决跨shard的查询呢，这个是个难点，据介绍优酷是尽量不跨shard查询，实在不行通过多维分片索引、分布式搜索引擎，下策是分布式数据库查询（这个非常麻烦而且耗性能）。</p>&#13;
</li><li style="list-style-type:decimal">&#13;
<p style="line-height:1.5; margin:10px auto"> <strong>缓存策略</strong></p>&#13;
<p style="line-height:1.5; margin:10px auto">貌似大的系统都对“缓存”情有独钟，从http缓存到memcached内存数据缓存，但优酷表示没有用内存缓存，理由如下：</p>&#13;
<ol style="padding-left:50px">&#13;
<li style="list-style-type:decimal">避免内存拷贝，避免内存锁</li><li style="list-style-type:decimal">如接到老大哥通知要把某个视频撤下来，如果在缓存里是比较麻烦的</li></ol>&#13;
<p style="line-height:1.5; margin:10px auto">而且Squid 的 write() 用户进程空间有消耗，Lighttpd 1.5 的 AIO(异步I/O) 读取文件到用户内存导致效率也比较低下。</p>&#13;
<p style="line-height:1.5; margin:10px auto">但为何我们访问优酷会如此流畅，与土豆相比优酷的视频加载速度略胜一筹？这个要归功于优酷建立的比较完善的内容分发网络（CDN），它通过多种方式保证分布在全国各地的用户进行就近访问——用户点击视频请求后，优酷网将根据用户所处地区位置，将离用户最近、服务状况最好的视频服务器地址传送给用户，从而保证用户可以得到快速的视频体验。这就是CDN带来的优势，就近访问。</p>&#13;
</li></ol>&#13;
</ol>&#13;
   &#13;
