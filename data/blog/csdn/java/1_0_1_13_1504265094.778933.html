

<p>类图</p>&#13;
<p><img src="http://img.blog.csdn.net/20141010153224381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamp3d21scDQ1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="430" height="300" alt="" /><br />&#13;
</p>&#13;
<p></p><pre name="code" class="java">/**
 * 业务流程模板，提供基本框架
 * @author stone
 *
 */
public abstract class BaseTemplate {
	
	public abstract void part1();

	public abstract void part2();

	public abstract void part3();

	//这里为了严格实验结果，使用final不可被重写
	public final void useTemplateMethod() {
		part1();
		part2();
		part3();
	}
}</pre><br />&#13;
<pre name="code" class="java">/**
 * 模板实现方式1
 * @author stone
 *
 */
public class TemplateMethod extends BaseTemplate {

	@Override
	public void part1() {
		System.out.println("模板方法1");
	}

	@Override
	public void part2() {
		System.out.println("模板方法2");
	}

	@Override
	public void part3() {
		System.out.println("模板方法3");
	}

}
</pre><br />&#13;
<pre name="code" class="java">/**
 * 模板实现方式2
 * @author stone
 *
 */
public class TemplateMethod2 extends BaseTemplate {

	@Override
	public void part1() {
		System.out.println("模板方法11");
	}

	@Override
	public void part2() {
		System.out.println("模板方法22");
	}

	@Override
	public void part3() {
		System.out.println("模板方法33");
	}
	
}</pre><br />&#13;
<pre name="code" class="java">/**
 * 模板方法(TemplateMethod)模式：行为型模式,定义了一系列操作的骨架，将模块的实现 延迟到实现类或者子类中实现。
 * 跟建造者模式的区别：
 * 		建造者模式，使用组合方式，由指挥者Director指挥组合的Builder建造，建造流程由Director控制，建造的模块方法由Builder实现
 * 		模板方法模式，由模板定义操作流程，由子类或实现类 实现具体的模块方法
 * 		综上，建造者模式灵活于模板方法模式
 * @author stone
 *
 */
public class Test {
	public static void main(String[] args) {
		BaseTemplate tm = new TemplateMethod();
		tm.useTemplateMethod();
		
		System.out.println("");
		
		BaseTemplate tm2 = new TemplateMethod2();
		tm2.useTemplateMethod();
	}
}</pre><br />&#13;
打印&#13;
<p></p><pre name="code" class="plain">模板方法1
模板方法2
模板方法3

模板方法11
模板方法22
模板方法33
</pre><br />&#13;
<br />&#13;
&#13;
   &#13;
