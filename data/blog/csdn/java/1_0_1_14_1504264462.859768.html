

<p><span style="font-size:14px"><span style="font-size:32px">一、hibernate入门</span><br />&#13;
</span></p>&#13;
<h2><span style="font-size:14px"><span style="font-size:18px">1.hibernate简介：</span><br />&#13;
</span></h2>&#13;
<ul>&#13;
<li><span style="font-size:14px">Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的<a target="_blank" href="http://baike.baidu.com/view/1507.htm">J2EE</a>架构中取代CMP，完成<a target="_blank" href="http://baike.baidu.com/view/4549557.htm">数据持久化</a>的重任。</span></li></ul>&#13;
<ul>&#13;
<li><span style="font-size:14px"></span>&#13;
<p><span style="color:#333399">Hibernate</span><span style="color:#333399">是一个开放源码的、非常优秀、成熟的</span><span style="color:#333399">O/R Mapping</span><span style="color:#333399">框架。</span><span style="color:black">它提供了强大、高性能的</span><span style="color:black">Java</span><span style="color:black">对象和关系数据的持久化和查询功能。</span></p>&#13;
</li></ul>&#13;
<ul>&#13;
<li><span style="font-size:14px"></span>&#13;
<p><span style="color:black">   </span>Hibernate <span style="color:black">只是一个</span><span style="color:#333399">将持久化类与数据库表相映射</span><span style="color:black">的工具，每个持久化类</span><span style="color:#333399">实例</span><span style="color:black">均对应于数据库表中的一条</span><span style="color:#333399">数据行</span><span style="color:black">。可以使用面向对象的方法操作此持久化类实例，完成对数据库表的插入、删除、修改等操作。</span></p>&#13;
</li></ul>&#13;
<ul>&#13;
<li><span style="font-size:14px"></span>&#13;
<p><span style="color:black">    </span>利用<span style="color:black">Hibernate</span><span style="color:black">操作数据库，我们通过应用程序</span><span style="color:#333399">经过</span><span style="color:#333399">Hibernate</span><span style="color:#333399">持久层来访问数据库</span><span style="color:black">，其实</span><span style="color:black">Hibernate</span><span style="color:black">完成了以前</span><span style="color:black">JDBC</span><span style="color:black">的功能，不过</span><span style="color:black">Hibernate</span><span style="color:black">使用面向对象的方法操作数据库。</span></p>&#13;
</li></ul>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<h2><span style="font-size:14px">2.包的作用</span></h2>&#13;
<p><img src="http://img.blog.csdn.net/20160826133134962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</p>&#13;
<p><span style="color:#FF0000">常用的包介绍：</span><br />&#13;
</p>&#13;
<blockquote><strong><span style="font-size:12px">（1）hibernate3.jar: <a target="_blank" href="http://lib.csdn.net/base/17" class="replace_word" title="Java EE知识库" style="color:rgb(223,52,52)">&#13;
hibernate</a>的核心库，没有什么可说的，必须使用的jar包 </span><br />&#13;
<span style="font-size:12px">（2）cglib-asm.jar: CGLIB库，Hibernate用它来实现PO字节码的动态生成，非常核心的库，必须使用的jar包 </span><br />&#13;
<span style="font-size:12px">（3）dom4j.jar: dom4j是一个<a target="_blank" href="http://lib.csdn.net/base/17" class="replace_word" title="Java EE知识库" style="color:rgb(223,52,52)">Java</a>的XML API，类似于jdom，用来读写XML文件的。dom4j是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件，可以在SourceForge上找到它。在IBM&#13;
 developerWorks上面可以找到一篇文章，对主流的Java XML API进行的性能、功能和易用性的评测，dom4j无论在那个方面都是非常出色的。我早在将近两年之前就开始使用dom4j，直到现在。如今你可以看到越 来越多的Java软件都在使用dom4j来读写XML，特别值得一提的是连Sun的JAXM也在用dom4j。这是必须使用的jar 包，Hibernate用它来读写配置文件。</span><br />&#13;
<span style="font-size:12px">（4）odmg.jar: ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库，必须使用的jar包。</span><br />&#13;
<span style="font-size:12px">（5）commons-collections.jar： Apache Commons包中的一个，包含了一些Apache开发的集合类，功能比java.util.*强大。必须使用的jar包。</span><br />&#13;
<span style="font-size:12px">（6）commons-beanutils.jar： Apache Commons包中的一个，包含了一些Bean工具类类。必须使用的jar包。</span><br />&#13;
<span style="font-size:12px">（7）commons-lang.jar: Apache Commons包中的一个，包含了一些数据类型工具类，是java.lang.*的扩展。必须使用的jar包。</span><br />&#13;
<span style="font-size:12px">（8）commons-logging.jar: Apache Commons包中的一个，包含了日志功能，必须使用的jar包</span></strong></blockquote>&#13;
<p></p>&#13;
<p><strong><span style="font-size:12px"><br />&#13;
</span></strong></p>&#13;
<br />&#13;
<p><br />&#13;
</p>&#13;
<h2><span style="font-size:14px">3.核心接口和类</span></h2>&#13;
<blockquote><strong><span style="color:black">(1)  </span>Configuration<span style="color:black">接口</span><br />&#13;
<span style="color:black">Configuration</span><span style="color:black">接口负责管理</span><span style="color:black">Hibernate</span><span style="color:black">的配置信息。</span><span style="color:#333399">为了能够连上数据库必须配置一些属性</span><span style="color:black">，这些属性包括：</span><br />&#13;
<span style="color:black">数据库</span><span style="color:black">URL                                 </span><br />&#13;
<span style="color:black">数据库用户</span><span style="color:black">                                     </span><br />&#13;
<span style="color:black">数据库用户密码</span><span style="color:black">                                               </span><br />&#13;
<span style="color:black">数据库</span><span style="color:black">JDBC</span><span style="color:black">驱动类</span><br />&#13;
</strong>&#13;
<p><strong><span style="color:black">数据库</span><span style="color:black">dialect</span><span style="color:black">，用于对特定数据库提供支持，其中包含了针对特定数据库特性的实现。</span></strong></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><strong><span style="color:#CC0000">(2)  </span><span style="color:#CC0000">SessionFactory</span><span style="color:#CC0000">接口</span></strong></p>&#13;
<p><strong><span style="color:black">应用程序从</span><span style="color:black">SessionFactory</span><span style="color:black">（会话工厂）里获得</span><span style="color:black">Session(</span><span style="color:black">会话</span><span style="color:black">)</span><span style="color:black">实例。这里用到了一个设计模式即工厂模式，用户程序从工厂类</span><span style="color:black">SessionFactory</span><span style="color:black">中取得</span><span style="color:black">Session</span><span style="color:black">的实例。</span><span style="color:#333399">SessionFactory</span><span style="color:#333399">不是轻量级的。</span><span style="color:black">它占的资源比较多，所以它应该能在整个应用中共享。一个项目通常只需要一个</span><span style="color:black">SessionFactory</span><span style="color:black">就够了，但是当项目要操作多个数据库时，必须为每个数据库指定一个</span><span style="color:black">SessionFactory</span><span style="color:black">。</span></strong></p>&#13;
<p><strong><span style="color:black">会话工厂缓存了生成的</span><span style="color:black">SQL</span><span style="color:black">语句和</span><span style="color:black">Hibernate</span><span style="color:black">在运行时使用的映射元数据。它也保存了在一个工作单元中读入的数据并且可能在以后的工作单元中被重用（只有类和集合映射指定了使用这种二级缓存时才会如此）</span><span style="color:black">Session</span><span style="color:black">类。</span></strong></p>&#13;
<p><strong><span style="color:#CC0000">（3)  </span>Session<span style="color:#CC0000">接口——实质上是connaction的子类</span></strong></p>&#13;
<p><strong><span style="color:black">该接口是</span><span style="color:black">Hibernate</span><span style="color:black">使用最多的接口。</span><span style="color:black">Session</span><span style="color:black">不是线程安全的，它代表与数据库之间的一次操作。</span><span style="color:black">Session</span><span style="color:black">是持久层操作的基础，相当于</span><span style="color:black">JDBC</span><span style="color:black">中的</span><span style="color:black">Connection</span><span style="color:black">。然而</span><span style="color:#333399">在</span><span style="color:#333399">Hibernate</span><span style="color:#333399">中，实例化的</span><span style="color:#333399">Session</span><span style="color:#333399">是一个轻量级的类，创建和销毁它都不会占用很多资源</span><span style="color:#CC0000">。</span><span style="color:black">Session</span><span style="color:black">通过</span><span style="color:black">SessionFactory</span><span style="color:black">打开，在所有的工作完成后，需要关闭。但如果在程序中，不断地创建以及销毁</span><span style="color:black">Session</span><span style="color:black">对象，则会给系统带来不良影响。所以有时需要考虑</span><span style="color:black">session</span><span style="color:black">的管理合理的创建合理的销毁。</span></strong></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><strong><span style="color:#CC0000">(4)  </span>Query<span style="color:#CC0000">类</span></strong></p>&#13;
<p><strong><span style="color:black">Query</span><span style="color:black">类可以很方便地对数据库及持久对象进行查询，它可以有两种表达方式：</span><span style="color:#333399">查询语句使用</span><span style="color:#333399">HQL</span><span style="color:black">（</span><span style="color:black">HQL</span><span style="color:black">是</span><span style="color:black">Hibernate&#13;
 Query </span><span style="color:black">Lanaguage</span><span style="color:black">简称是</span><span style="color:black">Hibernate</span><span style="color:black">配备了一种非常强大的查询语言，类似于</span><span style="color:black">SQL</span><span style="color:black">）</span><span style="color:#333399">或者本地数据库的</span><span style="color:#333399">SQL</span><span style="color:#333399">语句编写</span><span style="color:black">。</span></strong></p>&#13;
<p><strong><span style="color:#CC0000">(5)  </span>Transaction<span style="color:#CC0000">接口</span></strong></p>&#13;
<strong><span style="color:black">       </span>如果你向数据库中增加数据或修改数据时，需要使用事务处理，这时你需要<span style="color:black">Transaction</span><span style="color:black">接口。</span><span style="color:#333399">Transaction</span><span style="color:#333399">接口是对实际事务实现的一个抽象</span><span style="color:black">，该接口可以实现</span><span style="color:black">JDBC</span><span style="color:black">的事务、</span><span style="color:black">JTA</span><span style="color:black">中的</span><span style="color:black">UserTransaction</span><span style="color:black">、甚至可以是</span><span style="color:black">CORBA</span><span style="color:black">事务等跨容器的事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移值</span></strong><br />&#13;
<br />&#13;
</blockquote>&#13;
<h2><span style="color:black"><span style="color:black">4.Hibernate</span><span style="color:black">主键</span><span style="color:black">ID</span><span style="color:black">生成方式</span></span></h2>&#13;
<blockquote><strong><span style="font-size:12px; color:#CC0000">1</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">assigned:</span><span style="font-size:12px; color:black">主键由外部程序负责生成，无需</span><span style="font-size:12px; color:black">Hibernate</span><span style="font-size:12px; color:black">参与。即当增加一个实体时，由程序设定它的</span><span style="font-size:12px; color:black">ID</span><span style="font-size:12px; color:black">值</span><span style="font-size:12px; color:black">(</span><span style="font-size:12px; color:black">手工分配值</span><span style="font-size:12px; color:black">)</span><span style="font-size:12px"><br />&#13;
<span style="color:black">&lt;classname="</span><span style="color:black">bean.Customer</span><span style="color:black">"table="customers" catalog="support"&gt;</span><br />&#13;
<span style="color:black">        </span>&lt;id name="<span style="color:black">customerId</span><span style="color:black">"type="</span><span style="color:black">java.lang.String</span><span style="color:black">"&gt;</span><br />&#13;
<span style="color:black">            </span>&lt;column name="<span style="color:black">customerID</span><span style="color:black">"length="8" /&gt;</span><br />&#13;
<span style="color:black">            </span><span style="color:black">&lt;generatorclass="</span><span style="color:#333399">assigned</span><span style="color:black">"&gt;&lt;/generator&gt;</span><br />&#13;
<span style="color:black">        </span>&lt;/id&gt;<br />&#13;
<span style="color:black">        </span>.......<br />&#13;
</span></strong>&#13;
<p><strong><span style="font-size:12px; color:black">&lt;/class&gt;</span></strong></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><strong><span style="font-size:12px; color:#CC0000">2</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">identity:</span><span style="font-size:12px; color:black">在</span><span style="font-size:12px; color:black">DB2</span><span style="font-size:12px; color:black">、</span><span style="font-size:12px; color:black">SQL&#13;
 Server</span><span style="font-size:12px; color:black">、</span><span style="font-size:12px; color:black">MySQL</span><span style="font-size:12px; color:black">等数据库产品中表中主键列可以设定是</span><span style="font-size:12px; color:#333399">自动增长列</span><span style="font-size:12px; color:black">，则</span><span style="font-size:12px; color:#333399">增加一条记录时主键的值可以不赋值</span><span style="font-size:12px; color:black">。</span><span style="font-size:12px; color:#333399">用数据库提供的主键生成机制</span><span style="font-size:12px; color:black">。</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">(1)</span><span style="font-size:12px; color:black">表结构：</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black"> </span><span style="font-size:12px">create table test1 (  <span style="color:black">tid</span><span style="color:black">int</span><span style="color:black"> not null </span>primary key<span style="color:black">auto_increment</span><span style="color:black">,</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">namechar(40));</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">  </span><span style="font-size:12px">(2)<span style="color:black">映射文件</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">    </span><span style="font-size:12px">&lt;class name="bean.Test1"table="test1" catalog="support"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px; color:black">&lt;id name="tid"type="java.lang.Integer"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;column name="</span><span style="font-size:12px; color:black">tid</span><span style="font-size:12px; color:black">"/&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;generator class="</span><span style="font-size:12px; color:#333399">identity</span><span style="font-size:12px; color:black">"&gt;&lt;/generator&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/id&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;property name="name"type="<span style="color:black">java.lang.String</span><span style="color:black">"&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px">&lt;column name="name"length="40" /&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/property&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">    </span><span style="font-size:12px">&lt;/class&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:#CC0000">3</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">increment:</span><span style="font-size:12px; color:#333399">主键按数值顺序递增</span><span style="font-size:12px; color:black">。此方式的实现机制为在当前应用实例中</span><span style="font-size:12px; color:#333399">维持一个变量，以保存着当前的最大值，之后每次需要生成主键的时候将此值加</span><span style="font-size:12px; color:#333399">1</span><span style="font-size:12px; color:#333399">作为主键</span><span style="font-size:12px; color:black">。这种方式可能产生的问题是：</span><span style="font-size:12px; color:#333399">如果当前有多个实例访问同一个数据库，那么由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常</span><span style="font-size:12px; color:black">。因此，</span><span style="font-size:12px; color:#333399">如果同一数据库有多个实例访问，此方式必须避免使用。</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">&lt;classname="bean.Test2" table="test2"catalog="support"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px; color:black">&lt;id name="tid"type="java.lang.Integer"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;column name="</span><span style="font-size:12px; color:black">tid</span><span style="font-size:12px; color:black">"/&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;generator class="</span><span style="font-size:12px; color:#333399">increment</span><span style="font-size:12px; color:black">"&gt;&lt;/generator&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/id&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;property name="name"type="<span style="color:black">java.lang.String</span><span style="color:black">"&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px">&lt;column name="name"length="40" /&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/property&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">    </span><span style="font-size:12px">&lt;/class&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:#CC0000">4</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">sequence:</span><span style="font-size:12px; color:#333399">采用数据库提供的</span><span style="font-size:12px; color:#333399">sequence</span><span style="font-size:12px; color:#333399">机制生成主键</span><span style="font-size:12px; color:black">。 </span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">     </span><span style="font-size:12px">如<span style="color:black">Oralce</span><span style="color:black">中的</span><span style="color:black">Sequence</span><span style="color:black">，在</span><span style="color:black">Oracle</span><span style="color:black">中创建序列：</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">           </span><span style="font-size:12px; color:#333399">create sequence</span><span style="font-size:12px; color:#333399">hibernate_sequence</span><span style="font-size:12px; color:#333399">;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">     </span><span style="font-size:12px">当需要保存实例时，<span style="color:black">Hibernate</span><span style="color:black">自动查询</span><span style="color:black">Oracle</span><span style="color:black">中序列</span><span style="color:black">"</span><span style="color:black">hibernate_sequence</span><span style="color:black">"</span><span style="color:black">的下一个值</span><span style="color:black">;</span><span style="color:black">该值作为主键值。可以改变默认的序列名称。</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">  </span><span style="font-size:12px">&lt;id name="<span style="color:black">sid</span><span style="color:black">"type="</span><span style="color:black">java.lang.Integer</span><span style="color:black">"&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">       </span><span style="font-size:12px">&lt;column name="<span style="color:black">sid</span><span style="color:black">"/&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">       </span><span style="font-size:12px">&lt;generator class="<span style="color:#333399">sequence</span><span style="color:black">"&gt;&lt;/generator&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">  </span><span style="font-size:12px">&lt;/id&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:#CC0000">5</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">native</span><span style="font-size:12px; color:#CC0000">：</span><span style="font-size:12px; color:black">由</span><span style="font-size:12px; color:black">Hibernate</span><span style="font-size:12px; color:black">根据底层数据库自行判断采用</span><span style="font-size:12px; color:black">identity</span><span style="font-size:12px; color:black">、</span><span style="font-size:12px; color:black">hilo</span><span style="font-size:12px; color:black">、</span><span style="font-size:12px; color:black">sequence</span><span style="font-size:12px; color:black">其中一种作为主键生成方式。</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:#CC0000">6</span><span style="font-size:12px; color:#CC0000">、</span><span style="font-size:12px; color:#CC0000">uuid.hex</span><span style="font-size:12px; color:#CC0000">：</span><span style="font-size:12px; color:#333399">由</span><span style="font-size:12px; color:#333399">Hibernate</span><span style="font-size:12px; color:#333399">为</span><span style="font-size:12px; color:#333399">ID</span><span style="font-size:12px; color:#333399">列赋值</span><span style="font-size:12px; color:black">，</span><span style="font-size:12px; color:#333399">依据当前客户端机器的</span><span style="font-size:12px; color:#333399">IP</span><span style="font-size:12px; color:#333399">、</span><span style="font-size:12px; color:#333399">JVM</span><span style="font-size:12px; color:#333399">启动时间、当前时间、一个计数器生成串，以该串为</span><span style="font-size:12px; color:#333399">ID</span><span style="font-size:12px; color:#333399">值。</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black"> </span><span style="font-size:12px">&lt;class name="bean.Test3"table="test3" catalog="support"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px; color:black">&lt;id name="tid"type="java.lang.String"&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;column name="</span><span style="font-size:12px; color:black">tid</span><span style="font-size:12px; color:black">"length="50" /&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px; color:black">&lt;generator class="</span><span style="font-size:12px; color:#333399">uuid.hex</span><span style="font-size:12px; color:black">"&gt;&lt;/generator&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/id&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;property name="name"type="<span style="color:black">java.lang.String</span><span style="color:black">"&gt;</span></span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">            </span><span style="font-size:12px">&lt;column name="name"length="40" /&gt;</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">        </span><span style="font-size:12px">&lt;/property&gt;<br />&#13;
</span></strong></p>&#13;
<p><strong><span style="font-size:12px; color:black">  </span><span style="font-size:12px">&lt;/class&gt;</span></strong></p>&#13;
</blockquote>&#13;
<h2><span style="color:black"><span style="color:black">5.Hibernate</span><span style="color:black">多表操作</span></span></h2>&#13;
<p></p>&#13;
<p>关系型数据库具有三种常用关系：<span style="color:#333399">一对一</span><span style="color:black">关系、</span><span style="color:#333399">一对多</span><span style="color:black">关系和</span><span style="color:#333399">多对多</span><span style="color:black">关系。</span></p>&#13;
<p><span style="color:black"> </span>建立了一对多关系的表之间，<span style="color:#333399">一方中的表叫</span><span style="color:#333399">“</span><span style="color:#333399">主表</span><span style="color:#333399">”</span><span style="color:#333399">，多方中的表叫</span><span style="color:#333399">“</span><span style="color:#333399">子表</span><span style="color:#333399">”</span><span style="color:black">；两表中相关联的字段，在主表中叫</span><span style="color:black">“</span><span style="color:#333399">主键</span><span style="color:black">”</span><span style="color:black">，在子表中称</span><span style="color:black">“</span><span style="color:#333399">外键</span><span style="color:black">”</span><span style="color:black">。</span></p>&#13;
<ul>&#13;
<li>&#13;
<h3><span style="color:#CC0000">一对多关系操作</span></h3>&#13;
</li></ul>&#13;
<blockquote>&#13;
<p><span style="color:black"> <strong>   </strong></span><strong>我们以院系表与学生表为例。在<span style="color:black">Hibernate</span><span style="color:black">映射中，在院系表中添加一个集合属性，集合属性存放该院系下的学生。学生表中将院系编号字段映射成一个院系类对象。这样通过院系类对象的属性集合找到该院系下的所有学生。通过学生对象的院系属性也很快定位到院系的其它信息不仅仅是院系编号。</span></strong></p>&#13;
<p><strong><span style="color:black"><span style="color:black"><span style="color:#333399">Student.hbm.xml</span></span><br />&#13;
</span></strong></p>&#13;
<p><strong><span style="color:black"></span></strong></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_1_3350366" name="code" class="html">&lt;hibernate-mapping&gt;
    &lt;class name="bean.Student" table="student" catalog="support"&gt;
        &lt;id name="sno" type="java.lang.String"&gt;
            &lt;column name="sno" length="4" /&gt;
            &lt;generator class="assigned"&gt;&lt;/generator&gt;
        &lt;/id&gt;
&lt;!--name设定待映射的持久化类的属性名--&gt;
&lt;!--column设定和持久化类的属性对应的表的外键--&gt; 
&lt;!--class设定持久化类的属性的类型--&gt;
        &lt;many-to-one name="dept" class="bean.Dept" fetch="select"&gt;
            &lt;column name="deptid" length="4" /&gt;
        &lt;/many-to-one&gt;
        &lt;property name="sname" type="java.lang.String"&gt;
            &lt;column name="sname" length="20" /&gt;
        &lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</pre><br />&#13;
<p></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><strong><span style="color:#333399">Dept.hbm.xml</span></strong></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_2_5716134" name="code" class="html">&lt;strong&gt;
&lt;hibernate-mapping&gt;
    &lt;class name="bean.Dept" table="dept" catalog="support"&gt;
        &lt;id name="deptid" type="java.lang.String"&gt;
            &lt;column name="deptid" length="4" /&gt;
            &lt;generator class="assigned"&gt;&lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="deptname" type="java.lang.String"&gt;
            &lt;column name="deptname" length="30" /&gt;
        &lt;/property&gt;
&lt;!-- name设定待映射的持久化类的属性名--&gt;
        &lt;set name="students" inverse="true"&gt;
&lt;!--所关联的持久类对应的表的外键--&gt;
            &lt;key&gt;
                &lt;column name="deptid" length="4" /&gt;
            &lt;/key&gt;
&lt;!--设定持久化所关联的类--&gt;
            &lt;one-to-many class="bean.Student" /&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
&lt;/strong&gt;</pre><br />&#13;
</blockquote>&#13;
<ul>&#13;
<li><span style="color:black"></span>&#13;
<h3><span style="color:#CC0000">多对多关系操作</span></h3>&#13;
</li></ul>&#13;
<blockquote><span style="color:black"><span style="color:#CC0000"></span></span>&#13;
<p><strong><span style="color:black">以学生与教师为例，一个教师可以教对个学生，一个学生也可以接受多个老师的教育。所以他们之间是多对多的关系。我们一般建立</span><span style="color:black">3</span><span style="color:black">个表：学生表、教师表以及学生教师表。</span></strong></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><strong><span style="color:#CC0000">学生类映射文件<span style="color:black"><span style="color:black"><span style="color:#333399">Student.hbm.xml</span></span></span></span></strong></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_3_6097818" name="code" class="html">&lt;strong&gt; &lt;class name="Student"&gt;          
         ......
        &lt;!-- name="teachers" 表示:Student类中有一个属性叫teachers (是Set集合)--&gt;  
        &lt;!-- table="teacher_student" 表示:中间关联表。表名叫teacher_student --&gt;           
        &lt;set name="teachers" table="teacher_student"&gt;  
      &lt;!-- column="student_id" 表示:中间表teacher_student的字段--&gt;  
      &lt;!-- Student类的id与中间表teacher_student的字段student_id对应--&gt;  
            &lt;key column="student_id"/&gt;              
            &lt;!-- column="teacher_id" 表示:中间表teacher_student的字段--&gt;  
            &lt;!-- class="Teacher" 表示:中间表teacher_student的字段teacher_id与 Teacher类的id对应--&gt;  
          &lt;many-to-many class="Teacher”
                                           column="teacher_id"/&gt;  
       &lt;/set&gt;  
   &lt;/class&gt;
&lt;/strong&gt;</pre>&#13;
<p><strong><span style="color:#CC0000">教师类映射文件Teacher.hbm.xml</span></strong></p>&#13;
<p><span style="color:#CC0000"></span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_4_2608045" name="code" class="html">&lt;strong&gt;&lt;span style="color:#330033;"&gt; &lt;class name="Teacher"&gt;          
        ......
       &lt;set name="students" table="teacher_student"&gt;  
            &lt;key column="teacher_id"/&gt;              
            &lt;many-to-many class="Student" 
                                                 column="student_id"/&gt;  
        &lt;/set&gt;  
    &lt;/class&gt; &lt;/span&gt;
&lt;/strong&gt;</pre><strong><br />&#13;
</strong>&#13;
<p></p>&#13;
<p><span style="color:black">       </span><strong>注意：把多对多关联</strong><span style="color:black">分解为</span><span style="color:#CC0000">两个</span><span style="color:#333399">一对多关联</span><span style="color:black">，具有更好的可扩展性和操作性。</span><span style="color:#CC0000"><span style="color:black"><br />&#13;
</span></span></p>&#13;
</blockquote>&#13;
<h2><span style="color:#CC0000"></span>&#13;
</h2><p><span style="color:#CC0000"><span style="color:black">6.级联操作与延迟加载</span></span></p>&#13;
&#13;
<blockquote><span style="font-size:14px; color:#CC0000"><span style="color:black"></span></span>&#13;
<p><span style="color:#CC0000">(1</span><span style="color:#CC0000">)、</span><span style="color:#CC0000">cascade</span><span style="color:#CC0000">级联操作</span></p>&#13;
<p><span style="color:black">    </span>所谓<span style="color:black">cascade</span><span style="color:black">，如果有两个表，在</span><span style="color:#333399">更新一方的时候</span><span style="color:black">，可以根据对象之间的关联关系，</span><span style="color:#333399">对被关联方进行相应的更新</span><span style="color:black">。比如说院系表和学生表之间是一对多关系，使用</span><span style="color:black">cascade,</span><span style="color:black">如删除院系表中的一条院系记录时，该院系下的所有学生记录也自动删除。这种现象称为</span><span style="color:#333399">级联删除</span><span style="color:black">。当创建一个新的院系实例，该院系实例集合属性中保存有学生。当该院系实例持久化时，自动将集合学生也自动添加到数据库的学生表中去。这称为</span><span style="color:#333399">级联增加</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#333399">all :</span><span style="color:black">所有情况下均进行关联操作。</span></p>&#13;
<p><span style="color:#333399">none</span><span style="color:#333399">：</span><span style="color:black">所有情况下均不进行关联操作。这是</span><span style="color:#333399">默认值</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#333399">save-update:</span><span style="color:black">执行</span><span style="color:black">save/update/</span><span style="color:black">saveOrUpdate</span><span style="color:black">时进行关联操作</span></p>&#13;
<p><span style="color:#333399">delete</span><span style="color:#333399">：</span><span style="color:black">在执行</span><span style="color:black">delete</span><span style="color:black">时进行关联操作。</span></p>&#13;
<p><span style="color:black"><br />&#13;
</span></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><span style="color:#CC0000">2</span><span style="color:#CC0000">、</span><span style="color:#CC0000">inverse</span><span style="color:#CC0000">属性（相当于你谢了字表，自动调价主表没有的字段）</span></p>&#13;
<p><span style="color:black">             </span>这个属性不好理解，打个比方来说这个属性。</p>&#13;
<p><span style="color:black">       </span>一个学校有个校长，学校里有很多学生。学生表中假设有一个字段是校长编号（多方）<span style="color:black">,</span><span style="color:black">如果我们增加一个学生，学生记录中校长编号字段如何填呢？显然学生自己填（即由学生方维护）要容易些，学生记住校长现实点。如果你要让校长填写学生的校长编号这个字段（即由校长方维护）则比较难，因为校长如何记住那么多学生呢？</span></p>&#13;
<p><span style="color:black"><br />&#13;
</span></p>&#13;
<span style="font-size:14px; color:#CC0000"><span style="color:black"><span style="color:black"></span></span></span>&#13;
<p><span style="color:#CC0000">3</span><span style="color:#CC0000">、延迟加载</span></p>&#13;
<p><span style="color:black">(1)</span><span style="color:black">属性的延迟加载</span></p>&#13;
<p><span style="color:black">       </span>如<span style="color:black">Person</span><span style="color:black">表有一个人员图片字段（对应</span><span style="color:black">java.sql.Clob</span><span style="color:black">类型）属于大数据对象，当我们加载该对象时，我们</span><span style="color:#333399">不得不每一次都要加载这个字段，而不论我们是否真的需要它</span><span style="color:black">，而且这种大数据对象的读取本身会</span><span style="color:#333399">带来很大的性能开销</span><span style="color:black">。我们</span><span style="color:#333399">可以如下配置</span><span style="color:black">我们的实体类的</span><span style="color:#333399">映射文件</span><span style="color:black">：</span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_5_7482067" name="code" class="html"> &lt;hibernate-mapping&gt;

&lt;class name="bean.Person"table="person"&gt;

……

&lt;property name="pimage"type="java.sql.Clob"

                         column="pimage"lazy="true"/&gt;

&lt;/class&gt;

 &lt;/hibernate-mapping&gt;</pre><br />&#13;
</blockquote>&#13;
<h2><span style="font-size:14px; color:#CC0000"><span style="color:black"><span style="color:black"><span style="color:black">7.Hibernate</span><span style="color:black">缓存技术</span></span></span></span></h2>&#13;
<blockquote><span style="font-size:14px; color:#CC0000"><span style="color:black"></span></span>&#13;
<p><span style="font-size:14px; color:#CC0000"><span style="color:black"><span style="color:black"><span style="color:black"></span></span></span></span></p>&#13;
<p><span style="color:black">     </span>缓存是介于物理数据源与应用程序之间，缓存被广泛用于数据库应用领域。缓存的设计就是为了<span style="color:#333399">通过存储已经从数据库读取的数据来减少应用程序和数据库之间的数据流量</span><span style="color:black">，而数据库的访问只在检索的数据不在当前缓存的时候才需要。</span></p>&#13;
<p><span style="color:#CC0000">1</span><span style="color:#CC0000">、</span><span style="color:#CC0000">Hibernate</span><span style="color:#CC0000">缓存范围以及分类</span><span style="color:black">  </span>(<span style="color:black">缓存的范围分为三类</span><span style="color:black">)</span></p>&#13;
<p><span style="color:#333399"> </span><span style="color:#333399">(1) </span><span style="color:#333399">事务范围：</span><span style="color:black">缓存只能被当前事务访问。缓存的生命周期依赖于事务的生命周期，当事务结束时，缓存也就结束生命周期。在此范围下，缓存的介质是内存。事务可以是数据库事务或者应用事务，每个事务都有独自的缓存。</span></p>&#13;
<p><span style="color:black"> </span><span style="color:#333399">(2) </span><span style="color:#333399">应用范围：</span><span style="color:black">缓存被应用范围内的所有事务共享的。这些事务有可能是并发访问缓存，因此必须对缓存采取必要的事务隔离机制。缓存的生命周期依赖于应用的生命周期，应用结束时，缓存也就结束了生命周期，二级缓存存在于应用范围。</span></p>&#13;
<p><span style="color:#333399">(3) </span><span style="color:#333399">集群范围：</span><span style="color:black">在集群环境中，缓存被一个机器或者多个机器的进程共享。缓存中的数据被复制到集群环境中的每个进程节点，进程间通过远程通信来保证缓存中的数据的一致性，缓存中的数据通常采用对象的松散数据形式，二级缓存也存在与应用范围。</span></p>&#13;
<p><span style="color:black">    </span><span style="color:#CC0000">Hibernate</span><span style="color:#CC0000">中提供了两级</span><span style="color:#CC0000">Cache</span><span style="color:#CC0000">。</span></p>&#13;
<p><span style="color:black">      </span><span style="color:#333399">第</span><span style="color:#333399">1</span><span style="color:#333399">级别的缓存</span><span style="color:black">是</span><span style="color:#333399">Session</span><span style="color:#333399">级别</span><span style="color:black">的缓存，即</span><span style="color:#333399">上述事务范围以及应用范围</span><span style="color:black">的缓存。这一级别的缓存</span><span style="color:#333399">由</span><span style="color:#333399">Hibernate</span><span style="color:#333399">管理</span><span style="color:black">的，一般无需进行干预；缓存的</span><span style="color:#333399">物理介质为内存</span><span style="color:black">，由于内存容量有限，必须通过恰当的检索策略和检索方式来</span><span style="color:#333399">限制加载对象的数目</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black">     </span><span style="color:#333399">第</span><span style="color:#333399">2</span><span style="color:#333399">级别的缓存</span><span style="color:black">是</span><span style="color:#333399">SessionFactory</span><span style="color:#333399">级别</span><span style="color:black">的缓存，属于</span><span style="color:#333399">进程范围或群集范围</span><span style="color:black">的缓存。这一级别的缓存</span><span style="color:#333399">可以进行配置和更改</span><span style="color:black">，并且可以</span><span style="color:#333399">动态加载和卸载</span><span style="color:black">。</span><span style="color:black">第</span><span style="color:black">2</span><span style="color:black">级缓存的</span><span style="color:#333399">物理介质可以是内存和硬盘</span><span style="color:black">，因此第</span><span style="color:black">2</span><span style="color:black">级缓存可以存放大量的数据，</span><span style="color:#333399">数据过期策略的</span><span style="color:#333399">maxElementsInMemory</span><span style="color:#333399">属性值</span><span style="color:black">可以控制内存中的对象数目。</span></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p>Hibernate<span style="color:black">本身并不提供</span><span style="color:black">2</span><span style="color:black">级缓存的产品化实现，而是</span><span style="color:#333399">为众多支持</span><span style="color:#333399">Hibernate</span><span style="color:#333399">的第三方缓存组件提供整合接口</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black"><br />&#13;
</span></p>&#13;
</blockquote>&#13;
<h2><span style="font-size:18px; color:#CC0000"><span style="color:black"></span></span>&#13;
</h2><p><span style="color:#CC0000"><span style="color:black"><span style="color:black"><span style="color:black"></span></span></span></span></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><span style="color:black">8.hibernate使用步骤</span></p>&#13;
&#13;
<blockquote><span style="font-size:14px; color:#CC0000"><span style="color:black"></span></span>&#13;
<p><span style="font-size:14px; color:#CC0000"><span style="color:black"><span style="color:black"><span style="color:black"></span></span></span></span></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><span style="font-size:14px; color:black"><span style="color:#333399">第</span><span style="color:#333399">1</span><span style="color:#333399">步： 先建一个</span><span style="color:#333399">Java</span><span style="color:#333399">工程导入使用</span><span style="color:#333399">Hibernate</span><span style="color:#333399">最小必要包。</span>（看要点2）</span></p>&#13;
<p><span style="font-size:14px; color:black"></span></p>&#13;
<p><span style="font-size:14px; color:#333399"></span></p>&#13;
<p><span style="font-size:14px; color:#333399">第</span><span style="font-size:14px; color:#333399">2</span><span style="font-size:14px; color:#333399">步：在</span><span style="font-size:14px; color:#333399">src</span><span style="font-size:14px; color:#333399">创建配置文件</span><span style="font-size:14px; color:#333399">hibernate.cfg.xml</span><span style="font-size:14px; color:#333399">，放置在</span><span style="font-size:14px; color:#333399">src</span><span style="font-size:14px; color:#333399">目录中。</span></p>&#13;
<p><span style="font-size:14px; color:#333399">hibernate.cfg.xml<br />&#13;
</span></p>&#13;
<p><span style="font-size:14px; color:#333399"></span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_6_7256841" name="code" class="html">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
          "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;

&lt;session-factory&gt;
    &lt;property name="connection.driver_class"&gt;
		com.mysql.jdbc.Driver
	&lt;/property&gt;
	&lt;property name="connection.url"&gt;
		jdbc:mysql://127.0.0.1:3306/hib
	&lt;/property&gt;
	&lt;property name="connection.username"&gt;root&lt;/property&gt;
	&lt;property name="connection.password"&gt;1234&lt;/property&gt;
	
	&lt;property name="dialect"&gt;
		org.hibernate.dialect.MySQLDialect
	&lt;/property&gt;

	&lt;mapping resource="cn/hncu/domain/Student.hbm.xml"/&gt;
&lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><br />&#13;
<br />&#13;
<p></p>&#13;
<p><span style="font-size:14px; color:#333399">第</span><span style="font-size:14px; color:#333399">3</span><span style="font-size:14px; color:#333399">步：编写一个会话工厂类。通过会话工厂类产生一个会话</span><span style="font-size:14px; color:#333399">Session</span><span style="font-size:14px; color:#333399">对象。</span><span style="font-size:14px; color:black">Session</span><span style="font-size:14px; color:black">对象是</span><span style="font-size:14px; color:black">Hibernate</span><span style="font-size:14px; color:black">的核心。任何对数据库操作都在会话中进行的。</span></p>&#13;
<p><span style="font-size:14px; color:black">HibernateSessionFactory.java<br />&#13;
</span></p>&#13;
<p><span style="font-size:14px; color:black"></span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_7_2447292" name="code" class="html">package cn.hncu.hib;

import org.hibernate.HibernateException;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.hibernate.classic.Session;

public class HibernateSessionFactory {
   private static String configFile = "/hibernate.cfg.xml";
   private static Configuration config = new Configuration();
   private static SessionFactory sessionFactory =null;
   
   private static final ThreadLocal&lt;Session&gt; t = new ThreadLocal&lt;Session&gt;();
   
   static{
	   try {
		   config.configure(configFile);
		   sessionFactory = config.buildSessionFactory();
		} catch (HibernateException e) {
			e.printStackTrace();
		}
   }
   
   public static Session getSession() throws HibernateException{
	   Session session = t.get();
	   if(session == null || !session.isOpen()){
		   if(sessionFactory==null){
			   rebuildSessionFactory();
		   }
		   session = (sessionFactory!=null) ? sessionFactory.openSession() : null;
		   t.set(session);
	   }
	   return session;
   }

   private static void rebuildSessionFactory() {
	   try {
		   config.configure(configFile);
		   sessionFactory = config.buildSessionFactory();
		} catch (HibernateException e) {
			e.printStackTrace();
		}
   }
   
   //关闭与数据库的会话
   public static void closeSession() throws HibernateException{
	   Session session = t.get();
	   t.set(null);
	   if(session!=null){
		   session.close();
	   }
   }
   
   
}
</pre><br />&#13;
<br />&#13;
<p></p>&#13;
<p><span style="font-size:14px; color:black"></span></p>&#13;
<p><span style="font-size:14px; color:#333399">第</span><span style="font-size:14px; color:#333399">4</span><span style="font-size:14px; color:#333399">步：编写</span><span style="font-size:14px; color:#333399">POJO</span><span style="font-size:14px; color:#333399">类以及映射文件。</span></p>&#13;
<p><span style="font-size:14px; color:#333399">POJO类<span style="color:#333399">Student.java</span></span></p>&#13;
<p><span style="font-size:14px; color:#333399"></span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_8_8194150" name="code" class="html">package cn.hncu.domain;

public class Student {
	private String studId;
	private String studName;
	private Integer age;
	

	public String getStudId() {
		return studId;
	}

	public void setStudId(String studId) {
		this.studId = studId;
	}

	public String getStudName() {
		return studName;
	}

	public void setStudName(String studName) {
		this.studName = studName;
	}

	public Integer getAge() {
		return age;
	}

	public void setAge(Integer age) {
		this.age = age;
	}

	
}
</pre><br />&#13;
Student.hib.xml<br />&#13;
<p></p>&#13;
<p><span style="font-size:14px; color:#333399"></span></p>&#13;
<pre code_snippet_id="1852055" snippet_file_name="blog_20160826_9_7321315" name="code" class="html">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="cn.hncu.domain"&gt;
  &lt;class name="Student" table="students" catalog="hib2"&gt;
     &lt;id name="studId" type="java.lang.String"&gt;
         &lt;column name="id" length="8"&gt;&lt;/column&gt;
     &lt;/id&gt;
     &lt;property name="studName" type="java.lang.String"&gt;
        &lt;column name="name" length="40" /&gt;
     &lt;/property&gt;
     &lt;property name="age" type="java.lang.Integer"&gt;
        &lt;column name="age" /&gt;
     &lt;/property&gt;
          
  &lt;/class&gt;
&lt;/hibernate-mapping&gt;</pre><br />&#13;
<br />&#13;
<p></p>&#13;
<p><span style="font-size:14px; color:#333399"></span></p>&#13;
<p><span style="font-size:14px; color:#333399">第</span><span style="font-size:14px; color:#333399">5</span><span style="font-size:14px; color:#333399">步：使用</span></p>&#13;
<br />&#13;
<br />&#13;
<br />&#13;
<br />&#13;
<p><span style="font-size:14px; color:#CC0000"><span style="color:black"><span style="color:black"><span style="color:black"></span><br />&#13;
</span></span></span></p>&#13;
</blockquote>&#13;
<h2><span style="color:#CC0000"></span>&#13;
</h2><p><span style="color:#CC0000"><span style="color:black"><br />&#13;
</span></span></p>&#13;
&#13;
<span style="color:black"><span style="color:#CC0000"></span></span>&#13;
<p><span style="color:black"></span></p>&#13;
<p><br />&#13;
</p>&#13;
<blockquote><span style="color:black"><span style="color:#CC0000"></span></span>&#13;
<p><span style="color:black"><br />&#13;
<br />&#13;
</span></p>&#13;
</blockquote>&#13;
<span style="color:black"><span style="color:#CC0000"><br />&#13;
</span></span>&#13;
<blockquote>&#13;
<p><span style="color:black"><br />&#13;
</span></p>&#13;
</blockquote>&#13;
<p><br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
   &#13;
