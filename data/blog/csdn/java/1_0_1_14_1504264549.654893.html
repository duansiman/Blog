

<p><span style="font-size:14px">前篇说到了Thread中的join方法，这一篇我们就来介绍一下suspend()和resume()方法，从字面意义上可以了解到这两个方法是一对的，suspend()方法就是将一个线程挂起(暂停)，resume()方法就是将一个挂起线程复活继续执行。首先看一个例子：</span></p>&#13;
<p><span style="font-size:14px"></span></p><pre code_snippet_id="203924" snippet_file_name="blog_20140225_1_3323838" name="code" class="java">package com.threadstop.demo;&#13;
&#13;
&#13;
import java.util.Iterator;&#13;
import java.util.Map;&#13;
import java.util.Map.Entry;&#13;
import java.util.Set;&#13;
&#13;
&#13;
/**&#13;
 * @author weijiang204321&#13;
 *说明:&#13;
 *调用了suspend方法，将t0线程挂起，但是出现的问题是，t0.suspend方法之后的代码不执行了，搞了半天终于知道为什么了，&#13;
 *因为在t0里面使用了System.out.println方法了，查看println方法的源代码发现他是个同步的方法，加锁了，这个锁是哪个呢？&#13;
 *对就是PrintStream,在Main中的printCurrentAliveThread方法中用到了System.out.println方法，打断点才知道&#13;
 *搞了半天阻塞在这里了，因为我们知道suspend方法是不释放锁的，所以导致会阻塞在println方法中，但是有一个前提是t0线程和main线程&#13;
 *的println方法中拿到的是同一个锁，这时候在看一下System.out变量时一个static PrintStream，这时候就明了了，因为是static&#13;
 *所以对象是相同的，这两个线程拿到的System.out是同一个对象，所以这两个线程也是拿到的是相同的锁的。&#13;
 *&#13;
 */&#13;
&#13;
&#13;
public class ThreadStopLock {&#13;
<span style="white-space:pre">	</span>&#13;
<span style="white-space:pre">	</span>public static void main(String[] args) {&#13;
<span style="white-space:pre">		</span>try {&#13;
<span style="white-space:pre">			</span>//定义线程&#13;
<span style="white-space:pre">			</span>Thread t0 = new Thread() {&#13;
<span style="white-space:pre">				</span>public void run() {&#13;
<span style="white-space:pre">					</span>try {&#13;
<span style="white-space:pre">						</span>for(long i=0;i&lt;1000*1000*10;i++){&#13;
<span style="white-space:pre">							</span>System.out.println(i);&#13;
<span style="white-space:pre">						</span>}&#13;
<span style="white-space:pre">						</span>System.out.println("thread death");&#13;
<span style="white-space:pre">					</span>} catch (Throwable ex) {&#13;
<span style="white-space:pre">						</span>System.out.println("Caught in run: " + ex);&#13;
<span style="white-space:pre">						</span>ex.printStackTrace();&#13;
<span style="white-space:pre">					</span>}&#13;
<span style="white-space:pre">				</span>}&#13;
<span style="white-space:pre">			</span>};&#13;
<span style="white-space:pre">			</span>//开启线程&#13;
<span style="white-space:pre">			</span>t0.start();&#13;
<span style="white-space:pre">			</span>//等待2s之后挂起线程t0&#13;
<span style="white-space:pre">			</span>Thread.sleep(2*1000);&#13;
<span style="white-space:pre">			</span>//挂起线程&#13;
<span style="white-space:pre">			</span>t0.suspend();&#13;
<span style="white-space:pre">			</span>//打印当前的所有线程&#13;
<span style="white-space:pre">			</span>printCurrentAliveThread();&#13;
<span style="white-space:pre">			</span>//等待2s之后恢复线程&#13;
<span style="white-space:pre">			</span>Thread.sleep(2*1000);&#13;
<span style="white-space:pre">			</span>//复活线程&#13;
<span style="white-space:pre">			</span>t0.resume();&#13;
<span style="white-space:pre">			</span>&#13;
<span style="white-space:pre">		</span>} catch (Throwable t) {&#13;
<span style="white-space:pre">			</span>System.out.println("Caught in main: " + t);&#13;
<span style="white-space:pre">			</span>t.printStackTrace();&#13;
<span style="white-space:pre">		</span>}&#13;
&#13;
&#13;
<span style="white-space:pre">	</span>}&#13;
<span style="white-space:pre">	</span>&#13;
<span style="white-space:pre">	</span>/**&#13;
<span style="white-space:pre">	</span> * 打印当前线程&#13;
<span style="white-space:pre">	</span> */&#13;
<span style="white-space:pre">	</span>public static void printCurrentAliveThread(){&#13;
<span style="white-space:pre">		</span>Map&lt;Thread, StackTraceElement[]&gt; maps = Thread.getAllStackTraces();&#13;
<span style="white-space:pre">		</span>Set&lt;Entry&lt;Thread, StackTraceElement[]&gt;&gt; set = maps.entrySet();&#13;
<span style="white-space:pre">		</span>Iterator&lt;Entry&lt;Thread,StackTraceElement[]&gt;&gt; iterator = set.iterator();&#13;
<span style="white-space:pre">		</span>System.out.println("System Alive Thread List:");&#13;
<span style="white-space:pre">		</span>System.out.println("-------------------------");&#13;
<span style="white-space:pre">		</span>while(iterator.hasNext()){&#13;
<span style="white-space:pre">			</span>System.out.println("AliveThread_Name:"+iterator.next().getKey().getName());&#13;
<span style="white-space:pre">		</span>}&#13;
<span style="white-space:pre">		</span>System.out.println("-------------------------");&#13;
<span style="white-space:pre">	</span>}&#13;
<span style="white-space:pre">	</span>&#13;
}
</pre>代码很简单的，定义一个线程，在线程中进行打印，在主线程中的逻辑是，先开启线程t0进行打印数据，等待2s之后将挂起线程t0，然后打印一下当前的活跃线程，然后再等待2s之后再复活t0线程继续打印！&#13;
<p><span style="font-size:14px">但是结果不尽人意呀，结果很是惊讶的！运行结果：</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20140225142704515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">好吧，开始打印，打印到311800(当然这个不是一定的)，就停止了，但是这一停止不是停2s呀，是一直停着，这不是明显的死锁吗？导致t0.suspend后面的代码都不执行了，这就郁闷了，这个是为什么呢？纠结了一下午，打断点的时候才知道为什么，断点停在方法printCurrentAliveThread中的System.out.println()这行代码上，那就可以断定了，发生死锁的原因可能就是System.out.println方法，查看源代码：</span></p>&#13;
<p><span style="font-size:14px"></span></p><pre code_snippet_id="203924" snippet_file_name="blog_20140225_2_5418171" name="code" class="java"> public void println(String x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }</pre>这个是PrintStream对象中的println方法，是个同步锁的方法，这时候应该就明白了，那么这个锁是什么呢？没错，这个所就是PrintStream对象，因为在t0线程中也有System.out.println，当调用suspend()方法调用的时候，这个方法是不会释放锁的，当然这个锁是同一个的，为什么呢？看一下System类中的out变量定义：&#13;
<p><span style="font-size:14px"></span></p><pre code_snippet_id="203924" snippet_file_name="blog_20140225_3_6606651" name="code" class="java"> public final static PrintStream out = null;</pre>是static类型的，所以他是类上面的锁，肯定是同一个锁了，所以发生了死锁，&#13;
<p><span style="font-size:14px">这时候我们将printCurrentAliveThread方法注释之后，运行就没有任何问题了。</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">就写到这里吧，好累，后面还有哦，继续关注吧！<br />&#13;
<br />&#13;
</span></p>&#13;
   &#13;
