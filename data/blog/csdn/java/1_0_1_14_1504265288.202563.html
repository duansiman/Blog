

<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39721563" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39755577" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39759199" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39784403" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39804057" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39805069" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39805735" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39806973">http://blog.csdn.net/lhy_ycu/article/details/39806973</a></strong></span><br />&#13;
</p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<span style="font-size:18px; color:rgb(255,0,0)"><br />&#13;
</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
</p>&#13;
<span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span>&#13;
<p><span style="font-size:14px">模板方法模式(Template Method)：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以再不改变算法结构的情况下，重新定义算法中的某些步骤。简而言之：模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</span></p>&#13;
<h2>一、uml建模：</h2>&#13;
<p><img src="http://img.blog.csdn.net/20141007170557137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<h2>二、代码实现：</h2>&#13;
<div><pre name="code" class="java">/**
 * 示例：模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
 * 
 * 以吃饭为例：有几个步骤 --&gt; 煮饭+烧菜+吃饭中+吃完了
 */
abstract class AbstractTemplate {

	public final void haveMeal() {
		zhuFan();
		shaoCai();
		duringMeal();
		finish();
	}

	public abstract void zhuFan();

	public abstract void shaoCai();

	public void duringMeal() {
		System.out.println("吃饭中...");
	}

	public void finish() {
		System.out.println("吃完了...");
	}
}

class Sub1 extends AbstractTemplate {

	@Override
	public void zhuFan() {
		System.out.println("使用电饭煲煮饭...");

	}

	@Override
	public void shaoCai() {
		System.out.println("使用炉灶烧菜...");
	}
}

class Sub2 extends AbstractTemplate {

	@Override
	public void zhuFan() {
		System.out.println("使用高压锅煮饭...");

	}

	@Override
	public void shaoCai() {
		System.out.println("使用电磁炉烧菜...");
	}
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
	public static void main(String[] args) {
		AbstractTemplate at1 = new Sub1();
		at1.haveMeal();
		System.out.println("\n");
		AbstractTemplate at2 = new Sub2();
		at2.haveMeal();
	}
}</pre></div>&#13;
<h2><br />&#13;
</h2>&#13;
<h2>三、总结</h2>&#13;
<p></p>&#13;
<p>模板方法模式：一个抽象类中，有一个主方法，再定义1...n个方法，可以抽象，可以不抽象，定义子类继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。<br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
</p>&#13;
   &#13;
