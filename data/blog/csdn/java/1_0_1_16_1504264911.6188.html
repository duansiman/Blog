

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">原文出自：http://blog.csdn.net/yangbutao/article/details/12242441</span></p>&#13;
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"></span></p>&#13;
<h1 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
一、 设计理念</h1>&#13;
<span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px"></span><span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px"></span>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t1" style="color:rgb(106,57,6)" id="t1"></a> </h2>&#13;
<p></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri"> </span></p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t2" style="color:rgb(106,57,6)" id="t2"></a><span style="font-family:Cambria; font-size:24px">1.</span>      <span style="font-size:24px">空间换时间</span></h2>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t3" style="color:rgb(106,57,6)" id="t3"></a><span style="font-family:Calibri; font-size:24px">1)</span>      <span style="font-size:24px">多级缓存，静态化</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
客户端页面缓存（<span style="font-family:Calibri">http header</span>中包含<span style="font-family:Calibri">Expires/Cache of Control</span>，<span style="font-family:Calibri">last modified(304</span>，<span style="font-family:Calibri">server</span>不返回<span style="font-family:Calibri">body</span>，客户端可以继续用<span style="font-family:Calibri">cache</span>，减少流量<span style="font-family:Calibri">)</span>，<span style="font-family:Calibri">ETag</span>）</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
反向代理缓存</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
应用端的缓存<span style="font-family:Calibri">(memcache)</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
内存数据库</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri">Buffer</span>、<span style="font-family:Calibri">cache</span>机制（数据库，中间件等）</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t4" style="color:rgb(106,57,6)" id="t4"></a><span style="font-family:Calibri; font-size:24px">2)</span>      <span style="font-size:24px">索引</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
哈希、<span style="font-family:Calibri">B</span>树、倒排、<span style="font-family:Calibri">bitmap</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
哈希索引适合综合数组的寻址和链表的插入特性，可以实现数据的快速存取。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri">B</span>树索引适合于查询为主导的场景，避免多次的<span style="font-family:Calibri">IO</span>，提高查询的效率。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
倒排索引实现单词到文档映射关系的最佳实现方式和最有效的索引结构，广泛用在搜索领域。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri">Bitmap</span>是一种非常简洁快速的数据结构，他能同时使存储空间和速度最优化（而不必空间换时间），适合于海量数据的的计算场景。</p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t5" style="color:rgb(106,57,6)" id="t5"></a><span style="font-family:Cambria; font-size:24px">2.</span>     <span style="font-size:24px">并行与分布式计算</span></h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri"> </span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t6" style="color:rgb(106,57,6)" id="t6"></a><span style="font-family:Calibri; font-size:24px">1)</span>      <span style="font-size:24px">任务切分、分而治之<span style="font-family:Calibri">(MR)</span></span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在大规模的数据中，数据存在一定的局部性的特征，利用局部性的原理将海量数据计算的问题分而治之。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri">MR</span>模型是无共享的架构，数据集分布至各个节点。处理时，每个节点就近读取本地存储的数据处理<span style="font-family:Calibri">(map)</span>，将处理后的数据进行合并<span style="font-family:Calibri">(combine)</span>、排序<span style="font-family:Calibri">(shuffle and sort)</span>后再分发<span style="font-family:Calibri">(</span>至<span style="font-family:Calibri">reduce</span>节点<span style="font-family:Calibri">)</span>，避免了大量数据的传输，提高了处理效率。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<span style="font-family:Calibri"> </span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t7" style="color:rgb(106,57,6)" id="t7"></a><span style="font-family:Calibri; font-size:24px">2)</span>      <span style="font-size:24px">多进程、多线程并行执行<span style="font-family:Calibri">(MPP)</span></span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
并行计算（<span style="font-family:Calibri">Parallel Computing</span>）是指同时使用多种计算资源解决计算问题的过程，是提高计算机系统计算速度和处理能力的一种有效手段。它的基本思想是用多个处理器<span style="font-family:Calibri">/</span>进程<span style="font-family:Calibri">/</span>线程来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
和<span style="font-family:Calibri">MR</span>的区别在于，它是基于问题分解的，而不是基于数据分解。</p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t8" style="color:rgb(106,57,6)" id="t8"></a><span style="font-family:Cambria; font-size:24px">3.</span>      <span style="font-size:24px">多维度的可用</span></h2>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t9" style="color:rgb(106,57,6)" id="t9"></a><span style="font-family:Calibri; font-size:24px">1)</span>      <span style="font-size:24px">负载均衡、容灾、备份</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
随着平台并发量的增大，需要扩容节点进行集群，利用负载均衡设备进行请求的分发；负载均衡设备通常在提供负载均衡的同时，也提供失效检测功能；同时为了提高可用性，需要有容灾备份，以防止节点宕机失效带来的不可用问题；备份有在线的和离线备份，可以根据失效性要求的不同，进行选择不同的备份策略。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t10" style="color:rgb(106,57,6)" id="t10"></a><span style="font-family:Calibri; font-size:24px">2)</span>      <span style="font-size:24px">读写分离</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
读写分离是对数据库来讲的，随着系统并发量的增大，提高数据访问可用性的一个重要手段就是写数据和读数据进行分离；当然在读写分离的同时，需要关注数据的一致性问题；对于一致性的问题，在分布式的系统<span style="font-family:Calibri">CAP</span>定量中，更多的关注于可用性。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t11" style="color:rgb(106,57,6)" id="t11"></a><span style="font-family:Calibri; font-size:24px">3)</span>      <span style="font-size:24px">依赖关系</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
平台中各个模块之间的关系尽量是低耦合的，可以通过相关的消息组件进行交互，能异步则异步，分清楚数据流转的主流程和副流程，主副是异步的，比如记录日志可以是异步操作的，增加整个系统的可用性。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
当然在异步处理中，为了确保数据得到接收或者处理，往往需要确认机制<span style="font-family:Calibri">(confirm</span>、<span style="font-family:Calibri">ack)</span>。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
但是有些场景中，虽然请求已经得到处理，但是因其他原因<span style="font-family:Calibri">(</span>比如网络不稳定<span style="font-family:Calibri">)</span>，确认消息没有返回，那么这种情况下需要进行请求的重发，对请求的处理设计因重发因素需要考虑幂等性。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t12" style="color:rgb(106,57,6)" id="t12"></a><span style="font-family:Calibri; font-size:24px">4)</span>      <span style="font-size:24px">监控</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
监控也是提高整个平台可用性的一个重要手段，多平台进行多个维度的监控；模块在运行时候是透明的，以达到运行期白盒化。</p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t13" style="color:rgb(106,57,6)" id="t13"></a><span style="font-family:Cambria; font-size:24px">4.</span>      <span style="font-size:24px">伸缩</span></h2>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t14" style="color:rgb(106,57,6)" id="t14"></a><span style="font-family:Calibri; font-size:24px">1)</span>      <span style="font-size:24px">拆分</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
拆分包括对业务的拆分和对数据库的拆分。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统的资源总是有限的，一段比较长的业务执行如果是一竿子执行的方式，在大量并发的操作下，这种阻塞的方式，无法有效的及时释放资源给其他进程执行，这样系统的吞吐量不高。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
需要把业务进行逻辑的分段，采用异步非阻塞的方式，提高系统的吞吐量。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
随着数据量和并发量的增加，读写分离不能满足系统并发性能的要求，需要对数据进行切分，包括对数据进行分库和分表。这种分库分表的方式，需要增加对数据的路由逻辑支持。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t15" style="color:rgb(106,57,6)" id="t15"></a><span style="font-family:Calibri; font-size:24px">2)</span>      <span style="font-size:24px">无状态</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于系统的伸缩性而言，模块最好是无状态的，通过增加节点就可以提高整个的吞吐量。</p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t16" style="color:rgb(106,57,6)" id="t16"></a><span style="font-family:Cambria; font-size:24px">5.</span>      <span style="font-size:24px">优化资源利用</span></h2>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t17" style="color:rgb(106,57,6)" id="t17"></a><span style="font-family:Calibri; font-size:24px">1)</span>      <span style="font-size:24px">系统容量有限</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统的容量是有限的，承受的并发量也是有限的，在架构设计时，一定需要考虑流量的控制，防止因意外攻击或者瞬时并发量的冲击导致系统崩溃。在设计时增加流控的措施，可考虑对请求进行排队，超出预期的范围，可以进行告警或者丢弃。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t18" style="color:rgb(106,57,6)" id="t18"></a><span style="font-family:Calibri; font-size:24px">2)</span>      <span style="font-size:24px">原子操作与并发控制</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于共享资源的访问，为了防止冲突，需要进行并发的控制，同时有些交易需要有事务性来保证交易的一致性，所以在交易系统的设计时，需考虑原子操作和并发控制。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
保证并发控制一些常用高性能手段有，乐观锁、<span style="font-family:Calibri">Latch</span>、<span style="font-family:Calibri">mutex</span>、写时复制、<span style="font-family:Calibri">CAS</span>等；多版本的并发控制<span style="font-family:Calibri">MVCC</span>通常是保证一致性的重要手段，这个在数据库的设计中经常会用到。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t19" style="color:rgb(106,57,6)" id="t19"></a><span style="font-family:Calibri; font-size:24px">3)</span>      <span style="font-size:24px">基于逻辑的不同，采取不一样的策略</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
平台中业务逻辑存在不同的类型，有计算复杂型的，有消耗<span style="font-family:Calibri">IO</span>型的，同时就同一种类型而言，不同的业务逻辑消耗的资源数量也是不一样的，这就需要针对不同的逻辑采取不同的策略。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
针对<span style="font-family:Calibri">IO</span>型的，可以采取基于事件驱动的异步非阻塞的方式，单线程方式可以减少线程的切换引起的开销，或者在多线程的情况下采取自旋<span style="font-family:Calibri">spin</span>的方式，减少对线程的切换<span style="font-family:Calibri">(</span>比如<span style="font-family:Calibri">oracle latch</span>设计<span style="font-family:Calibri">)</span>；对于计算型的，充分利用多线程进行操作。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
同一类型的调用方式，不同的业务进行合适的资源分配，设置不同的计算节点数量或者线程数量，对业务进行分流，优先执行优先级别高的业务。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t20" style="color:rgb(106,57,6)" id="t20"></a><span style="font-family:Calibri; font-size:24px">4)</span>      <span style="font-size:24px">容错隔离</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统的有些业务模块在出现错误时，为了减少并发下对正常请求的处理的影响，有时候需要考虑对这些异常状态的请求进行单独渠道的处理，甚至暂时自动禁止这些异常的业务模块。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
有些请求的失败可能是偶然的暂时的失败<span style="font-family:Calibri">(</span>比如网络不稳定<span style="font-family:Calibri">)</span>，需要进行请求重试的考虑。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t21" style="color:rgb(106,57,6)" id="t21"></a><span style="font-family:Calibri; font-size:24px">5)</span>      <span style="font-size:24px">资源释放</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统的资源是有限的，在使用资源时，一定要在最后释放资源，无论是请求走的是正常路径还是异常的路径，以便于资源的及时回收，供其他请求使用。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在设计通信的架构时，往往需要考虑超时的控制。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h1 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t22" style="color:rgb(106,57,6)" id="t22"></a>二、 静态架构蓝图</h1>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <img alt="" src="http://img.blog.csdn.net/20131002225742921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p align="left" style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
整个架构是分层的分布式的架构，纵向包括<span style="font-family:宋体">CDN，负载均衡/反向代理，web应用，业务层，基础服务层，数据存储层。水平方向包括对整个平台的配置管理部署和监控。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h1 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t23" style="color:rgb(106,57,6)" id="t23"></a>三、 剖析架构</h1>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t24" style="color:rgb(106,57,6)" id="t24"></a>1. CDN</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
CDN<span style="font-family:宋体">系统能够实时地根据</span><a target="_blank" href="http://baike.baidu.com/view/411702.htm" style="color:rgb(106,57,6); text-decoration:none">网络流量</a>和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 <span style="font-family:Calibri">Internet</span><a target="_blank" href="http://baike.baidu.com/view/2774663.htm" style="color:rgb(106,57,6); text-decoration:none">网络拥挤</a>的状况，提高用户访问网站的响应速度。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于大规模电子商务平台一般需要建<span style="font-family:Calibri">CDN</span><span style="font-family:宋体">做网络加速，大型平台如淘宝、京东都采用自建</span><span style="font-family:Calibri">CDN</span><span style="font-family:宋体">，中小型的企业可以采用第三方</span><span style="font-family:Calibri">CDN</span><span style="font-family:宋体">厂商合作</span>，如蓝汛、网宿、快网等。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
当然在选择<span style="font-family:Calibri">CDN</span><span style="font-family:宋体">厂商时，需要考虑经营时间长短，是否有可扩充的带宽资源、灵活的流量和带宽选择、稳定的节点、性价比。</span></p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t25" style="color:rgb(106,57,6)" id="t25"></a>2. 负载均衡、反向代理</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
一个大型的平台包括很多个业务域，不同的业务域有不同的集群，可以用<span style="font-family:Calibri">DNS</span><span style="font-family:宋体">做域名解析的分发或轮询，</span><span style="font-family:Calibri">DNS</span><span style="font-family:宋体">方式实现简单，但是因存在</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">而缺乏灵活性；一般基于</span>商用的硬件<span style="font-family:Calibri">F5</span>、NetScaler或者开源的软负载<span style="font-family:Calibri">lvs</span><span style="font-family:宋体">在</span><span style="font-family:Calibri">4</span><span style="font-family:宋体">层做分发，当然会采用做冗余</span>(<span style="font-family:宋体">比如</span><span style="font-family:Calibri">lvs+keepalived)</span>的考虑，采取主备方式。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
4<span style="font-family:宋体">层分发到业务集群上后，会经过</span><span style="font-family:Calibri">web</span><span style="font-family:宋体">服务器如</span><span style="font-family:Calibri">nginx</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">HAProxy</span><span style="font-family:宋体">在</span><span style="font-family:Calibri">7</span><span style="font-family:宋体">层做负载均衡或者反向代理分发到集群中的应用节点。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
选择哪种负载，需要综合考虑各种因素（是否满足高并发高性能，Session保持如何解决，负载均衡的算法如何，支持压缩，缓存的内存消耗）；下面基于几种常用的负载均衡软件做个介绍。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
LVS<span style="font-family:宋体">，工作在</span><span style="font-family:Calibri">4</span><span style="font-family:宋体">层，</span><span style="font-family:Calibri">Linux</span><span style="font-family:宋体">实现的高性能高并发、可伸缩性、可靠的的负载均衡器，支持多种转发方式</span><span style="font-family:Calibri">(NAT</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">DR</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">IP Tunneling)</span><span style="font-family:宋体">，其中</span><span style="font-family:Calibri">DR</span><span style="font-family:宋体">模式支持通过广域网进行负载均衡。支持双机热备</span><span style="font-family:Calibri">(Keepalived</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">Heartbeat)</span><span style="font-family:宋体">。对网络环境的依赖性比较高。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Nginx<span style="font-family:宋体">工作在</span><span style="font-family:Calibri">7</span><span style="font-family:宋体">层，事件驱动的、异步非阻塞的架构、支持多进程的高并发的负载均衡器</span><span style="font-family:Calibri">/</span><span style="font-family:宋体">反向代理软件。可以针对域名、目录结构、正则规则针对</span><span style="font-family:Calibri">http</span><span style="font-family:宋体">做一些分流。通过</span>端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持<span style="font-family:Calibri">url</span><span style="font-family:宋体">来检测</span>。对于<span style="font-family:Calibri">session sticky</span><span style="font-family:宋体">，可以基于</span><span style="font-family:Calibri">ip hash</span><span style="font-family:宋体">的算法来实现，通过基于cookie的扩展nginx-sticky-module支持</span><span style="font-family:Calibri">session&#13;
 sticky</span><span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HAProxy<span style="font-family:宋体">支持</span><span style="font-family:Calibri">4</span><span style="font-family:宋体">层和</span><span style="font-family:Calibri">7</span><span style="font-family:宋体">层做负载均衡，支持</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">的会话保持，</span><span style="font-family:Calibri">cookie</span><span style="font-family:宋体">的引导；支持后端</span><span style="font-family:Calibri">url</span><span style="font-family:宋体">方式的检测；负载均衡的算法比较丰富，有</span><span style="font-family:Calibri">RR</span><span style="font-family:宋体">、权重等。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于图片，需要有单独的域名，独立或者分布式的图片服务器或者如<span style="font-family:Calibri">mogileFS</span><span style="font-family:宋体">，可以图片服务器之上加</span><span style="font-family:Calibri">varnish</span><span style="font-family:宋体">做图片缓存。</span></p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t26" style="color:rgb(106,57,6)" id="t26"></a>3. App<span style="font-family:宋体">接入</span></h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
应用层运行在<span style="font-family:Calibri">jboss</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">tomcat</span><span style="font-family:宋体">容器中，代表独立的系统，比如前端购物、用户自主服务、后端系统等</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
协议接口，<span style="font-family:Calibri">HTTP</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">JSON</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
可以采用<span style="font-family:Calibri">servlet3.0,</span><span style="font-family:宋体">异步化</span><span style="font-family:Calibri">servlet,</span><span style="font-family:宋体">提高整个系统的吞吐量</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
http<span style="font-family:宋体">请求经过</span><span style="font-family:Calibri">Nginx</span><span style="font-family:宋体">，通过负载均衡算法分到到</span><span style="font-family:Calibri">App</span><span style="font-family:宋体">的某一节点，这一层层扩容起来比较简单。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
除了利用<span style="font-family:Calibri">cookie</span><span style="font-family:宋体">保存少量用户部分信息外</span><span style="font-family:Calibri">(</span>cookie<span style="font-family:宋体">一般不能超过</span><span style="font-family:Calibri">4K</span><span style="font-family:宋体">的大小</span>)<span style="font-family:宋体">，对于</span><span style="font-family:Calibri">App</span><span style="font-family:宋体">接入层，保存有用户相关的</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">数据，但是有些反向代理或者负载均衡不支持对</span><span style="font-family:Calibri">session sticky</span><span style="font-family:宋体">支持不是很好或者对接入的可用性要求比较高</span><span style="font-family:Calibri">(app</span><span style="font-family:宋体">接入节点宕机，</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">随之丢失</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，这就需要考虑</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">的集中式存储，使得</span><span style="font-family:Calibri">App</span><span style="font-family:宋体">接入层无状态化，同时</span>系统用户变多的时候，就可以通过增加更多的应用节点来达到水平扩展的目的。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Session<span style="font-family:宋体">的集中式存储，需要满足以下几点要求：</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a<span style="font-family:宋体">、高效的通讯协议</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b<span style="font-family:宋体">、</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">的分布式缓存，支持节点的伸缩，数据的冗余备份以及数据的迁移</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
c<span style="font-family:宋体">、</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">过期的管理</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t27" style="color:rgb(106,57,6)" id="t27"></a>4. 业务服务</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
代表某一领域的业务提供的服务，对于电商而言，领域有用户、商品、订单、红包、支付业务等等，不同的领域提供不同的服务，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
这些不同的领域构成一个个模块，良好的模块划分和接口设计非常重要，一般是参考高内聚、接口收敛的原则，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
这样可以提高整个系统的可用性。当然可以根据应用规模的大小，模块可以部署在一起，对于大规模的应用，一般是独立部署的。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
高并发：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
业务层对外协议以<span style="font-family:Calibri">NIO</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">RPC</span><span style="font-family:宋体">方式暴露，可以采用比较成熟的</span><span style="font-family:Calibri">NIO</span><span style="font-family:宋体">通讯框架，如</span><span style="font-family:Calibri">netty</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">mina</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
可用性：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
为了提高模块服务的可用性，一个模块部署在多个节点做冗余，并自动进行负载转发和失效转移<span style="font-family:Calibri">;</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
最初可以利用<span style="font-family:Calibri">VIP+heartbeat</span><span style="font-family:宋体">方式，目前系统有一个单独的组件</span><span style="font-family:Calibri">HA,</span><span style="font-family:宋体">利用</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">实现</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">比原来方案的优点</span><span style="font-family:Calibri">)</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
一致性、事务：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于分布式系统的一致性，尽量满足可用性，一致性可以通过校对来达到最终一致的状态。</p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t28" style="color:rgb(106,57,6)" id="t28"></a>5. 基础服务中间件</h2>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t29" style="color:rgb(106,57,6)" id="t29"></a>1) 通信组件</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通信组件用于业务系统内部服务之间的调用，在大并发的电商平台中，需要满足高并发高吞吐量的要求。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
整个通信组件包括客户端和服务端两部分。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
客户端和服务器端维护的是长连接，可以减少每次请求建立连接的开销，在客户端对于每个服务器定义一个连接池，初始化连接后，可以并发连接服务端进行<span style="font-family:Calibri">rpc</span><span style="font-family:宋体">操作，连接池中的长连接需要心跳维护，设置请求超时时间。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于长连接的维护过程可以分两个阶段，一个是发送请求过程，另外一个是接收响应过程。在发送请求过程中，若发生<span style="font-family:Calibri">IOException</span><span style="font-family:宋体">，则把该连接标记失效。接收响应时，服务端返回</span>SocketTimeoutException，如果设置了超时时间，那么就直接返回异常，清除当前连接中那些超时的请求。否则继续发送心跳包<span style="font-family:Calibri">(</span><span style="font-family:宋体">因为可能是丢包，超过</span><span style="font-family:Calibri">pingInterval</span><span style="font-family:宋体">间隔时间就发送</span><span style="font-family:Calibri">ping</span><span style="font-family:宋体">操作</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，若</span><span style="font-family:Calibri">ping</span><span style="font-family:宋体">不通</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">发送</span><span style="font-family:Calibri">IOException)</span><span style="font-family:宋体">，则说明当前连接是有问题的，那么就把当前连接标记成已经失效；若</span><span style="font-family:Calibri">ping</span><span style="font-family:宋体">通，则说明当前连接是可靠的，继续进行读操作。失效的连接会从连接池中清除掉。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
每个连接对于接收响应来说都以单独的线程运行，客户端可以通过同步<span style="font-family:Calibri">(wait,notify)</span><span style="font-family:宋体">方式或者异步进行</span><span style="font-family:Calibri">rpc</span><span style="font-family:宋体">调用，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
序列化采用更高效的<span style="font-family:Calibri">hession</span><span style="font-family:宋体">序列化方式。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
服务端采用事件驱动的<span style="font-family:Calibri">NIO</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">MINA</span><span style="font-family:宋体">框架，支撑高并发高吞吐量的请求。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002225833109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t30" style="color:rgb(106,57,6)" id="t30"></a>2) 路由<span style="font-family:Calibri">Router</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在大多数的数据库切分解决方案中，为了提高数据库的吞吐量，首先是对不同的表进行垂直切分到不同的数据库中，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
然后当数据库中一个表超过一定大小时，需要对该表进行水平切分，这里也是一样，这里以用户表为例；</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于访问数据库客户端来讲，需要根据用户的<span style="font-family:Calibri">ID</span><span style="font-family:宋体">，定位到需要访问的数据；</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据切分算法，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
根据用户的<span style="font-family:Calibri">ID</span><span style="font-family:宋体">做</span><span style="font-family:Calibri">hash</span><span style="font-family:宋体">操作，一致性</span><span style="font-family:Calibri">Hash</span><span style="font-family:宋体">，这种方式存在失效数据的迁移问题，迁移时间内服务不可用</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
维护路由表，路由表中存储用户和<span style="font-family:Calibri">sharding</span><span style="font-family:宋体">的映射关系</span><span style="font-family:Calibri">,sharding</span><span style="font-family:宋体">分为</span><span style="font-family:Calibri">leader</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">replica</span><span style="font-family:宋体">，分别负责写和读</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
这样每个<span style="font-family:Calibri">biz</span><span style="font-family:宋体">客户端都需要保持所有</span><span style="font-family:Calibri">sharding</span><span style="font-family:宋体">的连接池，这样有个缺点是会产生全连接的问题；</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
一种解决方法是<span style="font-family:Calibri">sharding</span><span style="font-family:宋体">的切分提到业务服务层进行，每个业务节点只维护一个</span><span style="font-family:Calibri">shard</span><span style="font-family:宋体">的连接即可。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
见图（<span style="font-family:Calibri">router</span><span style="font-family:宋体">）</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <img alt="" src="http://img.blog.csdn.net/20131002225856500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
   </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
路由组件的实现是这样的（可用性、高性能、高并发）</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
基于性能方面的考虑，采用<span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">中维护用户</span><span style="font-family:Calibri">id</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">shard</span><span style="font-family:宋体">的关系，为了保证可用性，搭建</span><span style="font-family:Calibri">replicatset</span><span style="font-family:宋体">集群。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
biz<span style="font-family:宋体">的</span><span style="font-family:Calibri">sharding</span><span style="font-family:宋体">和数据库的</span><span style="font-family:Calibri">sharding</span><span style="font-family:宋体">是一一对应的，只访问一个数据库</span><span style="font-family:Calibri">sharding.</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
biz<span style="font-family:宋体">业务注册节点到</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">上</span><span style="font-family:Calibri">/bizs/shard/</span><span style="font-family:宋体">下。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
router<span style="font-family:宋体">监听</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">上</span><span style="font-family:Calibri">/bizs/</span><span style="font-family:宋体">下节点状态，缓存在线</span><span style="font-family:Calibri">biz</span><span style="font-family:宋体">在</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">中。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
client<span style="font-family:宋体">请求</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">获取</span><span style="font-family:Calibri">biz</span><span style="font-family:宋体">时，</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">首先从</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">中获取用户对应的</span><span style="font-family:Calibri">shard,router</span><span style="font-family:宋体">根据缓存的内容通过</span><span style="font-family:Calibri">RR</span><span style="font-family:宋体">算法获取</span><span style="font-family:Calibri">biz</span><span style="font-family:宋体">节点。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
为了解决<span style="font-family:Calibri">router</span><span style="font-family:宋体">的可用性和并发吞吐量问题，对</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">进行冗余，同时</span><span style="font-family:Calibri">client</span><span style="font-family:宋体">监听</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">/routers</span><span style="font-family:宋体">节点并缓存在线</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">节点列表。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t31" style="color:rgb(106,57,6)" id="t31"></a>3) HA</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
传统实现<span style="font-family:Calibri">HA</span><span style="font-family:宋体">的做法一般是采用虚拟</span><span style="font-family:Calibri">IP</span><span style="font-family:宋体">漂移，结合</span><span style="font-family:Calibri">Heartbeat</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">keepalived</span><span style="font-family:宋体">等实现</span><span style="font-family:Calibri">HA</span><span style="font-family:宋体">，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Keepalived<span style="font-family:宋体">使用</span><span style="font-family:Calibri">vrrp</span><span style="font-family:宋体">方式进行数据包的转发，提供</span><span style="font-family:Calibri">4</span><span style="font-family:宋体">层的负载均衡，通过检测</span><span style="font-family:Calibri">vrrp</span><span style="font-family:宋体">数据包来切换，做冗余热备更加适合与</span><span style="font-family:Calibri">LVS</span><span style="font-family:宋体">搭配。</span><span style="font-family:Calibri">Linux Heartbeat</span><span style="font-family:宋体">是基于网络或者主机的服务的高可用，</span><span style="font-family:Calibri">HAProxy</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">Nginx</span><span style="font-family:宋体">可以基于</span><span style="font-family:Calibri">7</span><span style="font-family:宋体">层进行数据包的转发，因此</span><span style="font-family:Calibri">Heatbeat</span><span style="font-family:宋体">更加适合做</span><span style="font-family:Calibri">HAProxy</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">Nginx</span><span style="font-family:宋体">，包括业务的高可用。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在分布式的集群中，可以用<span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">做分布式的协调，实现集群的列表维护和失效通知，客户端可以选择</span><span style="font-family:Calibri">hash</span><span style="font-family:宋体">算法或者</span><span style="font-family:Calibri">roudrobin</span><span style="font-family:宋体">实现负载均衡；对于</span><span style="font-family:Calibri">master-master</span><span style="font-family:宋体">模式、</span><span style="font-family:Calibri">master-slave</span><span style="font-family:宋体">模式，可以通过</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">分布式锁的机制来支持。</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t32" style="color:rgb(106,57,6)" id="t32"></a>4) 消息<span style="font-family:Calibri">Message</span></h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于平台各个系统之间的异步交互，是通过<span style="font-family:Calibri">MQ</span><span style="font-family:宋体">组件进行的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在设计消息服务组件时，需要考虑消息一致性、持久化、可用性、以及完善的监控体系。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
业界开源的消息中间件主要<span style="font-family:Calibri">RabbitMQ</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">kafka</span><span style="font-family:宋体">有两种，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
RabbitMQ,<span style="font-family:宋体">遵循</span><span style="font-family:Calibri">AMQP</span><span style="font-family:宋体">协议，由内在高并发的</span><span style="font-family:Calibri">erlanng</span><span style="font-family:宋体">语言开发</span>；kafka<span style="font-family:宋体">是</span><span style="font-family:Calibri">Linkedin</span><span style="font-family:宋体">于</span><span style="font-family:Calibri">2010</span><span style="font-family:宋体">年</span><span style="font-family:Calibri">12</span><span style="font-family:宋体">月份开源的消息发布订阅系统</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">它主要用于处理活跃的流式数据</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">大数据量的数据处理上。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对消息一致性要求比较高的场合需要有应答确认机制，包括生产消息和消费消息的过程；不过因网络等原理导致的应答缺失，可能会导致消息的重复，这个可以在业务层次根据幂等性进行判断过滤；<span style="font-family:Calibri">RabbitMQ</span><span style="font-family:宋体">采用的是这种方式。还有一种机制是消费端从</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">拉取消息时带上</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">号，从</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">中某个</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">点批量拉取消息，这样无须应答机制，</span><span style="font-family:Calibri">kafka</span><span style="font-family:宋体">分布式消息中间件就是这种方式。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
消息的在<span style="font-family:Calibri">broker</span><span style="font-family:宋体">中的存储，根据消息的可靠性的要求以及性能方面的综合衡量，可以在内存中，可以持久化到存储上。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于可用性和高吞吐量的要求，集群和主备模式都可以在实际的场景应用的到。<span style="font-family:Calibri">RabbitMQ</span><span style="font-family:宋体">解决方案中有普通的集群和可用性更高的</span><span style="font-family:Calibri">mirror queue</span><span style="font-family:宋体">方式。 </span>kafka<span style="font-family:宋体">采用</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">对集群中的</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">consumer</span><span style="font-family:宋体">进行管理，可以注册</span><span style="font-family:Calibri">topic</span><span style="font-family:宋体">到</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">上；通过</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">的协调机制，</span><span style="font-family:Calibri">producer</span><span style="font-family:宋体">保存对应</span><span style="font-family:Calibri">topic</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">信息，可以随机或者轮询发送到</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">上；并且</span><span style="font-family:Calibri">producer</span><span style="font-family:宋体">可以基于语义指定分片，消息发送到</span><span style="font-family:Calibri">broker</span><span style="font-family:宋体">的某分片上。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
总体来讲，RabbitMQ用在实时的对可靠性要求比较高的消息传递上。<span style="font-family:Calibri">kafka</span><span style="font-family:宋体">主要用于处理活跃的流式数据</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">大数据量的数据处理上。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t33" style="color:rgb(106,57,6)" id="t33"></a>5) Cache&amp;Buffer</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>Cache<span style="font-family:宋体">系统</span></strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在一些高并发高性能的场景中，使用<span style="font-family:Calibri">cache</span><span style="font-family:宋体">可以减少对后端系统的负载，承担可大部分读的压力，可以大大提高系统的吞吐量，比如通常在数据库存储之前增加</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">缓存。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
但是引入<span style="font-family:Calibri">cache</span><span style="font-family:宋体">架构不可避免的带来一些问题，</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">命中率的问题</span><span style="font-family:Calibri">, cache</span><span style="font-family:宋体">失效引起的抖动，</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">和存储的一致性。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Cache<span style="font-family:宋体">中的数据相对于存储来讲，毕竟是有限的，比较理想的情况是存储系统的热点数据，这里可以用一些常见的算法</span><span style="font-family:Calibri">LRU</span><span style="font-family:宋体">等等淘汰老的数据；随着系统规模的增加，单个节点</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">不能满足要求，就需要搭建分布式</span><span style="font-family:Calibri">Cache</span><span style="font-family:宋体">；为了解决单个节点失效引起的抖动 ，分布式</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">一般采用一致性</span><span style="font-family:Calibri">hash</span><span style="font-family:宋体">的解决方案，大大减少因单个节点失效引起的抖动范围；而对于可用性要求比较高的场景，每个节点都是需要有备份的。数据在</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">和存储上都存有同一份备份，必然有一致性的问题，一致性比较强的，在更新数据库的同时，更新数据库</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">。对于一致性要求不高的，可以去设置缓存失效时间的策略。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Memcached<span style="font-family:宋体">作为高速的分布式缓存服务器，协议比较简单，基于</span><span style="font-family:Calibri">libevent</span><span style="font-family:宋体">的事件处理机制。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Cache<span style="font-family:宋体">系统在平台中用在</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">系统的客户端中，热点的数据会缓存在客户端，当数据访问失效时，才去访问</span><span style="font-family:Calibri">router</span><span style="font-family:宋体">系统。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
当然目前更多的利用内存型的数据库做<span style="font-family:Calibri">cache</span><span style="font-family:宋体">，比如</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">；</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">比</span><span style="font-family:Calibri">memcache</span><span style="font-family:宋体">有丰富的数据操作的</span><span style="font-family:Calibri">API</span><span style="font-family:宋体">；</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">都对数据进行了持久化，而</span><span style="font-family:Calibri">memcache</span><span style="font-family:宋体">没有这个功能，因此</span><span style="font-family:Calibri">memcache</span><span style="font-family:宋体">更加适合在关系型数据库之上的数据的缓存。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>Buffer<span style="font-family:宋体">系统</span></strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
用在高速的写操作的场景中，平台中有些数据需要写入数据库，并且数据是分库分表的，但对数据的可靠性不是那么高，为了减少对数据库的写压力，可以采取批量写操作的方式。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
开辟一个内存区域，当数据到达区域的一定阀值时如80%时，在内存中做分库梳理工作(内存速度还是比较快的)，后分库批量flush。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t34" style="color:rgb(106,57,6)" id="t34"></a>6) 搜索</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在电子商务平台中搜索是一个非常的重要功能，主要有搜索词类目导航、自动提示和搜索排序功能。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
开源的企业级搜索引擎主要有<span style="font-family:Calibri">lucene,</span> sphinx，这里不去论述哪种搜索引擎更好一些，不过选择搜索引擎除了基本的功能需要支持外，非功能方面需要考虑以下两点：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a、 搜索引擎是否支持分布式的索引和搜索，来应对海量的数据，支持读写分离，提高可用性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b、 索引的实时性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
c、 性能</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Solr<span style="font-family:宋体">是基于</span><span style="font-family:Calibri">lucene</span><span style="font-family:宋体">的高性能的全文搜索服务器，提供了比</span><span style="font-family:Calibri">lucene</span><span style="font-family:宋体">更为丰富的查询语言，可配置可扩展，对外提供基于</span><span style="font-family:Calibri">http</span><span style="font-family:宋体">协议的</span><span style="font-family:Calibri">XML/JSON</span><span style="font-family:宋体">格式的接口。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
从<span style="font-family:Calibri">Solr4</span><span style="font-family:宋体">版本开始提供了</span><span style="font-family:Calibri">SolrCloud</span><span style="font-family:宋体">方式来支持分布式的索引，自动进行</span><span style="font-family:Calibri">sharding</span><span style="font-family:宋体">数据切分；通过每个</span><span style="font-family:Calibri">sharding</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">master-slave(leader</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">replica)</span><span style="font-family:宋体">模式提高搜索的性能；利用</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">对集群进行管理，包括</span><span style="font-family:Calibri">leader</span><span style="font-family:宋体">选举等等，保障集群的可用性。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Lucene<span style="font-family:宋体">索引的</span><span style="font-family:Calibri">Reader</span><span style="font-family:宋体">是基于索引的</span><span style="font-family:Calibri">snapshot</span><span style="font-family:宋体">的，所以必须在索引</span><span style="font-family:Calibri">commit</span><span style="font-family:宋体">的后，重新打开一个新的</span><span style="font-family:Calibri">snapshot</span><span style="font-family:宋体">，才能搜索到新添加的内容；而索引的</span><span style="font-family:Calibri">commit</span><span style="font-family:宋体">是非常耗性能的，这样达到实时索引搜索效率就比较低下。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于索引搜索实时性，<span style="font-family:Calibri">Solr4</span><span style="font-family:宋体">的之前解决方案是结合文件全量索引和内存增量索引合并的方式，参见下图。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002225923937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Solr4<span style="font-family:宋体">提供了</span><span style="font-family:Calibri">NRT softcommit</span><span style="font-family:宋体">的解决方案，</span><span style="font-family:Calibri">softcommit</span><span style="font-family:宋体">无需进行提交索引操作，就可以搜素到最新对索引的变更，不过对索引的变更并没有</span><span style="font-family:Calibri">sync commit</span><span style="font-family:宋体">到硬盘存储上，若发生意外导致程序非正常结束，未</span><span style="font-family:Calibri">commit</span><span style="font-family:宋体">的数据会丢失，因此需要定时的进行</span><span style="font-family:Calibri">commit</span><span style="font-family:宋体">操作。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
平台中对数据的索引和存储操作是异步的，可以大大提高可用性和吞吐量；只对某些属性字段做索引操作，存储数据的标识<span style="font-family:Calibri">key</span><span style="font-family:宋体">，减少索引的大小；数据是存储在分布式存储</span><span style="font-family:Calibri">HBase </span><span style="font-family:宋体">中的，</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">对二级索引搜索支持的不好，然而可以结合</span><span style="font-family:Calibri">Solr</span><span style="font-family:宋体">搜索功能进行多维度的检索统计。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
索引数据和<span style="font-family:Calibri">HBase</span><span style="font-family:宋体">数据存储的一致性，也就是如何保障</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">存储的数据都被索引过，可以采用</span><span style="font-family:Calibri">confirm</span><span style="font-family:宋体">确认机制，通过在索引前建立待索引数据队列，在数据存储并索引完成后，从待索引数据队列中删除数据。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t35" style="color:rgb(106,57,6)" id="t35"></a>7) 日志收集</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<a target="_blank" name="OLE_LINK1" style="color:rgb(106,57,6)" id="OLE_LINK1"></a><a target="_blank" name="OLE_LINK2" style="color:rgb(106,57,6)" id="OLE_LINK2">在整个交易过程中，会产生大量的日志，这些日志需要收集到分布式存储系统中存储起来，以便于集中式的查询和分析处理。</a></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
日志系统需具备三个基本组件，分别为<span style="font-family:Calibri">agent</span><span style="font-family:宋体">（封装数据源，将数据源中的数据发送给</span><span style="font-family:Calibri">collector</span><span style="font-family:宋体">），</span><span style="font-family:Calibri">collector</span><span style="font-family:宋体">（接收多个</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">的数据，并进行汇总后导入后端的</span><span style="font-family:Calibri">store</span><span style="font-family:宋体">中），</span><span style="font-family:Calibri">store</span><span style="font-family:宋体">（中央存储系统，应该具有可扩展性和可靠性，应该支持当前非常流行的</span><span style="font-family:Calibri">HDFS</span><span style="font-family:宋体">）。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
开源的日志收集系统业界使用的比较多的是<span style="font-family:Calibri">cloudera</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">Flume</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">facebook</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">Scribe</span><span style="font-family:宋体">，其中</span><span style="font-family:Calibri">Flume</span><span style="font-family:宋体">目前的版本</span><span style="font-family:Calibri">FlumeNG</span><span style="font-family:宋体">对</span><span style="font-family:Calibri">Flume</span><span style="font-family:宋体">从架构上做了较大的改动。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在设计或者对日志收集系统做技术选型时，通常需要具有以下特征：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a、 应用系统和分析系统之间的桥梁，将他们之间的关系解耦</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b、 分布式可扩展，具有高的扩展性，当数据量增加时，可以通过增加节点水平扩展</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
日志收集系统是可以伸缩的，在系统的各个层次都可伸缩，对数据的处理不需要带状态，伸缩性方面也比较容易实现。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
c、 近实时性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在一些时效性要求比较高的场景中，需要可以及时的收集日志，进行数据分析；</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
一般的日志文件都会定时或者定量的进行<span style="font-family:Calibri">rolling</span><span style="font-family:宋体">，所以实时检测日志文件的生成，及时对日志文件进行类似的</span><span style="font-family:Calibri">tail</span><span style="font-family:宋体">操作，并支持批量发送提高传输效率；批量发送的时机需要满足消息数量和时间间隔的要求。 </span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
d、 容错性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Scribe<span style="font-family:宋体">在容错方面的考虑是，当后端的存储系统</span><span style="font-family:Calibri">crash</span><span style="font-family:宋体">时，</span><span style="font-family:Calibri">scribe</span><span style="font-family:宋体">会将数据写到本地磁盘上，当存储系统恢复正常后，</span><span style="font-family:Calibri">scribe</span><span style="font-family:宋体">将日志重新加载到存储系统中。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
FlumeNG<span style="font-family:宋体">通过</span><span style="font-family:Calibri">Sink Processor</span><span style="font-family:宋体">实现负载均衡和故障转移。多个</span><span style="font-family:Calibri">Sink</span><span style="font-family:宋体">可以构成一个</span><span style="font-family:Calibri">Sink Group</span><span style="font-family:宋体">。一个</span><span style="font-family:Calibri">Sink Processor</span><span style="font-family:宋体">负责从一个指定的</span><span style="font-family:Calibri">Sink Group</span><span style="font-family:宋体">中激活一个</span><span style="font-family:Calibri">Sink</span><span style="font-family:宋体">。</span><span style="font-family:Calibri">Sink Processor</span><span style="font-family:宋体">可以通过组中所有</span><span style="font-family:Calibri">Sink</span><span style="font-family:宋体">实现负载均衡；也可以在一个</span><span style="font-family:Calibri">Sink</span><span style="font-family:宋体">失败时转移到另一个。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
e、 事务支持</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Scribe<span style="font-family:宋体">没有考虑事务的支持。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Flume<span style="font-family:宋体">通过应答确认机制实现事务的支持，参见下图，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002230010062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通常提取发送消息都是批量操作的，消息的确认是对一批数据的确认，这样可以大大提高数据发送的效率。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
f、 可恢复性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
FlumeNG<span style="font-family:宋体">的</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">根据可靠性的要求的不同，可以基于内存和文件持久化机制，基于内存的数据传输的销量比较高，但是在节点宕机后，数据丢失，不可恢复；而文件持久化宕机是可以恢复的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
g、 数据的定时定量归档</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据经过日志收集系统归集后，一般存储在分布式文件系统如<span style="font-family:Calibri">Hadoop</span><span style="font-family:宋体">，为了便于对数据进行后续的处理分析，需要定时</span><span style="font-family:Calibri">(TimeTrigger)</span><span style="font-family:宋体">或者定量</span><span style="font-family:Calibri">(SizeTrigger</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">rolling</span><span style="font-family:宋体">分布式系统的文件。</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t36" style="color:rgb(106,57,6)" id="t36"></a>8) 数据同步</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在交易系统中，通常需要进行异构数据源的同步，通常有数据文件到关系型数据库，数据文件到分布式数据库，关系型数据库到分布式数据库等。数据在异构源之间的同步一般是基于性能和业务的需求，数据存储在本地文件中一般是基于性能的考虑，文件是顺序存储的，效率还是比较高的；数据同步到关系型数据一般是基于查询的需求；而分布式数据库是存储越来越多的海量数据的，而关系型数据库无法满足大数据量的存储和查询请求。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在数据同步的设计中需要综合考虑吞吐量、容错性、可靠性、一致性的问题</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
同步有实时增量数据同步和离线全量数据区分，下面从这两个维度来介绍一下，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
实时增量一般是<span style="font-family:Calibri">Tail</span><span style="font-family:宋体">文件来实时跟踪文件变化，批量或者多线程往数据库导出</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">这种方式的架构类似于日志收集框架。这种方式需要有确认机制，包括两个方面。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
一个方面是Channel<span style="font-family:宋体">需要给</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">确认已经批量收到数据记录了，发送</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">号给</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">，这样在</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">失效恢复时，可以从这个</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">点开始</span><span style="font-family:Calibri">tail</span><span style="font-family:宋体">；当然对于允许少量的重复记录的问题</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">发生在</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">给</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">确认的时，</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">宕机并未受到确认消息</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，需要在业务场景中判断。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
另外一个方面是<span style="font-family:Calibri">sync</span><span style="font-family:宋体">给</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">确认已经批量完成写入到数据库的操作，这样</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">可以删除这部分已经</span><span style="font-family:Calibri">confirm</span><span style="font-family:宋体">的消息。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
基于可靠性的要求，<span style="font-family:Calibri">channel</span><span style="font-family:宋体">可以采用文件持久化的方式。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
参见下图</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002230050093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
离线全量遵循空间间换取时间，分而治之的原则，尽量的缩短数据同步的时间，提高同步的效率。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
需要对源数据比如<span style="font-family:Calibri">mysql</span><span style="font-family:宋体">进行切分，多线程并发读源数据，多线程并发批量写入分布式数据库比如</span><span style="font-family:Calibri">HBase,</span><span style="font-family:宋体">利用</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">作为读写之间的缓冲，实现更好的解耦，</span><span style="font-family:Calibri">channel</span><span style="font-family:宋体">可以基于文件存储或者内存。参见下图：</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002230100171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于源数据的切分，如果是文件可以根据文件名称设置块大小来切分。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于关系型数据库，由于一般的需求是只离线同步一段时间的数据<span style="font-family:Calibri">(</span><span style="font-family:宋体">比如凌晨把当天的订单数据同步到</span><span style="font-family:Calibri">HBase)</span><span style="font-family:宋体">，所以需要在数据切分时</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">按照行数切分</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，会多线程扫描整个表</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">及时建索引，也要回表</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，对于表中包含大量的数据来讲，</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">很高，效率非常低；这里解决的方法是对数据库按照时间字段</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">按照时间同步的</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">建立分区，每次按照分区进行导出。</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t37" style="color:rgb(106,57,6)" id="t37"></a>9) 数据分析</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
从传统的基于关系型数据库并行处理集群、用于内存计算近实时的，到目前的基于<span style="font-family:Calibri">hadoop</span><span style="font-family:宋体">的海量数据的分析，数据的分析在大型电子商务网站中应用非常广泛，包括</span><span style="color:rgb(64,64,64)">流量统计、推荐引擎、趋势分析、用户行为分析、数据挖掘分类器、分布式索引等</span><span style="color:rgb(64,64,64)">等。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
并行处理集群有商业的<span style="font-family:Calibri">EMC Greenplum</span><span style="font-family:宋体">，</span><span style="color:rgb(0,0,0)">Greenplum<span style="font-family:宋体">的架构采用了</span><span style="font-family:Verdana">MPP(</span><span style="font-family:宋体">大规模并行处理</span><span style="font-family:Verdana">)</span></span><span style="color:rgb(0,0,0)">，</span>基于<span style="font-family:Calibri">postgresql</span><span style="font-family:宋体">的大数据量存储的分布式数据库。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
内存计算方面有<span style="font-family:Calibri">SAP</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">HANA</span><span style="font-family:宋体">，开源的</span><span style="font-family:Calibri">nosql</span><span style="font-family:宋体">内存型的数据库</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">也支持</span><span style="font-family:Calibri">mapreduce</span><span style="font-family:宋体">进行数据的分析。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
海量数据的离线分析目前互联网公司大量的使用<span style="font-family:Calibri">Hadoop</span><span style="font-family:宋体">，</span>Hadoop<span style="font-family:宋体">在可伸缩性、健壮性、计算性能和成本上具有无可替代的优势，事实上已成为当前互联网企业主流的大数据分析平台</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Hadoop<span style="font-family:宋体">通过</span><span style="font-family:Calibri">MapReuce</span><span style="font-family:宋体">的分布式处理框架，用于处理大规模的数据，伸缩性也非常好；但是</span><span style="font-family:Calibri">MapReduce</span><span style="font-family:宋体">最大的不足是不能满足实时性的场景，主要用于离线的分析。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
基于<span style="font-family:Calibri">MapRduce</span><span style="font-family:宋体">模型编程做数据的分析，开发上效率不高，位于</span><span style="font-family:Calibri">hadoop</span><span style="font-family:宋体">之上</span><span style="font-family:Calibri">Hive</span><span style="font-family:宋体">的出现使得数据的分析可以类似编写</span><span style="font-family:Calibri">sql</span><span style="font-family:宋体">的方式进行，</span><span style="font-family:Calibri">sql</span><span style="font-family:宋体">经过语法分析、生成执行计划后最终生成</span><span style="font-family:Calibri">MapReduce</span><span style="font-family:宋体">任务进行执行，这样大大提高了开发的效率，做到以</span><span style="font-family:Calibri">ad-hoc(</span><span style="font-family:宋体">计算在</span><span style="font-family:Calibri">query</span><span style="font-family:宋体">发生时</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">方式进行的分析。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
基于<span style="font-family:Calibri">MapReduce</span><span style="font-family:宋体">模型的分布式数据的分析都是离线的分析，执行上都是暴力扫描，无法利用类似索引的机制；开源的</span><span style="font-family:Calibri">Cloudera Impala</span><span style="font-family:宋体">是基于</span><span style="font-family:Calibri">MPP</span><span style="font-family:宋体">的并行编程模型的，底层是</span><span style="font-family:Calibri">Hadoop</span><span style="font-family:宋体">存储的高性能的实时分析平台，可以大大降低数据分析的延迟。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
目前<span style="font-family:Calibri">Hadoop</span><span style="font-family:宋体">使用的版本是</span><span style="font-family:Calibri">Hadoop1.0</span><span style="font-family:宋体">，一方面原有的</span><span style="font-family:Calibri">MapReduce</span><span style="font-family:宋体">框架存在</span><span style="font-family:Calibri">JobTracker</span><span style="font-family:宋体">单点的问题，另外一方面</span><span style="font-family:Calibri">JobTracker</span><span style="font-family:宋体">在做资源管理的同时又做任务的调度工作，随着数据量的增大和</span><span style="font-family:Calibri">Job</span><span style="font-family:宋体">任务的增多，明显存在</span>可扩展性、内存消耗、线程模型、可靠性和性能上的缺陷瓶颈；<span style="font-family:Calibri">Hadoop2.0 yarn</span><span style="font-family:宋体">对整个框架进行了重构，分离了资源管理和任务调度，从架构设计上解决了这个问题。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
参考Yarn<span style="font-family:宋体">的架构</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t38" style="color:rgb(106,57,6)" id="t38"></a>10) 实时计算</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在互联网领域，实时计算被广泛实时监控分析、流控、风险控制等领域。电商平台系统或者应用对日常产生的大量日志和异常信息，需要经过实时过滤、分析，以判定是否需要预警；</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
同时需要对系统做自我保护机制，比如对模块做流量的控制，以防止非预期的对系统压力过大而引起的系统瘫痪，流量过大时，可以采取拒绝或者引流等机制；有些业务需要进行风险的控制，比如彩票中有些业务需要根据系统的实时销售情况进行限号与放号。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
原始基于单节点的计算，随着系统信息量爆炸式产生以及计算的复杂度的增加，单个节点的计算已不能满足实时计算的要求，需要进行多节点的分布式的计算，分布式实时计算平台就出现了。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
这里所说的实时计算，其实是流式计算，概念前身其实是<span style="font-family:Calibri">CEP</span><span style="font-family:宋体">复杂事件处理，相关的开源产品如</span><span style="font-family:Calibri">Esper</span><span style="font-family:宋体">，业界分布式的流计算产品</span>Yahoo S4,Twitter storm<span style="font-family:宋体">等，以</span><span style="font-family:Calibri">storm</span><span style="font-family:宋体">开源产品使用最为广泛。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于实时计算平台，从架构设计上需要考虑以下几个因素：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
1、 伸缩性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
随着业务量的增加，计算量的增加，通过增加节点处理，就可以处理。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
2、 高性能、低延迟</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
从数据流入计算平台数据，到计算输出结果，需要性能高效且低延迟，保证消息得到快速的处理，做到实时计算。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
3、 可靠性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
保证每个数据消息得到一次完整处理。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
4、 容错性</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统可以自动管理节点的宕机失效，对应用来说，是透明的。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Twitter<span style="font-family:宋体">的</span><span style="font-family:Calibri">Storm</span><span style="font-family:宋体">在以上这几个方面做的比较好，下面简介一下</span><span style="font-family:Calibri">Storm</span><span style="font-family:宋体">的架构。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img alt="" src="http://img.blog.csdn.net/20131002230153703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
整个集群的管理是通过<span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">来进行的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
客户端提交拓扑到nimbus<span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Nimbus<span style="font-family:宋体">针对该拓扑建立本地的目录根据</span>topology<span style="font-family:宋体">的配置计算</span>task<span style="font-family:宋体">，分配</span>task<span style="font-family:宋体">，在</span>zookeeper<span style="font-family:宋体">上建立</span>assignments<span style="font-family:宋体">节点存储</span>task<span style="font-family:宋体">和</span>supervisor<span style="font-family:宋体">机器节点中</span>woker<span style="font-family:宋体">的对应关系</span>。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在zookeeper<span style="font-family:宋体">上创建</span>taskbeats<span style="font-family:宋体">节点来监控</span>task<span style="font-family:宋体">的心跳；启动</span>topology<span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Supervisor<span style="font-family:宋体">去</span>zookeeper<span style="font-family:宋体">上获取分配的</span>tasks<span style="font-family:宋体">，启动多个</span>woker<span style="font-family:宋体">进行，每个</span>woker<span style="font-family:宋体">生成</span>task<span style="font-family:宋体">，一个</span>task<span style="font-family:宋体">一个线程；根据</span>topology<span style="font-family:宋体">信息初始化建立</span>task<span style="font-family:宋体">之间的连接</span>;Task<span style="font-family:宋体">和</span>Task<span style="font-family:宋体">之间是通过</span>zeroMQ<span style="font-family:宋体">管理的；</span>之后整个拓扑运行起来。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Tuple<span style="font-family:宋体">是流的基本处理单元，也就是一个消息，</span>Tuple<span style="font-family:宋体">在</span>task<span style="font-family:宋体">中流转，</span>Tuple<span style="font-family:宋体">的发送和接收过程如下：</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
发送Tuple，Worker<span style="font-family:宋体">提供了一个</span>transfer<span style="font-family:宋体">的功能，用于当前</span>task<span style="font-family:宋体">把</span>tuple<span style="font-family:宋体">发到到其他的</span>task<span style="font-family:宋体">中。以目的</span>taskid<span style="font-family:宋体">和</span>tuple<span style="font-family:宋体">参数，序列化</span>tuple<span style="font-family:宋体">数据并放到</span>transfer queue<span style="font-family:宋体">中。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在0.8<span style="font-family:宋体">版本之前，这个</span>queue<span style="font-family:宋体">是</span>LinkedBlockingQueue<span style="font-family:宋体">，</span>0.8<span style="font-family:宋体">之后是</span>DisruptorQueue<span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在0.8<span style="font-family:宋体">版本之后，每一个</span>woker<span style="font-family:宋体">绑定一个</span>inbound transfer queue<span style="font-family:宋体">和</span>outbond queue<span style="font-family:宋体">，</span>inbound queue<span style="font-family:宋体">用于接收</span>message<span style="font-family:宋体">，</span>outbond queue<span style="font-family:宋体">用于发送消息。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
发送消息时，由单个线程从transferqueue<span style="font-family:宋体">中拉取数据，把这个</span>tuple<span style="font-family:宋体">通过</span>zeroMQ<span style="font-family:宋体">发送到其他的</span>woker<span style="font-family:宋体">中。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
接收Tuple，每个woker<span style="font-family:宋体">都会监听</span>zeroMQ<span style="font-family:宋体">的</span>tcp<span style="font-family:宋体">端口来接收消息，消息放到</span>DisruptorQueue<span style="font-family:宋体">中后，后从</span>queue<span style="font-family:宋体">中获取</span>message(taskid,tuple)<span style="font-family:宋体">，根据目的</span>taskid,tuple<span style="font-family:宋体">的值路由到</span>task<span style="font-family:宋体">中执行。每个</span>tuple<span style="font-family:宋体">可以</span>emit<span style="font-family:宋体">到</span>direct steam<span style="font-family:宋体">中，也可以发送到</span>regular stream<span style="font-family:宋体">中，在</span>Reglular<span style="font-family:宋体">方式下，由</span>Stream Group<span style="font-family:宋体">（</span>stream id--&gt;component id --&gt;outbond tasks<span style="font-family:宋体">）功能完成当前</span>tuple<span style="font-family:宋体">将要发送的</span>Tuple<span style="font-family:宋体">的目的地。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通过以上分析可以看到，<span style="font-family:Calibri">Storm</span><span style="font-family:宋体">在伸缩性、容错性、高性能方面的从架构设计的角度得以支撑；同时在可靠性方面，</span><span style="font-family:Calibri">Storm</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">ack</span><span style="font-family:宋体">组件利用异或</span><span style="font-family:Calibri">xor</span><span style="font-family:宋体">算法在不失性能的同时，保证每一个消息得到完整处理的同时。 </span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t39" style="color:rgb(106,57,6)" id="t39"></a>11) 实时推送</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
实时推送的应用场景非常多，比如系统的监控动态的实时曲线绘制，手机消息的推送，<span style="font-family:Calibri">web</span><span style="font-family:宋体">实时聊天等。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
实时推送有很多技术可以实现，有<span style="font-family:Calibri">Comet</span><span style="font-family:宋体">方式，有</span><span style="font-family:Calibri">websocket</span><span style="font-family:宋体">方式等。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Comet<span style="font-family:宋体">基于服务器长连接的“服务器推”技术，包含两种：</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Long Polling<span style="font-family:宋体">：服务器端在接到请求后挂起，有更新时返回连接即断掉，然后客户端再发起新的连接</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Stream<span style="font-family:宋体">方式</span><span style="font-family:Calibri">: </span><span style="font-family:宋体">每次服务端数据传送不会关闭连接，连接只会在通信出现错误时，或是连接重建时关闭（一些防火墙常被设置为丢弃过长的连接， 服务器端可以设置一个超时时间， 超时后通知客户端重新建立连接，并关闭原来的连接）。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Websocket<span style="font-family:宋体">：长连接，全双工通信</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
是 <span style="font-family:Calibri">Html5 </span><span style="font-family:宋体">的一种新的协议。它实现了浏览器与服务器的双向通讯。</span><span style="font-family:Calibri">webSocket API </span><span style="font-family:宋体">中，浏览器和服务器端只需要通过一个握手的动作，便能形成浏览器与客户端之间的快速双向通道，使得数据可以快速的双向传播。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Socket.io<span style="font-family:宋体">是一个</span><span style="font-family:Calibri">NodeJS websocket</span><span style="font-family:宋体">库，包括客户端的</span><span style="font-family:Calibri">JS</span><span style="font-family:宋体">和服务端的的</span><span style="font-family:Calibri">nodejs</span><span style="font-family:宋体">，用于快速构建实时的</span><span style="font-family:Calibri">web</span><span style="font-family:宋体">应用。</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t40" style="color:rgb(106,57,6)" id="t40"></a>12) 推荐引擎</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 待补充</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t41" style="color:rgb(106,57,6)" id="t41"></a>6. 数据存储</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据库存储大体分为以下几类，有关系型（事务型）的数据库，以<span style="font-family:Calibri">oracle</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">为代表，有</span><span style="font-family:Calibri">keyvalue</span><span style="font-family:宋体">数据库，以</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">memcached db</span><span style="font-family:宋体">为代表，有文档型数据库如</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">，有列式</span>分布式数据库以<span style="font-family:Calibri">HBase</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">cassandra,dynamo</span><span style="font-family:宋体">为代表，还</span>有其他的图形数据库、对象数据 库、<span style="font-family:Calibri">xml</span><span style="font-family:宋体">数据库等。</span>每种类型的数据库应用的业务领域是不一样的，下面从内存型、关系型、分布式三个维度针对相关的产品做性能可用性等方面的考量分析。</p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t42" style="color:rgb(106,57,6)" id="t42"></a>1) 内存型数据库</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
内存型的数据库，以高并发高性能为目标，在事务性方面没那么严格，以开源<span style="font-family:Calibri">nosql</span><span style="font-family:宋体">数据库</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">为例</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø Mongodb</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>通信方式</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
多线程方式，主线程监听新的连接，连接后，启动新的线程做数据的操作（<span style="font-family:Calibri">IO</span><span style="font-family:宋体">切换）。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>数据结构</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img width="582" height="518" alt="" src="http://img.blog.csdn.net/20131002230236484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%; width:568px; height:345px" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<a target="_blank" href="http://pic.yupoo.com/iammutex/BT0Z9Asq/O6EzR.png" style="color:rgb(106,57,6); text-decoration:none"></a></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据库<span style="font-family:Calibri">--&gt;collection--&gt;record</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
MongoDB<span style="font-family:宋体">在数据存储上按命名空间来划分，一个</span><span style="font-family:Calibri">collection</span><span style="font-family:宋体">是一个命名空间，一个索引也是一个命名空间。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
同一个命名空间的数据被分成很多个<span style="font-family:Calibri">Extent</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">Extent</span><span style="font-family:宋体">之间使用双向链表连接。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在每一个<span style="font-family:Calibri">Extent</span><span style="font-family:宋体">中，保存了具体每一行的数据，这些数据也是通过双向链接连接的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
每一行数据存储空间不仅包括数据占用空间，还可能包含一部分附加空间，这使得在数据<span style="font-family:Calibri">update</span><span style="font-family:宋体">变大后可以不移动位置。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
索引以<span style="font-family:Calibri">BTree</span><span style="font-family:宋体">结构实现。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
如果你开启了<span style="font-family:Calibri">jorunaling</span><span style="font-family:宋体">日志，那么还会有一些文件存储着你所有的操作记录</span>。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>持久化存储</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
MMap<span style="font-family:宋体">方式把文件地址映射到内存的地址空间，直接操作内存地址空间就可以操作文件，不用再调用</span><span style="font-family:Calibri">write,read</span><span style="font-family:宋体">操作，性能比较高。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
mongodb<span style="font-family:宋体">调用</span><span style="font-family:Calibri">mmap</span><span style="font-family:宋体">把磁盘中的数据映射到内存中的，所以必须有一个机制时刻的刷数据到硬盘才能保证可靠性，多久刷一次是与</span><span style="font-family:Calibri">syncdelay</span><span style="font-family:宋体">参数相关的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 journal<span style="font-family:宋体">（进行恢复用）是</span><span style="font-family:Calibri">Mongodb</span><span style="font-family:宋体">中的</span><span style="font-family:Calibri">redo log</span><span style="font-family:宋体">，而</span><span style="font-family:Calibri">Oplog</span><span style="font-family:宋体">则是负责复制的</span><span style="font-family:Calibri">binlog</span><span style="font-family:宋体">。如果打开</span><span style="font-family:Calibri">journal</span><span style="font-family:宋体">，那么即使断电也只会丢失</span><span style="font-family:Calibri">100ms</span><span style="font-family:宋体">的数据，这对大多数应用来说都可以容忍了。从</span><span style="font-family:Calibri">1.9.2+</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">都会默认打开</span><span style="font-family:Calibri">journal</span><span style="font-family:宋体">功能，以确保数据安全。而且</span><span style="font-family:Calibri">journal</span><span style="font-family:宋体">的刷新时间是可以改变的，</span><span style="font-family:Calibri">2-300ms</span><span style="font-family:宋体">的范围</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">使用 </span><span style="font-family:Calibri">--journalCommitInterval </span><span style="font-family:宋体">命令。</span><span style="font-family:Calibri">Oplog</span><span style="font-family:宋体">和数据刷新到磁盘的时间是</span><span style="font-family:Calibri">60s</span><span style="font-family:宋体">，对于复制来说，不用等到</span><span style="font-family:Calibri">oplog</span><span style="font-family:宋体">刷新磁盘，在内存中就可以直接复制到</span><span style="font-family:Calibri">Sencondary</span><span style="font-family:宋体">节点。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>事务支持</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Mongodb<span style="font-family:宋体">只支持对单行记录的原子操作</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>HA<span style="font-family:宋体">集群</span></strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
用的比较多的是<span style="font-family:Calibri">Replica Sets</span><span style="font-family:宋体">，采用选举算法，自动进行</span><span style="font-family:Calibri">leader</span><span style="font-family:宋体">选举，在保证可用性的同时，可以做到强一致性要求。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img width="548" height="367" alt="" src="http://img.blog.csdn.net/20131002230434296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%; width:504px; height:237px" /><a target="_blank" href="http://pic.yupoo.com/iammutex/BT0Za34Q/8SKjb.png" style="color:rgb(106,57,6); text-decoration:none"></a></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
当然对于大量的数据，<span style="font-family:Calibri">mongodb</span><span style="font-family:宋体">也提供了数据的切分架构</span><span style="font-family:Calibri">Sharding</span><span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø Redis</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
丰富的数据结构，高速的响应速度，内存操作</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>通信方式</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
因都在内存操作，所以逻辑的操作非常快，减少了<span style="font-family:Calibri">CPU</span><span style="font-family:宋体">的切换开销，所以为单线程的模式（逻辑处理线程和主线程是一个）。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 reactor<span style="font-family:宋体">模式，实现自己的多路复用</span><span style="font-family:Calibri">NIO</span><span style="font-family:宋体">机制（</span><span style="font-family:Calibri">epoll</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">select</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">kqueue</span><span style="font-family:宋体">等）</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <span style="font-family:宋体">单线程处理多任务</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>数据结构</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
  hash+bucket<span style="font-family:宋体">结构，当链表的长度过长时，会采取迁移的措施（扩展原来两倍的</span><span style="font-family:Calibri">hash</span><span style="font-family:宋体">表，把数据迁移过去，</span><span style="font-family:Calibri">expand+rehash</span><span style="font-family:宋体">）</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>持久化存储</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a<span style="font-family:宋体">、全量持久化</span><span style="font-family:Calibri">RDB</span><span style="font-family:宋体">（遍历</span><span style="font-family:Calibri">redisDB,</span><span style="font-family:宋体">读取</span><span style="font-family:Calibri">bucket</span><span style="font-family:宋体">中的</span><span style="font-family:Calibri">key,value</span><span style="font-family:宋体">），</span><span style="font-family:Calibri">save</span><span style="font-family:宋体">命令阻塞主线程，</span><span style="font-family:Calibri">bgsave</span><span style="font-family:宋体">开启子进程进行</span><span style="font-family:Calibri">snapshot</span><span style="font-family:宋体">持久化操作，生成</span><span style="font-family:Calibri">rdb</span><span style="font-family:宋体">文件。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <span style="font-family:宋体">在</span><span style="font-family:Calibri">shutdown</span><span style="font-family:宋体">时，会调用</span><span style="font-family:Calibri">save</span><span style="font-family:宋体">操作</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <span style="font-family:宋体">数据发生变化，在多少秒内触发一次</span><span style="font-family:Calibri">bgsave</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
sync<span style="font-family:宋体">，</span><span style="font-family:Calibri">master</span><span style="font-family:宋体">接受</span><span style="font-family:Calibri">slave</span><span style="font-family:宋体">发出来的命令</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b<span style="font-family:宋体">、增量持久化（</span><span style="font-family:Calibri">aof</span><span style="font-family:宋体">类似</span><span style="font-family:Calibri">redolog</span><span style="font-family:宋体">），先写到日志</span><span style="font-family:Calibri">buffer,</span><span style="font-family:宋体">再</span><span style="font-family:Calibri">flush</span><span style="font-family:宋体">到日志文件中（</span><span style="font-family:Calibri">flush</span><span style="font-family:宋体">的策略可以配置的，而已单条，也可以批量），只有</span><span style="font-family:Calibri">flush</span><span style="font-family:宋体">到文件上的，才真正返回客户端。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
要定时对<span style="font-family:Calibri">aof</span><span style="font-family:宋体">文件和</span><span style="font-family:Calibri">rdb</span><span style="font-family:宋体">文件做合并操作（在快照过程中，变化的数据先写到</span><span style="font-family:Calibri">aof buf</span><span style="font-family:宋体">中等子进程完成快照</span><span style="font-family:Calibri">&lt;</span><span style="font-family:宋体">内存</span><span style="font-family:Calibri">snapshot&gt;</span><span style="font-family:宋体">后，再进行合并</span><span style="font-family:Calibri">aofbuf</span><span style="font-family:宋体">变化的部分以及全镜像数据）。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在高并发访问模式下，<span style="font-family:Calibri">RDB</span><span style="font-family:宋体">模式使服务的性能指标出现明显的抖动，</span><span style="font-family:Calibri">aof</span><span style="font-family:宋体">在性能开销上比</span><span style="font-family:Calibri">RDB</span><span style="font-family:宋体">好，但是恢复时重新加载到内存的时间和数据量成正比。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>集群<span style="font-family:Calibri">HA</span></strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通用的解决方案是主从备份切换，采用<span style="font-family:Calibri">HA</span><span style="font-family:宋体">软件，使得失效的主</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">可以快速的切换到从</span><span style="font-family:Calibri">redis</span><span style="font-family:宋体">上。主从数据的同步采用复制机制，该场景可以做读写分离。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
目前在复制方面，存在的一个问题是在遇到网络不稳定的情况下，<span style="font-family:Calibri">Slave</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">断开（包括闪断）会导致</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">需要将内存中的数据全部重新生成</span><span style="font-family:Calibri">rdb</span><span style="font-family:宋体">文件（快照文件），然后传输给</span><span style="font-family:Calibri">Slave</span><span style="font-family:宋体">。</span><span style="font-family:Calibri">Slave</span><span style="font-family:宋体">接收完</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">传递过来的</span><span style="font-family:Calibri">rdb</span><span style="font-family:宋体">文件以后会将自身的内存清空，把</span><span style="font-family:Calibri">rdb</span><span style="font-family:宋体">文件重新加载到内存中。这种方式效率比较低下，在后面的未来版本</span><span style="font-family:Calibri">Redis2.8</span><span style="font-family:宋体">作者已经实现了部分复制的功能。</span></p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t43" style="color:rgb(106,57,6)" id="t43"></a>2) 关系型数据库</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
关系型数据库在满足并发性能的同时，也需要满足事务性，以<span style="font-family:Calibri">mysql</span><span style="font-family:宋体">数据库为例，讲述架构设计原理，在性能方面的考虑，以及如何满足可用性的需求。</span> </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø mysql<span style="font-family:宋体">的架构原理</span><span style="font-family:Calibri">(innodb)</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在架构上，<span style="font-family:Calibri">mysql</span><span style="font-family:宋体">分为</span><span style="font-family:Calibri">server</span><span style="font-family:宋体">层和存储引擎层。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Server<span style="font-family:宋体">层的架构对于不同的存储引擎来讲都是一样的</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">包括连接</span><span style="font-family:Calibri">/</span><span style="font-family:宋体">线程处理、查询处理</span><span style="font-family:Calibri">(parser</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">optimizer)</span><span style="font-family:宋体">以及其他系统任务。存储引擎层有很多种，</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">提供了存储引擎的插件式结构，支持多种存储引擎，用的最广泛的是</span><span style="font-family:Calibri">innodb</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">myisamin</span><span style="font-family:宋体">；</span><span style="font-family:Calibri">inodb</span><span style="font-family:宋体">主要面向</span><span style="font-family:Calibri">OLTP</span><span style="font-family:宋体">方面的应用，支持事务处理，</span><span style="font-family:Calibri">myisam</span><span style="font-family:宋体">不支持事务，表锁，对</span><span style="font-family:Calibri">OLAP</span><span style="font-family:宋体">操作速度快。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
以下主要针对<span style="font-family:Calibri">innodb</span><span style="font-family:宋体">存储引擎做相关介绍。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <img width="582" height="458" alt="" src="http://img.blog.csdn.net/20131002230523203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%; width:551px; height:333px" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在线程处理方面，<span style="font-family:Calibri">Mysql</span><span style="font-family:宋体">是多线程的架构，由一个</span><span style="font-family:Calibri">master</span><span style="font-family:宋体">线程，一个锁监控线程，一个错误监控线程，和多个</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">线程组成。并且对一个连接会开启一个线程进行服务。</span><span style="font-family:Calibri">io</span><span style="font-family:宋体">线程又分为节省随机</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">insert buffer</span><span style="font-family:宋体">，用于事务控制的类似于</span><span style="font-family:Calibri">oracle</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">redo log</span><span style="font-family:宋体">，以及多个</span><span style="font-family:Calibri">write</span><span style="font-family:宋体">，多个</span><span style="font-family:Calibri">read</span><span style="font-family:宋体">的硬盘和内存交换的</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">线程。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在内存分配方面，包括<span style="font-family:Calibri">innodb buffer pool </span><span style="font-family:宋体">，以及</span><span style="font-family:Calibri">log buffer</span><span style="font-family:宋体">。其中</span><span style="font-family:Calibri">innodb buffer pool</span><span style="font-family:宋体">包括</span><span style="font-family:Calibri">insert buffer</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">datapage</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">index page</span><span style="font-family:宋体">、数据字典、自适应</span><span style="font-family:Calibri">hash</span><span style="font-family:宋体">。</span><span style="font-family:Calibri">L</span>og buffer<span style="font-family:宋体">用于缓存事务日志，提供性能。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在数据结构方面，<span style="font-family:Calibri">innodb</span><span style="font-family:宋体">包括表空间、段、区、页</span><span style="font-family:Calibri">/</span><span style="font-family:宋体">块，行。索引结构是</span><span style="font-family:Calibri">B</span>+tree<span style="font-family:宋体">结构，包括二级索引和主键索引，二级索引的叶子节点是主键</span><span style="font-family:Calibri">PK</span><span style="font-family:宋体">，根据主键索引的叶子节点指向存储的数据块。</span>这种<span style="font-family:Calibri">B+</span><span style="font-family:宋体">树存储结构可以更好的满足随机查询操作</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">要求，分为数据页和二级索引页，修改二级索引页面涉及到随机操作，为了提高写入时的性能，采用</span><span style="font-family:Calibri">insert buffer</span><span style="font-family:宋体">做顺序的写入，再由后台线程以一定频率将多个插入合并到二级索引页面。为了保证数据库的一致性</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">内存和硬盘数据文件</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，以及缩短实例恢复的时间，关系型数据库还有一个</span><span style="font-family:Calibri">checkpoint</span><span style="font-family:宋体">的功能，用于把内存</span><span style="font-family:Calibri">buffer</span><span style="font-family:宋体">中之前的脏页按照比例</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">老的</span><span style="font-family:Calibri">LSN)</span><span style="font-family:宋体">写入磁盘，这样</span><span style="font-family:Calibri">redolog</span><span style="font-family:宋体">文件的</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">以前的日志就可以被覆盖了，进行循环使用；在失效恢复时，只需要从日志中</span><span style="font-family:Calibri">LSN</span><span style="font-family:宋体">点进行恢复即可。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在事务特性支持上，关系型数据库需要满足<span style="font-family:Calibri">ACID</span><span style="font-family:宋体">四个特性，需要根据不同的事务并发和数据可见性要求，定义了不同的事务隔离级别，并且离不开对资源争用的锁机制，要避免产生死锁，</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">在</span><span style="font-family:Calibri">Server</span><span style="font-family:宋体">层和存储引擎层做并发控制，主要体现在读写锁，根据锁粒度不同，有各个级别的锁</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">表锁、行锁、页锁、</span><span style="font-family:Calibri">MVCC)</span><span style="font-family:宋体">；基于提高并发性能的考虑，使用多版本并发控制</span><span style="font-family:Calibri">MVCC</span><span style="font-family:宋体">来支持事务的隔离，并基于</span><span style="font-family:Calibri">undo</span><span style="font-family:宋体">来实现，在做事务回滚时，也会用到</span><span style="font-family:Calibri">undo</span><span style="font-family:宋体">段。</span><span style="font-family:Calibri">mysql </span><span style="font-family:宋体">用</span><span style="font-family:Calibri">redolog</span><span style="font-family:宋体">来保证数据的写入的性能和失效恢复，在修改数据时只需要修改内存，再把修改行为记录到事务日志中</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">顺序</span><span style="font-family:Calibri">IO)</span><span style="font-family:宋体">，不用每次将数据修改本身持久化到硬盘</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">随机</span><span style="font-family:Calibri">IO)</span><span style="font-family:宋体">，大大提高性能。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在可靠性方面，<span style="font-family:Calibri">innodb</span><span style="font-family:宋体">存储引擎提供了两次写机制</span><span style="font-family:Calibri">double writer</span><span style="font-family:宋体">用于防止在</span><span style="font-family:Calibri">flush</span><span style="font-family:宋体">页面到存储上出现的错误，解决磁盘</span><span style="font-family:Calibri">half-writern</span><span style="font-family:宋体">的问题。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø 对于高并发高性能的<span style="font-family:Calibri">mysql</span><span style="font-family:宋体">来讲，可以在多个维度进行性能方面的调优。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a<span style="font-family:宋体">、硬件级别，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
日志和数据的存储，需要分开，日志是顺序的写，需要做<span style="font-family:Calibri">raid1+0</span><span style="font-family:宋体">，并且用</span><span style="font-family:Calibri">buffer-IO</span><span style="font-family:宋体">；数据是离散的读写，走</span><span style="font-family:Calibri">direct IO</span><span style="font-family:宋体">即可，避免走文件系统</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">带来的开销。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
存储能力，<span style="font-family:Calibri">SAS</span><span style="font-family:宋体">盘</span><span style="font-family:Calibri">raid</span><span style="font-family:宋体">操作（</span><span style="font-family:Calibri">raid</span><span style="font-family:宋体">卡缓存，关闭读</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">，关闭磁盘</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">，关闭预读，只用</span><span style="font-family:Calibri">writeback buffer</span><span style="font-family:宋体">，不过需要考虑充放电的问题），当然如果数据规模不大，数据的存储可以用高速的设备，</span><span style="font-family:Calibri">Fusion IO</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">SSD</span><span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于数据的写入，控制脏页刷新的频率，对于数据的读取，控制<span style="font-family:Calibri">cache hit</span><span style="font-family:宋体">率；因此而估算系统需要的</span><span style="font-family:Calibri">IOPS</span><span style="font-family:宋体">，评估需要的硬盘数</span>量(fusion io<span style="font-family:宋体">上到</span><span style="font-family:Calibri">IOPS </span><span style="font-family:宋体">在</span>10w<span style="font-family:宋体">以上，普通的硬盘</span><span style="font-family:Calibri">150)</span><span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Cpu<span style="font-family:宋体">方面，单实例关闭</span><span style="font-family:Calibri">NUMA</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">对多核的支持不是太好，可以对多实例进行</span><span style="font-family:Calibri">CPU</span><span style="font-family:宋体">绑定。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b、操作系统级别，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
内核以及<span style="font-family:Calibri">socket</span><span style="font-family:宋体">的优化，网络优化</span><span style="font-family:Calibri">bond</span>、文件系统、<span style="font-family:Calibri">IO</span><span style="font-family:宋体">调度</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
innodb<span style="font-family:宋体">主要用在</span><span style="font-family:Calibri">OLTP</span><span style="font-family:宋体">类应用，一般都是</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">密集型的应用，在提高</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">能力的基础上，充分利用</span><span style="font-family:Calibri">cache</span><span style="font-family:宋体">机制。需要考虑的内容有，</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在保证系统可用内存的基础上，尽可能的扩大<span style="font-family:Calibri">innodb buffer pool</span><span style="font-family:宋体">，一般设置为物理内存的</span><span style="font-family:Calibri">3/4</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
文件系统的使用，只在记录事务日志的时候用文件系统的<span style="font-family:Calibri">cache</span><span style="font-family:宋体">；尽量避免</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">用到</span><span style="font-family:Calibri">swap</span>(可以将<span style="font-family:Calibri">vm.swappiness=0</span><span style="font-family:宋体">，内存紧张时，释放文件系统</span><span style="font-family:Calibri">cache</span>)</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
IO<span style="font-family:宋体">调度优化，</span>减少不必要的阻塞，降低随机<span style="font-family:Calibri">IO</span><span style="font-family:宋体">访问的延时</span><span style="font-family:Calibri">(CFQ</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">Deadline</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">NOOP)</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
c、<span style="font-family:Calibri">server</span>以及存储引擎级别（连接管理、网络管理、<span style="font-family:Calibri">table</span><span style="font-family:宋体">管理、日志）</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
包括<span style="font-family:Calibri">cache/buffer</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">Connection</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">IO</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
d、应用级别（比如索引的考虑，<span style="font-family:Calibri">schema</span><span style="font-family:宋体">的优化适当冗余；优化</span><span style="font-family:Calibri">sql</span><span style="font-family:宋体">查询导致的</span><span style="font-family:Calibri">CPU</span><span style="font-family:宋体">问题和内存问题</span>，减少锁的范围，减少回表扫描，覆盖索引）</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø 在高可用实践方面，</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
支持<span style="font-family:Calibri">master-master</span><span style="font-family:宋体">、</span><span style="font-family:Calibri">master-slave</span><span style="font-family:宋体">模式，</span><span style="font-family:Calibri">master-master</span><span style="font-family:宋体">模式是一个作为主负责读写，另外一个作为</span><span style="font-family:Calibri">standby</span><span style="font-family:宋体">提供灾备，</span><span style="font-family:Calibri">maser-slave</span><span style="font-family:宋体">是一个作为主提供写操作，其他几个节点作为读操作，支持读写分离。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于节点主备失效检测和切换，可以采用<span style="font-family:Calibri">HA</span><span style="font-family:宋体">软件，当然也可以从更细粒度定制的角度，采用</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">作为集群的协调服务。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于分布式的系统来讲，数据库主备切换的一致性始终是一个问题，可以有以下几种方式：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
a<span style="font-family:宋体">、集群方式，如</span><span style="font-family:Calibri">oracle</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">rack</span><span style="font-family:宋体">，缺点是比较复杂</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
b<span style="font-family:宋体">、共享</span><span style="font-family:Calibri">SAN</span><span style="font-family:宋体">存储方式，相关的数据文件和日志文件都放在共享存储上，优点是主备切换时数据保持一致，不会丢失，但由于备机有一段时间的拉起，会有短暂的不可用状态</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
c<span style="font-family:宋体">、主备进行数据同步的方式，常见的是日志的同步，可以保障热备，实时性好，但是切换时，可能有部分数据没有同步过来，带来了数据的一致性问题。可以在操作主数据库的同时，记录操作日志，切换到备时，会和操作日志做个</span><span style="font-family:Calibri">check</span><span style="font-family:宋体">，补齐未同步过来的数据；</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
d<span style="font-family:宋体">、</span>还有一种做法是备库切换到主库的<span style="font-family:Calibri">regolog</span><span style="font-family:宋体">的存储上，保证数据</span>不丢失。</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据库主从复制的效率在<span style="font-family:Calibri">mysql</span><span style="font-family:宋体">上不是太高，主要原因是事务是严格保持顺序的，索引</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">在复制方面包括日志</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">relog log</span><span style="font-family:宋体">两个过程都是单线程的串行操作，在数据复制优化方面，尽量减少</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">的影响。不过到了</span>Mysql5.6<span style="font-family:宋体">版本，可以支持在不同的库上的并行复制。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø 基于不同业务要求的存取方式</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
平台业务中，不同的业务有不同的存取要求，比如典型的两大业务用户和订单，用户一般来讲总量是可控的，而订单是不断地递增的，对于用户表首先采取分库切分，每个<span style="font-family:Calibri">sharding</span><span style="font-family:宋体">做一主多读，同样对于订单因更多需求的是用户查询自己的订单，也需要按照用户进行切分订单库，并且支持一主多读。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
在硬件存储方面，对于事务日志因是顺序写，闪存的优势比硬盘高不了多少，所以采取电池保护的写缓存的<span style="font-family:Calibri">raid</span><span style="font-family:宋体">卡存储；对于数据文件，无论是对用户或者订单都会存在大量的随机读写操作，当然加大内存是一个方面，另外可以采用高速的</span><span style="font-family:Calibri">IO</span><span style="font-family:宋体">设备闪存，比如</span><span style="font-family:Calibri">PCIe</span><span style="font-family:宋体">卡 </span><span style="font-family:Calibri">fusion-io</span><span style="font-family:宋体">。使用闪存也适合在单线程的负载中，比如主从复制，可以对从节点配置<span style="font-family:Calibri">fusion-IO</span>卡，降低复制的延迟。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于订单业务来讲，量是不断递增的，<span style="font-family:Calibri">PCIe</span><span style="font-family:宋体">卡存储容量比较有限，并且订单业务的热数据只有最近一段时间的</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">比如近</span><span style="font-family:Calibri">3</span><span style="font-family:宋体">个月的</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，对此这里列两种解决方案，一种是</span><span style="font-family:Calibri">flashcache</span><span style="font-family:宋体">方式，采用基于闪存和硬盘存储的开源混合存储方式，在闪存中存储热点的数据。另外一种是可以定期把老的数据导出到分布式数据库</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">中，用户在查询订单列表是近期的数据从</span><span style="font-family:Calibri">mysql</span><span style="font-family:宋体">中获取，老的数据可以从</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">中查询，当然需要</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">良好的</span><span style="font-family:Calibri">rowkey</span><span style="font-family:宋体">设计以适应查询需求。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h3 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t44" style="color:rgb(106,57,6)" id="t44"></a>3) 分布式数据库</h3>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
对于数据的高并发的访问，传统的关系型数据库提供读写分离的方案，但是带来的确实数据的一致性问题提供的数据切分的方案；对于越来越多的海量数据，传统的数据库采用的是分库分表，实现起来比较复杂，后期要不断的进行迁移维护；对于高可用和伸缩方面，传统数据采用的是主备、主从、多主的方案，但是本身扩展性比较差，增加节点和宕机需要进行数据的迁移。对于以上提出的这些问题，分布式数据库<span style="font-family:Calibri">HBase</span><span style="font-family:宋体">有一套完善的解决方案，适用于高并发海量数据存取的要求。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Ø HBase</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
基于列式的高效存储降低<span style="font-family:Calibri">IO</span><br />&#13;
通常的查询不需要一行的全部字段，大多数只需要几个字段<br />&#13;
对与面向行的存储系统，每次查询都会全部数据取出，然后再从中选出需要的字段<br />&#13;
面向列的存储系统可以单独查询某一列，从而大大降低<span style="font-family:Calibri">IO</span><br />&#13;
提高压缩效率<br />&#13;
同列数据具有很高的相似性，会增加压缩效率<br />&#13;
Hbase<span style="font-family:宋体">的很多特性，都是由列存储决定的</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>高性能</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
LSM Tree</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
适合高速写的场景</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <img width="412" height="178" alt="" src="http://img.blog.csdn.net/20131002230609750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>强一致的数据访问</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
MVCC</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">的一致性数据访问是通过</span><span style="font-family:Calibri">MVCC</span><span style="font-family:宋体">来实现的。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">在写数据的过程中，需要经过好几个阶段，写</span><span style="font-family:Calibri">HLog</span><span style="font-family:宋体">，写</span><span style="font-family:Calibri">memstore</span><span style="font-family:宋体">，更新</span><span style="font-family:Calibri">MVCC;</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
只有更新了<span style="font-family:Calibri">MVCC</span><span style="font-family:宋体">，才算真正</span><span style="font-family:Calibri">memstore</span><span style="font-family:宋体">写成功，其中事务的隔离需要有</span><span style="font-family:Calibri">mvcc</span><span style="font-family:宋体">的来控制，比如读数据不可以获取别的线程还未提交的数据。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>高可靠</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">的数据存储基于</span><span style="font-family:Calibri">HDFS</span><span style="font-family:宋体">，提供了冗余机制。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Region<span style="font-family:宋体">节点的宕机，对于内存中的数据还未</span><span style="font-family:Calibri">flush</span><span style="font-family:宋体">到文件中，提供了可靠的恢复机制。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<img width="496" height="165" alt="" src="http://img.blog.csdn.net/20131002230651125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%; width:478px; height:225px" /></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
  </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>可伸缩，自动切分，迁移</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通过<span style="font-family:Calibri">Zookeeper</span><span style="font-family:宋体">定位目标</span><span style="font-family:Calibri">Region Server</span><span style="font-family:宋体">，最后定位</span><span style="font-family:Calibri">Region</span><span style="font-family:宋体">。 </span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
Region Server<span style="font-family:宋体">扩容，通过将自身发布到</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">均匀分布。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>可用性</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
存在单点故障，<span style="font-family:Calibri">Region Server</span><span style="font-family:宋体">宕机后，短时间内该</span><span style="font-family:Calibri">server</span><span style="font-family:宋体">维护的</span><span style="font-family:Calibri">region</span><span style="font-family:宋体">无法访问，等待</span><span style="font-family:Calibri">failover</span><span style="font-family:宋体">生效。 </span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
通过<span style="font-family:Calibri">Master</span><span style="font-family:宋体">维护各</span><span style="font-family:Calibri">Region Server</span><span style="font-family:宋体">健康状况和</span><span style="font-family:Calibri">Region</span><span style="font-family:宋体">分布。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
多个<span style="font-family:Calibri">Master</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">宕机有</span><span style="font-family:Calibri">zookeeper</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">paxos</span><span style="font-family:宋体">投票机制选取下一任</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">。</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">就算全宕机，也不影响</span><span style="font-family:Calibri">Region</span><span style="font-family:宋体">读写。</span><span style="font-family:Calibri">Master</span><span style="font-family:宋体">仅充当一个自动运维角色。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HDFS<span style="font-family:宋体">为分布式存储引擎，一备三，高可靠，</span><span style="font-family:Calibri">0</span><span style="font-family:宋体">数据丢失。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HDFS<span style="font-family:宋体">的</span><span style="font-family:Calibri">namenode</span><span style="font-family:宋体">是一个</span><span style="font-family:Calibri">SPOF</span><span style="font-family:宋体">。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
为避免单个region<span style="font-family:宋体">访问过于频繁，单机压力过大，提供了</span><span style="font-family:Calibri">split</span><span style="font-family:宋体">机制</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">的写入是</span><span style="font-family:Calibri">LSM-TREE</span><span style="font-family:宋体">的架构方式，随着数据的</span><span style="font-family:Calibri">append</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">HFile</span><span style="font-family:宋体">越来越多，</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">提供了</span><span style="font-family:Calibri">HFile</span><span style="font-family:宋体">文件进行</span><span style="font-family:Calibri">compact</span><span style="font-family:宋体">，对过期数据进行清除，提高查询的性能。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>Schema free</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">没有像关系型数据库那样的严格的</span><span style="font-family:Calibri">schema</span><span style="font-family:宋体">，可以自由的增加和删除</span><span style="font-family:Calibri">schema</span><span style="font-family:宋体">中的字段。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
HBase<span style="font-family:宋体">分布式数据库，对于二级索引支持的不太好，目前只支持在</span><span style="font-family:Calibri">rowkey</span><span style="font-family:宋体">上的索引，所以</span><span style="font-family:Calibri">rowkey</span><span style="font-family:宋体">的设计对于查询的性能来讲非常关键。</span></p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t45" style="color:rgb(106,57,6)" id="t45"></a>7. 管理与部署配置</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
统一的配置库</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
部署平台</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<h2 style="margin:0px; padding:0px; color:rgb(54,46,43); font-family:Arial; line-height:26px">&#13;
<a target="_blank" name="t46" style="color:rgb(106,57,6)" id="t46"></a>8. 监控、统计</h2>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
大型分布式系统涉及各种设备，比如网络交换机，普通<span style="font-family:Calibri">PC</span><span style="font-family:宋体">机，各种型号的网卡，硬盘，内存等等，还有应用业务层次的监控，数量非常多的时候，出现错误的概率也会变大，并且有些监控的时效性要求比较高，有些达到秒级别；在大量的数据流中需要过滤异常的数据，有时候也对数据会进行上下文相关的复杂计算，进而决定是否需要告警。因此监控平台的性能、吞吐量、已经可用性就比较重要，需要规划统一的一体化的监控平台对系统进行各个层次的监控。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>平台的数据分类</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
应用业务级别：应用事件、业务日志、审计日志、请求日志、异常、请求业务<span style="font-family:Calibri">metrics</span><span style="font-family:宋体">、性能度量</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
系统级别：<span style="font-family:Calibri">CPU</span><span style="font-family:宋体">、内存、网络、</span><span style="font-family:Calibri">IO</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>时效性要求</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
阀值，告警：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
实时计算：</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
近实时分钟计算</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
按小时、天的离线分析</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
实时查询</p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 </p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
<strong>架构</strong></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
节点中<span style="font-family:Calibri">Agent</span><span style="font-family:宋体">代理可以接收日志、应用的事件以及通过探针的方式采集数据，</span><span style="font-family:Calibri">agent</span><span style="font-family:宋体">采集数据的一个原则是和业务应用的流程是异步隔离的，不影响交易流程。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据统一通过<span style="font-family:Calibri">collector</span><span style="font-family:宋体">集群进行收集，按照数据的不同类型分发到不同的计算集群进行处理；有些数据时效性不是那么高，比如按小时进行统计，放入</span><span style="font-family:Calibri">hadoop</span><span style="font-family:宋体">集群；有些数据是请求流转的跟踪数据，需要可以查询的，那么就可以放入</span><span style="font-family:Calibri">solr</span><span style="font-family:宋体">集群进行索引；有些数据需要进行实时计算的进而告警的，需要放到</span><span style="font-family:Calibri">storm</span><span style="font-family:宋体">集群中进行处理。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
数据经过计算集群处理后，结果存储到<span style="font-family:Calibri">Mysql</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">HBase</span><span style="font-family:宋体">中。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
监控的<span style="font-family:Calibri">web</span><span style="font-family:宋体">应用可以把监控的实时结果推送到浏览器中，也可以提供</span><span style="font-family:Calibri">API</span><span style="font-family:宋体">供结果的展现和搜索。</span></p>&#13;
<p style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">&#13;
 <img width="546" height="349" alt="" src="http://img.blog.csdn.net/20131002230740609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2J1dGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:none; max-width:100%" /></p>&#13;
<br />&#13;
   &#13;
