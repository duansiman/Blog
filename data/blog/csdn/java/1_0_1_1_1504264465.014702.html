

<h2>一.简介：</h2>&#13;
<blockquote><span style="color:black">   <em> <span style="font-size:14px"> </span>&#13;
</em></span><span style="font-size:14px">Spring<span style="color:black">在英语中含义是春天，对于</span><span style="color:black">JavaEE</span><span style="color:black">开发者来说，</span><span style="color:black">Spring</span><span style="color:black">框架出现确实带来了一股全新的春天的气息。早在</span><span style="color:black">2002</span><span style="color:black">年，</span><span style="color:#333399">Rod&#13;
 Johson</span><span style="color:black">在其编著的</span><span style="color:black">《</span><span style="color:black">Expert one to one J2EE design anddevelopment</span><span style="color:black">》</span><span style="color:black">书中，对</span><span style="color:black">Java&#13;
 EE</span><span style="color:black">框架臃肿、低效、脱离现实的种种现状提出了很多质疑，并积极寻求探索革新之道。由他主导编写了</span><span style="color:#333399">interface21</span><span style="color:#333399">框架</span><span style="color:black">，从实际需求出发，着眼于</span><span style="color:#333399">轻便、灵巧，易于开发、测试和部署</span><span style="color:black">的</span><span style="color:#333399">轻量级开发框架</span><span style="color:black">。以</span><span style="color:black">interface21</span><span style="color:black">框架为基础，并集成了其它许多开源成果，于</span><span style="color:black">2004</span><span style="color:black">年</span><span style="color:black">3</span><span style="color:black">月</span><span style="color:black">24</span><span style="color:black">日，发布了</span><span style="color:#333399">1.0</span><span style="color:#333399">正式版取名为</span><span style="color:#333399">Spring</span><span style="color:black">。</span></span><br />&#13;
<span style="font-size:14px"><span style="color:black"></span></span>&#13;
<p><span style="color:black">    </span>Spring<span style="color:black">的核心是个</span><span style="color:#333399">轻量级容器</span><span style="color:black">，实现了</span><span style="color:#333399">IoC</span><span style="color:#333399">（控制翻转）模式</span><span style="color:black">的容器，基于此核心容器所建立的应用程序，可以达到程序组件的</span><span style="color:#333399">松散耦合</span><span style="color:black">。这些特性都使得整个应用程序维护简化。</span><span style="color:black">Spring</span><span style="color:black">框架核心由下图所示的</span><span style="color:#333399">七个模块</span><span style="color:black">组成。</span></p>&#13;
<img src="http://img.blog.csdn.net/20160831011842490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
<br />&#13;
<span style="font-size:14px"><span style="color:black"><br />&#13;
</span></span><br />&#13;
<span style="font-size:14px"><span style="color:black"></span></span>&#13;
<p><span style="color:#CC0000">1</span><span style="color:#CC0000">、核心容器</span><span style="color:#CC0000">(Core)</span></p>&#13;
<p><span style="color:black">        </span>这是<span style="color:black">Spring</span><span style="color:black">框架</span><span style="color:#333399">最基础的部分</span><span style="color:black">，它</span><span style="color:#333399">提供了依赖注入（</span><span style="color:#333399">Dependency&#13;
 Injection</span><span style="color:#333399">）特征来实现容器对</span><span style="color:#333399">Bean</span><span style="color:#333399">的管理</span><span style="color:black">。这里最基本的概念是</span><span style="color:#333399">BeanFactory</span><span style="color:black">，它是任何</span><span style="color:black">Spring</span><span style="color:black">应用的核心。</span><span style="color:black">BeanFactory</span><span style="color:black">是工厂模式的一个实现，它</span><span style="color:#333399">使用</span><span style="color:#333399">IoC</span><span style="color:#333399">将</span><span style="color:#CC0000">应用配置和依赖说明</span><span style="color:#333399">从实际的应用代码中分离出来</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#CC0000">2</span><span style="color:#CC0000">、</span><span style="color:#CC0000">AOP</span><span style="color:#CC0000">模块</span></p>&#13;
<p><span style="color:black">      </span>AOP<span style="color:black">即面向</span><span style="color:#333399">切面编程技术</span><span style="color:black">，</span><span style="color:black">Spring</span><span style="color:black">在它的</span><span style="color:black">AOP</span><span style="color:black">模块中提供了对面向切面编程的丰富支持。</span><span style="color:black">AOP</span><span style="color:black">允许</span><span style="color:#333399">通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发</span><span style="color:black">。应用对象只实现它们应该做的</span><span style="color:black">——</span><span style="color:black">完成业务逻辑</span><span style="color:black">——</span><span style="color:black">仅此而已。它们</span><span style="color:#333399">并不负责其它的系统级关注点，例如日志或事务支持</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#CC0000">3</span><span style="color:#CC0000">、对象</span><span style="color:#CC0000">/</span><span style="color:#CC0000">关系映射集成模块</span><span style="color:#CC0000">ORM</span></p>&#13;
<p><span style="color:black">     </span>Hibernate<span style="color:black">是成熟的</span><span style="color:black">ORM</span><span style="color:black">产品，</span><span style="color:black">Spring</span><span style="color:black">并没有自己实现</span><span style="color:black">ORM</span><span style="color:black">框架而是</span><span style="color:#333399">集成了几个流行的</span><span style="color:#333399">ORM</span><span style="color:#333399">产品如</span><span style="color:#333399">Hibernate</span><span style="color:#333399">、</span><span style="color:#333399">JDO</span><span style="color:#333399">和</span><span style="color:#333399">iBATIS</span><span style="color:#333399">等</span><span style="color:black">。可以利用</span><span style="color:black">Spring</span><span style="color:black">对这些模块提供事务支持等。</span></p>&#13;
<p><span style="color:#CC0000">4</span><span style="color:#CC0000">、</span><span style="color:#CC0000">JDBC</span><span style="color:#CC0000">抽象和</span><span style="color:#CC0000">DAO</span><span style="color:#CC0000">模块</span></p>&#13;
<p><span style="color:black">     </span><span style="color:black">Spring</span><span style="color:black">虽然集成了几个</span><span style="color:black">ORM</span><span style="color:black">产品，但也可以不选择这几款产品，因为</span><span style="color:#333399">Spring</span><span style="color:#333399">提供了</span><span style="color:#333399">JDBC</span><span style="color:#333399">和</span><span style="color:#333399">DAO</span><span style="color:#333399">模块</span><span style="color:black">。该模块对现有的</span><span style="color:black">JDBC</span><span style="color:black">技术进行了</span><span style="color:#333399">优化</span><span style="color:black">。你可以保持你的数据库访问</span><span style="color:#333399">代码干净简洁</span><span style="color:black">，并且可以</span><span style="color:#333399">防止因关闭数据库资源失败而引起的问题</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#CC0000">5</span><span style="color:#CC0000">、</span><span style="color:#CC0000">Spring</span><span style="color:#CC0000">的</span><span style="color:#CC0000">Web</span><span style="color:#CC0000">模块</span></p>&#13;
<p><span style="color:black">      </span>Web<span style="color:black">上下文模块建立于应用上下文模块之上，</span><span style="color:#333399">提供了一个适合于</span><span style="color:#333399">Web</span><span style="color:#333399">应用的上下文</span><span style="color:black">。另外，这个模块</span><span style="color:#333399">还提供了一些面向服务支持</span><span style="color:black">。例如：实现文件上传的</span><span style="color:black">multipart</span><span style="color:black">请求，它也提供了</span><span style="color:black">Spring</span><span style="color:black">和其它</span><span style="color:black">Web</span><span style="color:black">框架的集成，比如</span><span style="color:black">Struts</span><span style="color:black">、</span><span style="color:black">WebWork</span><span style="color:black">。</span></p>&#13;
<p><span style="color:#CC0000">6</span><span style="color:#CC0000">、应用上下文（</span><span style="color:#CC0000">Context</span><span style="color:#CC0000">）模块</span></p>&#13;
<p><span style="color:black">       </span>核心模块的<span style="color:#333399">BeanFactory</span><span style="color:#333399">使</span><span style="color:#333399">Spring</span><span style="color:#333399">成为一个容器</span><span style="color:black">，而</span><span style="color:#333399">上下文模块使它成为一个框架</span><span style="color:black">。</span><span style="color:#333399">Web</span><span style="color:#333399">上下文模块</span><span style="color:black">建立于应用上下文模块之上，提供了一个</span><span style="color:#333399">适合于</span><span style="color:#333399">Web</span><span style="color:#333399">应用的上下文</span><span style="color:black">。该模块还提供了一些</span><span style="color:#333399">面向服务支持这个模块</span><span style="color:black">扩展了</span><span style="color:black">BeanFactory</span><span style="color:black">的概念，增加了对</span><span style="color:#333399">国际化（</span><span style="color:#333399">I18N</span><span style="color:#333399">）消息、事件传播以及验证</span><span style="color:black">的支持。</span></p>&#13;
<p><span style="color:black">      </span>另外，这个模块还提供了<span style="color:#333399">许多企业服务</span><span style="color:black">，例如电子邮件、</span><span style="color:black">JNDI</span><span style="color:black">访问、</span><span style="color:black">EJB</span><span style="color:black">集成、远程以及时序调度（</span><span style="color:black">scheduling</span><span style="color:black">）服务。也包括对</span><span style="color:#333399">模版框架</span><span style="color:black">例如</span><span style="color:black">Velocity</span><span style="color:black">和</span><span style="color:black">FreeMarker</span><span style="color:black">集成的支持。</span></p>&#13;
<p><span style="color:#CC0000">7</span><span style="color:#CC0000">、</span><span style="color:#CC0000">Spring</span><span style="color:#CC0000">的</span><span style="color:#CC0000">MVC</span><span style="color:#CC0000">框架</span></p>&#13;
<p><span style="color:black">      </span>Spring<span style="color:black">为构建</span><span style="color:black">Web</span><span style="color:black">应用提供了一个</span><span style="color:#333399">功能全面的</span><span style="color:#333399">MVC</span><span style="color:#333399">框架</span><span style="color:black">。虽然</span><span style="color:black">Spring</span><span style="color:black">可以很容易地与其它</span><span style="color:black">MVC</span><span style="color:black">框架集成，例如</span><span style="color:black">Struts2</span><span style="color:black">，但</span><span style="color:#333399">Spring</span><span style="color:#333399">的</span><span style="color:#333399">MVC</span><span style="color:#333399">框架使用</span><span style="color:#333399">IoC</span><span style="color:#333399">对控制逻辑和业务对象提供了完全的分离</span><span style="color:black">。</span></p>&#13;
</blockquote>&#13;
<h2><em><span style="font-size:14px"><span style="color:black">二.<span style="color:black">Spring</span><span style="color:black">入门示例</span></span></span></em></h2>&#13;
<p>        spring2.5基础包：spring.jar和commons-logging.jar</p>&#13;
<p>        spring3.x基础包：</p>&#13;
<ul>&#13;
<li> commons-logging.jar</li><li>org.springframework.asm-3.1.1.RELEASE.jar</li><li>org.springframework.beans-3.1.1.RELEASE.jar</li><li>org.springframework.context.support-3.1.1.RELEASE.jar</li><li>org.springframework.context-3.1.1.RELEASE.jar</li><li>org.springframework.core-3.1.1.RELEASE.jar</li><li>org.springframework.expression-3.1.1.RELEASE.jar<br />&#13;
</li></ul>&#13;
<p>                                 <br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<blockquote>建立好<span style="color:black">web</span><span style="color:black">工程或</span><span style="color:black">Java</span><span style="color:black">工程后</span><span style="color:#333399">在</span><span style="color:#333399">MyEclipse</span><span style="color:#333399">中</span><span style="color:black">可以加入</span><span style="color:black">Spring</span><span style="color:black">的支持，</span><span style="color:#333399">导入</span><span style="color:#333399">Spring</span><span style="color:#333399">的核心包</span><span style="color:black">。如果是</span><span style="color:#333399">Eclipse</span><span style="color:black">则在</span><span style="color:black">Spring</span><span style="color:black">网站上</span><span style="color:#333399">下载</span><span style="color:#333399">Spring</span><span style="color:#333399">的核心</span><span style="color:black">包并加入到工程中。</span><br />&#13;
<p><span style="color:#333399">1</span><span style="color:#333399">、编写一个普通的</span><span style="color:#333399">Java</span><span style="color:#333399">类（</span><span style="color:#333399">JavaBean</span><span style="color:#333399">）</span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_1_764349" name="code" class="html">package cn.hncu.s25.domain;

public class Person {
	private String name;
	private Integer age;
	
	public Person() {
		System.out.println("这是构造函数");
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
}

</pre>&#13;
<p><span style="color:#333399">2</span><span style="color:#333399">、在</span><span style="color:#333399">Spring</span><span style="color:#333399">配置文件</span><span style="color:#CC0000">applicationContext.xml</span><span style="color:#333399">。</span><span style="color:black">将</span><span style="color:black">JavaBean</span><span style="color:black">由</span><span style="color:black">Spring</span><span style="color:black">容器来管理。（2.5和3.x版本不一致，这里一2.5版本为例）</span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_2_6587654" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;
	&lt;bean id="p" class="cn.hncu.s25.domain.Person" scope="singleton"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
<br />&#13;
<p><span style="color:#333399">3</span><span style="color:#333399">、如何使用</span><span style="color:#333399">Spring</span><span style="color:#333399">容器配置的</span><span style="color:#333399">Bean</span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_3_3349051" name="code" class="html">                BeanFactory factory=new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));//这是2.5版本的方法
		Person p=(Person) factory.getBean("p");
		System.out.println(p.hashCode());


</pre><br />&#13;
<br />&#13;
</blockquote>&#13;
<h2><span style="color:#330033">三、Spring配置文件详解：</span></h2>&#13;
<blockquote>&#13;
<p><span style="color:#333399">这个配置文件<br />&#13;
</span></p>&#13;
<p><span style="color:#333399"></span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_4_532700" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt;
	&lt;bean id="p" class="cn.hncu.s3x.domain.Person"&gt;
		&lt;property name="name" value="Jack"&gt;&lt;/property&gt;
		&lt;property name="age" value="23"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="user" class="cn.hncu.s3x.demo2.User"&gt;
		&lt;property name="name" value="Jack" /&gt;
		&lt;property name="age" value="20" /&gt;
		&lt;property name="cat" ref="cat" /&gt;
		&lt;property name="pets"&gt;
			&lt;list&gt;
				&lt;value&gt;Tom&lt;/value&gt;
				&lt;value&gt;dog&lt;/value&gt;
				&lt;value&gt;pig&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
		&lt;property name="map"&gt;
			&lt;map&gt;
				&lt;entry key="name" value="中国"&gt;
				&lt;/entry&gt;
			&lt;/map&gt;
		&lt;/property&gt;
		&lt;property name="set"&gt;
			&lt;set&gt;
				&lt;value&gt;aaa&lt;/value&gt;
				&lt;value&gt;bbb&lt;/value&gt;
			&lt;/set&gt;
		&lt;/property&gt;
		&lt;property name="objs"&gt;
			&lt;array&gt;
				&lt;value&gt;222&lt;/value&gt;
				&lt;ref bean="cat2" /&gt;
				&lt;list&gt;
					&lt;ref bean="cat2" /&gt;
					&lt;ref bean="cat" /&gt;
				&lt;/list&gt;
				&lt;bean class="cn.hncu.s3x.demo2.Cat"&gt;
					&lt;property name="name" value="我的猫" /&gt;
				&lt;/bean&gt;
			&lt;/array&gt;
		&lt;/property&gt;
		&lt;property name="list"&gt;
			&lt;list&gt;
				&lt;map&gt;
					&lt;entry key-ref="p" value-ref="cat"&gt;&lt;/entry&gt;
					&lt;entry value-ref="cat2"&gt;
						&lt;key&gt;
							&lt;bean class="cn.hncu.s3x.domain.Person"&gt;
								&lt;property name="name" value="王建安" /&gt;
								&lt;property name="age" value="25" /&gt;
							&lt;/bean&gt;
						&lt;/key&gt;
					&lt;/entry&gt;
				&lt;/map&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="cat" class="cn.hncu.s3x.demo2.Cat"&gt;
		&lt;property name="name" value="Tom猫" /&gt;
	&lt;/bean&gt;
	&lt;bean id="cat2" class="cn.hncu.s3x.demo2.Cat"&gt;
		&lt;property name="name" value="黑猫" /&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</pre>这是Bean对象&#13;
<p></p>&#13;
<p><span style="color:#333399"></span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_5_2626251" name="code" class="html">package cn.hncu.s3x.demo2;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class User {
	private String name;
	private Integer age;
	private Cat cat;
	private List&lt;String&gt; pets;
	private Map&lt;String,Object&gt; map;
	private Set&lt;String&gt; set;
	private Object objs[];
	private List&lt;Map&lt;Object, Cat&gt;&gt; list;
	

	

	public List&lt;Map&lt;Object, Cat&gt;&gt; getList() {
		return list;
	}

	public void setList(List&lt;Map&lt;Object, Cat&gt;&gt; list) {
		this.list = list;
	}

	public Set&lt;String&gt; getSet() {
		return set;
	}

	public void setSet(Set&lt;String&gt; set) {
		this.set = set;
	}

	public Object[] getObjs() {
		return objs;
	}

	public void setObjs(Object[] objs) {
		this.objs = objs;
	}

	public Map&lt;String, Object&gt; getMap() {
		return map;
	}

	public void setMap(Map&lt;String, Object&gt; map) {
		this.map = map;
	}

	public List&lt;String&gt; getPets() {
		return pets;
	}

	public void setPets(List&lt;String&gt; pets) {
		this.pets = pets;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getAge() {
		return age;
	}

	public void setAge(Integer age) {
		this.age = age;
	}

	public Cat getCat() {
		return cat;
	}

	public void setCat(Cat cat) {
		this.cat = cat;
	}
       @Override
    public String toString() {
        return "User [name=" + name + ", age=" + age + ", cat=" + cat
                + ", pets=" + pets + ", map=" + map + ", set=" + set
                + ", objs=" + Arrays.toString(objs) + ", list=" + list + "]";
    }
	
}



package cn.hncu.s3x.demo2;

public class Cat {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Cat [name=" + name + "]";
    }
    
}


package cn.hncu.s3x.domain;

public class Person {
    private String name;
    private Integer age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
    
}

 </pre><br />&#13;
这是测试代码&#13;
<p></p>&#13;
<p><span style="color:#333399"></span></p>&#13;
<pre code_snippet_id="1858913" snippet_file_name="blog_20160831_6_6356005" name="code" class="html">package cn.hncu.s3x.demo2;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Demo2 {
	@Test
	public void demo1(){
		ApplicationContext act=new ClassPathXmlApplicationContext("app2.xml");
		User user=act.getBean("user", User.class);
		System.out.println(user);
	}
}
</pre><br />&#13;
<p></p>&#13;
<p><span style="color:#333399"><br />&#13;
</span></p>&#13;
</blockquote>&#13;
<h2><span style="color:#333399"></span>&#13;
</h2><p><span style="color:black">四、Spring IOC </span><span style="color:black">控制反转</span></p>&#13;
&#13;
<blockquote>&#13;
<p><span style="color:#333399"></span></p>&#13;
<p><span style="color:black">     </span><span style="color:#333399">IoC</span><span style="color:#333399">(Inversion of Control)</span><span style="color:black">中文译为</span><span style="color:#333399">控制反转</span><span style="color:black">也可以叫做</span><span style="color:#333399">DI</span><span style="color:black">（</span><span style="color:black">Dependency&#13;
 Injection</span><span style="color:black">，</span><span style="color:#333399">依赖注入</span><span style="color:black">）。</span></p>&#13;
<p><span style="color:#333399">控制反转模式的基本概念是：</span><span style="color:#CC0000">不直接创建对象，但是</span><span style="color:#CC00FF">在</span><span style="color:#CC00FF">xml</span><span style="color:#CC00FF">配置文件中</span><span style="color:#CC0000">描述创建它们的方式。</span><span style="color:black">在工程中使用该</span><span style="color:black">Bean</span><span style="color:black">时由</span><span style="color:black">Spring</span><span style="color:black">容器创建</span><span style="color:black">Bean</span><span style="color:black">的实例。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。</span></p>&#13;
<p><span style="color:#333399">第1步</span><span style="color:#333399">、</span><span style="color:#333399">Spring</span><span style="color:#333399">注入</span><span style="color:#333399">(</span><span style="color:#333399">又称依赖注入</span><span style="color:#333399">DI):</span><span style="color:black">其目的是为其中</span><span style="color:black">bean</span><span style="color:black">的属性赋值</span></p>&#13;
<p><span style="color:#333399">第</span><span style="color:#333399">2</span><span style="color:#333399">步</span><span style="color:#333399">:</span><span style="color:#333399">在配置文件中注入属性的初始值</span></p>&#13;
</blockquote>&#13;
<h2><span style="color:#333399"></span>&#13;
</h2><p><span style="color:#333399"><span style="color:black">五、Spring Bean</span><span style="color:black">的作用域</span></span></p>&#13;
&#13;
<blockquote><span style="color:#333399"><span style="color:black"></span></span>&#13;
<p><span style="color:black">     </span>在<span style="color:black">Spring2.0</span><span style="color:black">之前</span><span style="color:black">bean</span><span style="color:black">只有</span><span style="color:black">2</span><span style="color:black">种作用域即：</span><span style="color:#333399">singleton(</span><span style="color:#333399">单例</span><span style="color:#333399">)</span><span style="color:black">、</span><span style="color:#333399">non-singleton</span><span style="color:#333399">（也称</span><span style="color:#333399">prototype</span><span style="color:#333399">）</span><span style="color:black">,&#13;
 Spring2.0</span><span style="color:black">以后，增加了</span><span style="color:#333399">session</span><span style="color:#333399">、</span><span style="color:#333399">request</span><span style="color:#333399">、</span><span style="color:#333399">global session</span><span style="color:black">三种专用于</span><span style="color:black">Web</span><span style="color:black">应用程序上下文的</span><span style="color:black">Bean</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black">     </span><span style="color:black">因此，</span><span style="color:#CC0000">默认情况下</span><span style="color:#CC0000">Spring2.0</span><span style="color:#CC0000">现在有五种类型的</span><span style="color:#CC0000">Bean</span><span style="color:black">。当然，</span><span style="color:black">Spring2.0</span><span style="color:black">对</span><span style="color:black">Bean</span><span style="color:black">的类型的设计进行了重构，并设计出灵活的</span><span style="color:black">Bean</span><span style="color:black">类型支持，</span><span style="color:#333399">理论上可以有无数多种类型的</span><span style="color:#333399">Bean</span><span style="color:black">，用户可以根据自己的需要，增加新的</span><span style="color:black">Bean</span><span style="color:black">类型，满足实际应用需求。</span></p>&#13;
<p><span style="color:black"></span></p>&#13;
<p><span style="color:#333399">1</span><span style="color:#333399">、</span><span style="color:#333399">singleton</span><span style="color:#333399">单实例</span></p>&#13;
<p><span style="color:black">  </span> <span style="color:black">当一个</span><span style="color:black">bean</span><span style="color:black">的作用域设置为</span><span style="color:black">singleton,</span><span style="color:black">那么</span><span style="color:#333399">Spring&#13;
 IOC</span><span style="color:#333399">容器中只会存在一个共享的</span><span style="color:#333399">bean</span><span style="color:#333399">实例，并且所有对</span><span style="color:#333399">bean</span><span style="color:#333399">的请求，只要</span><span style="color:#333399">id</span><span style="color:#333399">与该</span><span style="color:#333399">bean</span><span style="color:#333399">定义相匹配，则只会返回</span><span style="color:#333399">bean</span><span style="color:#333399">的同一实例</span><span style="color:black">。换言之，当把一个</span><span style="color:black">bean</span><span style="color:black">定义设置为</span><span style="color:black">singleton</span><span style="color:black">作用域时，</span><span style="color:black">Spring&#13;
 IOC</span><span style="color:black">容器只会创建该</span><span style="color:black">bean</span><span style="color:black">定义的唯一实例。这个单一实例会被存储到单例缓存（</span><span style="color:black">singletoncache</span><span style="color:black">）中，并且</span><span style="color:#333399">所有针对该</span><span style="color:#333399">bean</span><span style="color:#333399">的后续请求和引用都将返回被缓存的对象实例</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black">&lt;beanid="</span><span style="color:#CC0000">userdao</span><span style="color:black">"class="</span><span style="color:black">com.bean.UserDao</span><span style="color:black">"</span><span style="color:#333399">scope="singleton"</span><span style="color:black">/&gt;</span></p>&#13;
<p><span style="color:black">或</span><span style="color:black">&lt;beanid=" </span><span style="color:black">userdao</span><span style="color:black">" class="</span><span style="color:black">com.bean.UserDao</span><span style="color:black">"</span><span style="color:#333399">singleton="true"</span><span style="color:black">/&gt; </span></p>&#13;
<p><span style="color:black">UserDao</span><span style="color:black">bean1=( </span>&#13;
<span style="color:black">UserDao</span><span style="color:black">)</span><span style="color:black">factory.getBean</span><span style="color:black">("</span><span style="color:#CC0000">userdao</span><span style="color:black">");</span></p>&#13;
<p><span style="color:black">UserDao</span><span style="color:black">bean2=( </span>&#13;
<span style="color:black">UserDao</span><span style="color:black">)</span><span style="color:black">factory.getBean</span><span style="color:black">("</span><span style="color:#CC0000">userdao</span><span style="color:black">");</span></p>&#13;
<p><span style="color:#333399">2</span><span style="color:#333399">、</span><span style="color:#333399">prototype</span><span style="color:#333399">多实例</span><span style="color:black">  </span></p>&#13;
<p><span style="color:black">    </span><span style="color:#333399">每个</span><span style="color:#333399">Spring</span><span style="color:#333399">容器中，一个</span><span style="color:#333399">bean</span><span style="color:#333399">对应多个实例</span><span style="color:black">.</span><span style="color:black">&#13;
 prototype</span><span style="color:black">作用域部署的</span><span style="color:black">bean</span><span style="color:black">，</span><span style="color:#333399">每一次请求（将其注入到另一个</span><span style="color:#333399">bean</span><span style="color:#333399">中，或者以程序的方式调用容器的</span><span style="color:#333399">getBean</span><span style="color:#333399">()</span><span style="color:#333399">方法）都会产生一个新的</span><span style="color:#333399">bean</span><span style="color:#333399">实例，相当一个</span><span style="color:#333399">new</span><span style="color:#333399">的操作</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black">&lt;beanid="</span><span style="color:#CC0000">userdao</span><span style="color:black">"class="</span><span style="color:black">com.bean.UserDao</span><span style="color:black">"</span></p>&#13;
<p><span style="color:black">                                                  </span><span style="color:#333399">scope="prototype"</span><span style="color:black">/&gt;</span></p>&#13;
<p><span style="color:black">或</span><span style="color:black">&lt;beanid=" </span><span style="color:black">userdao</span><span style="color:black">" class="</span><span style="color:black">com.bean.UserDao</span><span style="color:black">"</span></p>&#13;
<p><span style="color:black">                                                    </span><span style="color:#333399">singleton="false"</span><span style="color:black">/&gt; </span></p>&#13;
<p><span style="color:black"> </span><span style="color:black">UserDao</span><span style="color:black"> bean1=(</span><span style="color:black">UserDao</span><span style="color:black">)</span><span style="color:black">factory.getBean</span><span style="color:black">("</span><span style="color:#CC0000">userdao</span><span style="color:black">");</span></p>&#13;
<p><span style="color:black"> </span><span style="color:black">UserDao</span><span style="color:black"> bean2=(</span><span style="color:black">UserDao</span><span style="color:black">)</span><span style="color:black">factory.getBean</span><span style="color:black">("</span><span style="color:#CC0000">userdao</span><span style="color:black">");</span></p>&#13;
<p><span style="color:black">Bean1</span><span style="color:black">与</span><span style="color:black">bean2</span><span style="color:black">的引用不相同。每次使用</span><span style="color:black">getBean</span><span style="color:black">()</span><span style="color:black">重新产生一个实例</span></p>&#13;
<p><span style="color:#333399">3</span><span style="color:#333399">、</span><span style="color:#333399">request  </span><span style="color:black"> </span></p>&#13;
<p><span style="color:black">     </span>request<span style="color:black">表示该</span><span style="color:#333399">针对每一次</span><span style="color:#333399">HTTP</span><span style="color:#333399">请求都会产生一个新的</span><span style="color:#333399">bean</span><span style="color:black">，同时该</span><span style="color:black">bean</span><span style="color:#333399">仅在当前</span><span style="color:#333399">HTTP&#13;
 request</span><span style="color:#333399">内有效</span><span style="color:black">。</span></p>&#13;
<p><span style="color:black">    </span><span style="color:black">&lt;bean id="</span><span style="color:black">userdao</span><span style="color:black">"class="</span><span style="color:black">com.bean.UserDao</span><span style="color:black">"</span></p>&#13;
<p><span style="color:black">                                                      </span><span style="color:#333399">scope="request"</span><span style="color:black">/&gt;</span></p>&#13;
<p><span style="color:#333399">4</span><span style="color:#333399">、</span><span style="color:#333399">session </span><span style="color:black">   </span></p>&#13;
<p><span style="color:black">      </span>session<span style="color:black">作用域表示</span><span style="color:#333399">该针对每一次</span><span style="color:#333399">HTTP</span><span style="color:#333399">请求都会产生一个新的</span><span style="color:#333399">bean</span><span style="color:black">，同时该</span><span style="color:black">bean</span><span style="color:#333399">仅在当前</span><span style="color:#333399">HTTP&#13;
 session</span><span style="color:#333399">内有效</span><span style="color:black">.</span></p>&#13;
<br />&#13;
<p><span style="color:black"><br />&#13;
</span></p>&#13;
</blockquote>&#13;
<h2>&#13;
<h2><span style="color:#333399"><span style="color:black"><span style="color:black">Spring AOP</span><span style="color:black">编程</span></span></span></h2>&#13;
</h2>&#13;
<blockquote><span style="color:black">   <span style="font-size:14px"> </span></span><span style="font-size:14px; color:#CC0000">切面（</span><span style="font-size:14px; color:#CC0000">Aspect</span><span style="font-size:14px; color:#CC0000">）：</span><span style="font-size:14px; color:black">简单的理解就是</span><span style="font-size:14px; color:#333399">把那些与核心业务无关的代码提取出来，进行封装成一个或几个模块用来处理那些附加的功能代码</span><span style="font-size:14px; color:black">。（如日志，事务，安全验证）我们把这个模块的作用理解为一个切面，其实</span><span style="font-size:14px; color:#333399">切面</span><span style="font-size:14px; color:black">就是我们写</span><span style="font-size:14px; color:#333399">一个类</span><span style="font-size:14px; color:black">，这个类中的代码原来是在业务模块中完成的，现在单独成一个或几个类。在业务模块需要的时候才织入。</span><span style="font-size:14px"><br />&#13;
<span style="color:#CC0000">    </span><span style="color:#CC0000">连接点（</span><span style="color:#CC0000">Joinpoint</span><span style="color:#CC0000">）：</span><span style="color:black">在程序执行过程中</span><span style="color:#333399">某个特定的点</span><span style="color:black">，比如某</span><span style="color:#333399">方法调用</span><span style="color:black">的时候或者</span><span style="color:#333399">处理异常</span><span style="color:black">的时候。&#13;
 在</span><span style="color:black">Spring AOP</span><span style="color:black">中，一个连接点总是代表一个方法的执行。通过声明一个</span><span style="color:black">JoinPoint</span><span style="color:black">类型的参数可以使通知（</span><span style="color:black">Advice</span><span style="color:black">）的主体部分获得连接点信息。</span><span style="color:black"> &#13;
</span><br />&#13;
<span style="color:#CC0000">    </span>切入点（<span style="color:#CC0000">Pointcut</span><span style="color:#CC0000">）：</span><span style="color:black">本质上是一个</span><span style="color:#333399">捕获连接点</span><span style="color:black">的结构。在</span><span style="color:black">AOP</span><span style="color:black">中，可以定义一个</span><span style="color:black">pointcut</span><span style="color:black">，来捕获相关方法的调用</span><br />&#13;
<span style="color:black">     </span><span style="color:#CC0000">织入（</span><span style="color:#CC0000">Weaving</span><span style="color:#CC0000">）：</span><span style="color:black">把切面（</span><span style="color:black">aspect</span><span style="color:black">）</span><span style="color:#333399">连接到其它的应用程序类型或者对象</span><span style="color:black">上，</span><span style="color:#333399">并创建</span><span style="color:black">一个</span><span style="color:#333399">被通知（</span><span style="color:#333399">advised</span><span style="color:#333399">）的对象</span><span style="color:black">。这些可以在编译时，类加载时和运行时完成。</span><span style="color:black">Spring</span><span style="color:black">和其它纯</span><span style="color:black">Java&#13;
 AOP</span><span style="color:black">框架一样，在运行时完成织入。</span><br />&#13;
<span style="color:black">     </span><span style="color:#CC0000">通知（</span><span style="color:#CC0000">Advice</span><span style="color:#CC0000">）：</span><span style="color:black">在切面的某个特定的</span><span style="color:#333399">连接点（</span><span style="color:#333399">Joinpoint</span><span style="color:#333399">）上执行的动作</span><span style="color:black">。通知有各种类型，其中包括“</span><span style="color:#333399">around</span><span style="color:black">”、“</span><span style="color:#333399">before</span><span style="color:black">”和“</span><span style="color:#333399">after</span><span style="color:black">”等通知。通知的类型将在后面部分进行讨论。许多</span><span style="color:black">AOP</span><span style="color:black">框架，包括</span><span style="color:black">Spring</span><span style="color:black">，都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</span><br />&#13;
<span style="color:black">通知的类型：</span><br />&#13;
<span style="color:black">    </span><span style="color:#CC0000">前置通知（</span><span style="color:#CC0000">Before advice</span><span style="color:#CC0000">）</span><span style="color:black">：在某</span><span style="color:#333399">连接点（</span><span style="color:#333399">join&#13;
 point</span><span style="color:#333399">）之前</span><span style="color:black">执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</span><br />&#13;
<span style="color:black">    </span><span style="color:#CC0000">返回后通知（</span><span style="color:#CC0000">After returning advice</span><span style="color:#CC0000">）</span><span style="color:black">：在某</span><span style="color:#333399">连接点（</span><span style="color:#333399">join&#13;
 point</span><span style="color:#333399">）正常完成后</span><span style="color:black">执行的通知：例如，一个方法没有抛出任何异常，正常返回。</span><br />&#13;
<span style="color:black">    </span><span style="color:#CC0000">抛出异常后通知（</span><span style="color:#CC0000">After throwing advice</span><span style="color:#CC0000">）</span><span style="color:black">：在</span><span style="color:#333399">方法抛出异常退出时</span><span style="color:black">执行的通知。</span><br />&#13;
<span style="color:black">    </span><span style="color:#CC0000">后置通知（</span><span style="color:#CC0000">After&#13;
</span><span style="color:#CC0000">（</span><span style="color:#CC0000">finally</span><span style="color:#CC0000">）</span><span style="color:#CC0000">advice</span><span style="color:#CC0000">）</span><span style="color:black">：当某</span><span style="color:#333399">连接点退出的时候</span><span style="color:black">执行的通知（不论是正常返回还是异常退出）。</span><br />&#13;
</span>&#13;
<p><span style="font-size:14px"><span style="color:black">     </span><span style="color:#CC0000">环绕通知（</span><span style="color:#CC0000">Around Advice</span><span style="color:#CC0000">）</span><span style="color:black">：</span><span style="color:#333399">包围一个连接点</span><span style="color:black">（</span><span style="color:black">join&#13;
 point</span><span style="color:black">）的通知，如方法调用。这是</span><span style="color:#333399">最强大的一种通知类型</span><span style="color:black">。 环绕通知可以</span><span style="color:#333399">在方法调用前后完成自定义的行为</span><span style="color:black">。它也</span><u><span style="color:black">会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行</span></u><span style="color:black">。</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black">下面演示代码：</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black">纯Java方式写AOP(拦截技术)</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_7_8272726" name="code" class="html">package cn.hncu.spring4x.aop;

import java.lang.reflect.Method;

import org.aopalliance.aop.Advice;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.junit.Test;
import org.springframework.aop.Advisor;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.aop.MethodBeforeAdvice;
import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.framework.ProxyFactoryBean;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.aop.support.JdkRegexpMethodPointcut;

import cn.hncu.spring4x.domain.Person;

public class AopDemo {
	@Test//纯Java的方式实现切面(拦截)技术
	public void demo1(){
		Person p=new Person();
		ProxyFactory factory=new ProxyFactory(); //该类的功能没有ProxyFactoryBean强
		factory.setTarget(p);//1 给代理工厂一个原型对象
		//切面 = 切点 + 通知
		//切点
		JdkRegexpMethodPointcut pointcut=new JdkRegexpMethodPointcut();
		pointcut.setPattern("cn.hncu.spring4x.domain.Person.run");
		//		pointcut.setPattern(".*run.*");ProxyFactory对setPattern无效
		Advice advice=new MethodInterceptor() {

			@Override
			public Object invoke(MethodInvocation invocation) throws Throwable {
				System.out.println("前面拦截");
				Object obj=invocation.proceed();
				System.out.println("后面拦截");
				return obj;
			}
		};
		//切面 = 切点 + 通知
		Advisor advisor=new DefaultPointcutAdvisor(pointcut, advice);

		factory.addAdvice(advice);

		Person p2=(Person) factory.getProxy();
//		p2.run();
//		p2.run(5);
		p2.say();
	}
	@Test//纯Java的方式实现切面(拦截)技术
	public void demo2(){
		ProxyFactoryBean factoryBean=new ProxyFactoryBean();
		factoryBean.setTarget(new Person());
		//切面 = 切点 + 通知
		//切点
		JdkRegexpMethodPointcut pointcut=new JdkRegexpMethodPointcut();
		pointcut.setPattern(".*run.*");

		//通知  前切面---不需要放行，原方法也能执行
		Advice beforeAdvice=new MethodBeforeAdvice() {
			@Override
			public void before(Method method, Object[] args, Object target)
					throws Throwable {
				System.out.println("beforeAdvice拦截");//正则表达式有效
			}
		};
		Advice afterReturning=new AfterReturningAdvice() {
			@Override
			public void afterReturning(Object returnValue, Method method,
					Object[] args, Object target) throws Throwable {
				System.out.println("afterReturning");
			}
		};

		Advice aroundAdvice=new MethodInterceptor() {

			public Object invoke(MethodInvocation invocation) throws Throwable {
				System.out.println("前面拦截");
				Object obj=invocation.proceed();
				System.out.println("后面拦截");
				return obj;
			}
		};
		Advisor advisor1=new DefaultPointcutAdvisor(pointcut, beforeAdvice);
		Advisor advisor2=new DefaultPointcutAdvisor(pointcut, afterReturning);
		Advisor advisor3=new DefaultPointcutAdvisor(pointcut, aroundAdvice);
		factoryBean.addAdvisors(advisor1,advisor2,advisor3);
		//2 给代理工厂一个切面 ---注意,添加的顺序的拦截动作执行的顺序是有关系的!!!
		//先加的切面，如果拦前面，就拦在最前面，如果拦后面，就拦在最后面.
		Person p = (Person) factoryBean.getObject(); //3 从代理工厂中获取一个代理后的对象
		//p.run();
		//p.run(0);
		p.say();
	}

}
</pre><br />&#13;
下面演示5种理由配置文件AOP&#13;
<p><span style="font-size:14px"><span style="color:black"><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black">通知：AroundAdvice.java</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_8_5557511" name="code" class="html">package cn.hncu.spring4x.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class AroundAdvice implements MethodInterceptor {

	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("前面拦拦....");
		Object resObj = invocation.proceed();//放行
		System.out.println("后面拦拦.....");
		return resObj;
	}

}
</pre><br />&#13;
<br />&#13;
&#13;
<p><span style="font-size:14px"><span style="color:black"><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black">测试代码，<br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_9_334041" name="code" class="html">package cn.hncu.spring4x.aop;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AopXmlDemo {
	@Test//采用配置文件的方式使用切面拦截
	public void demo1(){
		ApplicationContext act=new ClassPathXmlApplicationContext("cn/hncu/spring4x/aop/1.xml");
		Cat cat=act.getBean("catProxide",Cat.class);//要从catProxide返回
		cat.run();
		cat.say();
		cat.run(6);
	}
	@Test//把切点和通知配置成 切面的内部bean
	public void demo2(){
		ApplicationContext ctx = new ClassPathXmlApplicationContext("cn/hncu/spring4x/aop/2.xml");
		Cat cat = ctx.getBean("catProxide",Cat.class);
		cat.run();
		cat.say();
		cat.run(7);
	}
	@Test//直接在切面bean中配置“切点的正则表达式”，省去“切点bean”的配置
	public void demo3(){
		ApplicationContext ctx = new ClassPathXmlApplicationContext("cn/hncu/spring4x/aop/3.xml");
		Cat cat = ctx.getBean("catProxide",Cat.class);
		cat.run();
		cat.say();
		cat.run(7);
	}
	@Test//自动代理
	public void demo4(){
		ApplicationContext ctx = new ClassPathXmlApplicationContext("cn/hncu/spring4x/aop/4.xml");
		Cat cat = ctx.getBean(Cat.class);
		cat.run();
		cat.say();
		cat.run(7);
	}
	@Test//自己写的自动代理
	public void demo5(){
		ApplicationContext ctx = new ClassPathXmlApplicationContext("cn/hncu/spring4x/aop/5.xml");
		Cat cat = ctx.getBean("cat",Cat.class);
//		cat.run();
//		cat.say();
//		cat.run(7);
	}
	
}
</pre>1.xml<pre code_snippet_id="1858913" snippet_file_name="blog_20160901_10_9603692" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt;
	
	&lt;bean id="cat" class="cn.hncu.spring4x.aop.Cat"&gt;&lt;/bean&gt;
	&lt;!-- 切点 --&gt;
	&lt;bean id="pointcut" class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
		&lt;property name="pattern" value=".*run.*"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- 通知 ,要自己写--&gt;
	&lt;bean id="advice" class="cn.hncu.spring4x.aop.AroundAdvice"&gt;&lt;/bean&gt;
	
	&lt;!-- 切面=切点+通知 --&gt;
	&lt;bean id="advisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
		&lt;property name="advice" ref="advice"&gt;&lt;/property&gt;
		&lt;property name="pointcut" ref="pointcut"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	
	&lt;bean id="catProxide" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
		&lt;property name="target" ref="cat"&gt;&lt;/property&gt;
		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;advisor&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
2.xml&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_11_268784" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt;
	
	&lt;bean id="cat" class="cn.hncu.spring4x.aop.Cat"&gt;&lt;/bean&gt;
	
	&lt;!-- 切面=切点+通知 (把切点和通知写成内部bean)--&gt;
	&lt;bean id="advisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
		&lt;property name="advice"&gt;
			&lt;bean class="cn.hncu.spring4x.aop.AroundAdvice"&gt;&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="pointcut"&gt;
			&lt;bean class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
			 &lt;property name="patterns"&gt;
			 	&lt;list&gt;
			 		&lt;value&gt;.*run.*&lt;/value&gt;
			 		&lt;value&gt;.*say.*&lt;/value&gt;
			 	&lt;/list&gt;
			 &lt;/property&gt;
			 
			&lt;/bean&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	
	&lt;bean id="catProxide" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
		&lt;property name="target" ref="cat"&gt;&lt;/property&gt;
		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;advisor&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
<br />&#13;
&#13;
<p><span style="font-size:14px"><span style="color:black">3.xml</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_12_4173262" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt;

	&lt;bean id="cat" class="cn.hncu.spring4x.aop.Cat"&gt;&lt;/bean&gt;

	&lt;!--//直接在切面bean中配置“切点的正则表达式”，省去“切点bean”的配置 用到这个类 org.springframework.aop.support.RegexpMethodPointcutAdvisor --&gt;
	&lt;bean id="advisor"
		class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
		&lt;property name="advice"&gt;
			&lt;bean class="cn.hncu.spring4x.aop.AroundAdvice"&gt;&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="patterns"&gt;
			&lt;list&gt;
				&lt;value&gt;.*run.*&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

	&lt;bean id="catProxide" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
		&lt;property name="target" ref="cat"&gt;&lt;/property&gt;
		&lt;property name="interceptorNames"&gt;
			&lt;list&gt;
				&lt;value&gt;advisor&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
<br />&#13;
&#13;
<p><span style="font-size:14px"><span style="color:black">4.xml</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_13_8982810" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt;

	&lt;bean id="cat" class="cn.hncu.spring4x.aop.Cat"&gt;&lt;/bean&gt;

	&lt;!--//直接在切面bean中配置“切点的正则表达式”，省去“切点bean”的配置 用到这个类 org.springframework.aop.support.RegexpMethodPointcutAdvisor --&gt;
	&lt;bean id="advisor"
		class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
		&lt;property name="advice"&gt;
			&lt;bean class="cn.hncu.spring4x.aop.AroundAdvice"&gt;&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="patterns"&gt;
			&lt;list&gt;
				&lt;value&gt;.*run.*&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- 自动代理 --&gt;
	&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
<br />&#13;
&#13;
<p><span style="font-size:14px"><span style="color:black">5.xml<br />&#13;
<br />&#13;
</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_14_9124514" name="code" class="html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt;

	&lt;bean id="cat" class="cn.hncu.spring4x.aop.Cat"&gt;&lt;/bean&gt;

	&lt;!--//直接在切面bean中配置“切点的正则表达式”，省去“切点bean”的配置 用到这个类 org.springframework.aop.support.RegexpMethodPointcutAdvisor --&gt;
	&lt;bean id="advisor"
		class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
		&lt;property name="advice"&gt;
			&lt;bean class="cn.hncu.spring4x.aop.AroundAdvice"&gt;&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="patterns"&gt;
			&lt;list&gt;
				&lt;value&gt;.*run.*&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- 自动代理 --&gt;
	
	&lt;bean class="cn.hncu.spring4x.aop.MyAutoProxy"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</pre><br />&#13;
第五种方法，模拟自动代理&#13;
<p><span style="font-size:14px"><span style="color:black">MyAutoProxy.java</span></span></p>&#13;
<p><span style="font-size:14px"><span style="color:black"></span></span></p><pre code_snippet_id="1858913" snippet_file_name="blog_20160901_15_9266218" name="code" class="html">package cn.hncu.spring4x.aop;

import org.springframework.aop.Advisor;
import org.springframework.aop.framework.ProxyFactoryBean;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class MyAutoProxy implements BeanPostProcessor,ApplicationContextAware{
	private ApplicationContext applicationContext;
	@Override
	public void setApplicationContext(ApplicationContext applicationContext)
			throws BeansException {
		this.applicationContext=applicationContext;//保证是同一个容器

	}
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println(bean+"postProcessBeforeInitialization");
		return bean; //直接放行（一定要）
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println(bean+"postProcessAfterInitialization");
		ProxyFactoryBean factoryBean=new ProxyFactoryBean();
		factoryBean.setTarget(bean);
		Advisor advisor=applicationContext.getBean("advisor", Advisor.class);
		factoryBean.addAdvisor(advisor);
		return factoryBean.getObject();
	}


	
}
</pre><br />&#13;
<br />&#13;
&#13;
</blockquote>&#13;
<h2>&#13;
</h2><p><br />&#13;
</p>&#13;
<p><span style="color:#333399"><span style="color:black"><br />&#13;
</span></span></p>&#13;
<p><span style="color:#333399"><span style="color:black"><br />&#13;
</span></span></p>&#13;
&#13;
<blockquote>&#13;
<p><span style="color:#333399"></span></p>&#13;
<p><span style="color:#333399"><span style="color:black"></span><br />&#13;
</span></p>&#13;
<br />&#13;
</blockquote>&#13;
<p><br />&#13;
</p>&#13;
<p><span style="color:black"></span><br />&#13;
</p>&#13;
<h2></h2>&#13;
   &#13;
