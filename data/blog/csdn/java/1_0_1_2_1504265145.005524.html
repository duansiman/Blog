
                
<p style="text-align:center"><span style="font-size:24px">要想正确理解设计模式，首先必须明确它是为了解决什么问题而提出来的。</span></p>&#13;
<p style="text-align:center"><span style="font-size:24px">设计模式学习笔记</span></p>&#13;
<p style="text-align:right"><span style="font-size:24px">——Shulin</span></p>&#13;
<p style="text-align:right"><span style="font-size:24px">转载请注明出处：<a target="_blank" href="http://blog.csdn.net/zhshulin">http://blog.csdn.net/zhshulin</a></span></p>&#13;
<h1>1、概念</h1>&#13;
<p/>&#13;
<p>        装饰模式又名<span style="background:rgb(255,255,0)">包装<span style="font-family:Times New Roman">(Wrapper)</span><span style="font-family:宋体">模式</span></span>。装饰模式以对客户端透明的方式扩展对象的功能，<span style="color:rgb(255,0,0)">是继承关系的一个替代方案</span>。</p>&#13;
<p>        但是<span style="color:rgb(0,0,255)">纯粹的装饰模式很难找到</span>，大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。<span style="color:rgb(0,0,255)">半透明的装饰模式是介于装饰模式和适配器模式之间的</span>。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。</p>&#13;
<p><span style="color:rgb(0,0,255)">大多数的装饰模式实际上是半透明的装饰模式，</span>这样的装饰模式也称做半装饰、半适配器模式。</p>&#13;
<br/>&#13;
<h1>2、针对的问题</h1>&#13;
<p/>&#13;
<p><span style="color:rgb(0,0,255)">        动态地给一个对象添加一些额外的职责。</span>就增加功能来说，<span style="font-family:Times New Roman">Decorator</span><span style="font-family:宋体">模式相比生成子类更为灵活。</span>不改变接口的前提下，增强所考虑的类的性能。</p>&#13;
<p>何时使用：</p>&#13;
<p>    1）<span style="font-family:宋体">需要扩展一个类的功能，或给一个类增加附加责任。</span></p>&#13;
<p>    2）<span style="font-family:宋体">需要动态的给一个对象增加功能，这些功能可以再动态地撤销。</span></p>&#13;
<p>    3）<span style="font-family:宋体">需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得</span>    不现实。</p>&#13;
<br/>&#13;
<h1>3、角色组成</h1>&#13;
<p/>&#13;
<p><span style="background:rgb(255,255,0)">    l </span><span style="background:rgb(255,255,0)">抽象构件</span>(Component)<span style="font-family:宋体">角色：给出一个抽象接口，以规范准备接收附加责任的对象。</span></p>&#13;
<p><span style="background:rgb(255,255,0)">    l </span><span style="background:rgb(255,255,0)">具体构件</span>(ConcreteComponent)<span style="font-family:宋体">角色：定义一个将要接收附加责任的类</span></p>&#13;
<p><span style="background:rgb(255,255,0)">    l </span><span style="background:rgb(255,255,0)">装饰角色</span>(Decorator)：持有一个构件<span style="font-family:Times New Roman">(Component)</span><span style="font-family:宋体">对象的实例，并定义一个与抽象构件接口一致的接口</span></p>&#13;
<p><span style="background:rgb(255,255,0)">    l </span><span style="background:rgb(255,255,0)">具体装饰角色</span>(ConcreteDecorator)：负责给构件对象“贴上”附加的责任</p>&#13;
<div style="text-align:center"><img src="http://img.blog.csdn.net/20140818201029976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/></div>&#13;
<h1>4、举例说明</h1>&#13;
<p><br/>&#13;
</p>&#13;
<p/>&#13;
<p>        咖啡是一种饮料，咖啡的本质是咖啡豆<span style="font-family:Times New Roman">+</span><span style="font-family:宋体">水磨出来的。咖啡店现在要卖各种口味的咖啡，如果不使用装饰模式，那么在销售系统中，各种不一样的咖啡都要产生一个类，如果有</span><span style="font-family:Times New Roman">4</span><span style="font-family:宋体">中咖啡豆，</span><span style="font-family:Times New Roman">5</span><span style="font-family:宋体">种口味，那么将要产生至少</span><span style="font-family:Times New Roman">20</span><span style="font-family:宋体">个类（不包括混合口味），非常麻烦。使用了装饰模式，只需要</span><span style="font-family:Times New Roman">11</span><span style="font-family:宋体">个类即可生产任意口味咖啡（包括混合口味）。</span></p>&#13;
<br/>&#13;
<h2>4.1、类图</h2>&#13;
<p><img src="http://img.blog.csdn.net/20140818200845140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/><br/>&#13;
</p>&#13;
<p><br/>&#13;
</p>&#13;
<h2>4.2、源码</h2>&#13;
<p><span style="background-color:rgb(192,192,192)">Beverage</span><span style="background-color:rgb(192,192,192)">饮料接口</span></p>&#13;
<p/><pre code_snippet_id="453344" snippet_file_name="blog_20140818_1_8607627" name="code" class="java">/**
 * 饮料接口
 * @author Administrator
 *
 */
public interface Beverage {
	//返回商品描述
	public String getDescription();
	//返回价格
	public double getPrice();
}</pre><br/>&#13;
&#13;
<p><span style="background:rgb(192,192,192)">CoffeeBean1</span>——具体被装饰的对象类1</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_2_5129044" name="code" class="java">public class CoffeeBean1 implements Beverage {
	private String description = "选了第一种咖啡豆";
	@Override
	public String getDescription() {
		return description;
	}
	@Override
	public double getPrice() {
		return 50;
	}

}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">CoffeeBean2</span>——具体被装饰的对象类2</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_3_461981" name="code" class="java">public class CoffeeBean2 implements Beverage {
	private String description = "第二种咖啡豆！";
	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public double getPrice() {
		return 100;
	}

}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">Decorator</span>——装饰类</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_4_2414611" name="code" class="java">public class Decorator implements Beverage {
	private String description = "我只是装饰器，不知道具体的描述";
	@Override
	public String getDescription() {
		return description;
	}
	@Override
	public double getPrice() {
		return 0;		//价格由子类来决定
	}

}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">Milk</span>——具体装饰类，给咖啡加入牛奶</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_5_6634733" name="code" class="java">public class Milk extends Decorator{
	private String description = "加了牛奶！";
	private Beverage beverage = null;
	public Milk(Beverage beverage){
		this.beverage = beverage;
	}
	public String getDescription(){
		return beverage.getDescription()+"\n"+description;
	}
	public double getPrice(){
		return beverage.getPrice()+20;	//20表示牛奶的价格
	}
}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">Mocha</span>——给咖啡加入摩卡</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_6_3952538" name="code" class="java">public class Mocha extends Decorator {
	private String description = "加了摩卡！";
	private Beverage beverage = null;
	public Mocha(Beverage beverage){
		this.beverage = beverage;
	}
	public String getDescription(){
		return beverage.getDescription()+"\n"+description;
	}
	public double getPrice(){
		return beverage.getPrice()+49;	//30表示摩卡的价格
	}
}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">Soy</span>——给咖啡加入豆浆</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_7_1237323" name="code" class="java">public class Soy extends Decorator {
	private String description = "加了豆浆！";
	private Beverage beverage = null;
	public Soy(Beverage beverage){
		this.beverage = beverage;
	}
	public String getDescription(){
		return beverage.getDescription()+"\n"+description;
	}
	public double getPrice(){
		return beverage.getPrice()+30;	//30表示豆浆的价格
	}
}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">测试类：</span></p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_8_9950566" name="code" class="java">public class Test {

	public static void main(String[] args) {
		Beverage beverage = new CoffeeBean1();	//选择了第一种咖啡豆磨制的咖啡
		beverage = new Mocha(beverage);		//为咖啡加了摩卡
		beverage = new Milk(beverage);
		System.out.println(beverage.getDescription()+"\n加了摩卡和牛奶的咖啡价格："+beverage.getPrice());
		
	}
}</pre><br/>&#13;
<p><span style="background:rgb(192,192,192)">测试结果：</span></p>&#13;
<div style="text-align:center"><img src="http://img.blog.csdn.net/20140818201231156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/></div>&#13;
<p><br/>&#13;
</p>&#13;
<h1>5、装饰模式和适配器模式的关系</h1>&#13;
<p/>&#13;
<p><span style="background:rgb(255,255,0)">    <span style="font-size:14px"> </span><span style="font-size:12px">   装饰模式和适配器模式都是“包装模式<span style="font-family:'Times New Roman'">(Wrapper Pattern)</span><span style="font-family:宋体">”，</span></span></span><span style="font-size:12px">它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。</span></p>&#13;
<p><span style="font-size:12px"> </span></p>&#13;
<p><span style="font-size:12px">　　理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。</span></p>&#13;
<p><span style="font-size:12px"> </span></p>&#13;
<p><span style="font-size:12px">　　装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。</span></p>&#13;
<br/>&#13;
<p style="text-align:center"><img src="http://img.blog.csdn.net/20140818201400203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/><br/>&#13;
</p>&#13;
<p/>&#13;
<p class="p0" style="text-indent:21.0000pt; margin-bottom:0pt; margin-top:0pt; text-align:justify">&#13;
<span style="font-size:10.5pt; font-family:'ms shell dlg'"> 在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。</span><span style="font-size:10.5pt; font-family:'ms shell dlg'"/></p>&#13;
<p class="p0" style="margin-bottom:0pt; margin-top:0pt"><span style="font-size:10.5pt; font-family:'ms shell dlg'">显然，</span><span style="font-size:10.5pt; font-family:'ms shell dlg'">半透明的装饰模式实际上就是处于适配器模式与装饰模式之间的灰色地带</span><span style="font-size:10.5pt; font-family:'ms shell dlg'">。如果将装饰模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰模式倒可以成为这种合并后的“包装模式”的代表。</span></p>&#13;
<br/>&#13;
<h1>6、透明性要求</h1>&#13;
<p/>&#13;
<p>        装饰模式对客户端的透明性要求程序不要声明一个<span style="font-family:Times New Roman">ConcreteComponent</span><span style="font-family:宋体">类型的变量，而应当声明一个</span><span style="font-family:Times New Roman">Component</span><span style="font-family:宋体">类型的变量。</span></p>&#13;
<p>　　用上面的例子来说，必须永远把所有的饮料当成饮料来对待，而如果把饮料变成的加摩卡的饮料当成摩卡，而不是饮料，这是不应当发生的。下面的做法是对的：</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_9_59251" name="code" class="java">Beverage beverage = new CoffeeBean1();
Beverage mochaBeverage = new Mocha(beverage);</pre><br/>&#13;
<p>而下面的做法是不对的：</p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_10_1488493" name="code" class="java">Beverage beverage = new CoffeeBean1();
Mocha mochaBeverage = new Mocha(beverage);</pre><br/>&#13;
<h1>7、半透明模式</h1>&#13;
<p/>&#13;
<p>        然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统（<span style="color:rgb(51,102,255)">如下图</span>）里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的<span style="font-family:Times New Roman">fly()</span><span style="font-family:宋体">方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的</span><span style="font-family:Times New Roman">swim()</span><span style="font-family:宋体">方法。</span></p>&#13;
<div style="text-align:center"><img src="http://img.blog.csdn.net/20140818201628093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/></div>&#13;
<p/>&#13;
<p>        这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明<span style="font-family:Times New Roman">ConcreteDecorator</span><span style="font-family:宋体">类型的变量，从而可以调用</span><span style="font-family:Times New Roman">ConcreteDecorator</span><span style="font-family:宋体">类中才有的方法：</span></p>&#13;
<pre code_snippet_id="453344" snippet_file_name="blog_20140818_11_2676973" name="code" class="java">TheGreatestSage sage = new Monkey();
Bird bird = new Bird(sage);
bird.fly();</pre><br/>&#13;
<p>        半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。</p>&#13;
<br/>&#13;
<h1>8、优点</h1>&#13;
<p/>&#13;
<p>        （<span style="font-family:Times New Roman">1</span><span style="font-family:宋体">）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除          掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</span></p>&#13;
<p>　　（<span style="font-family:Times New Roman">2</span><span style="font-family:宋体">）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</span></p>&#13;
<h1>9、缺点</h1>&#13;
<p/>&#13;
<p>        使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p>&#13;
<br/>&#13;
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0"/>&#13;
            