

<p><span style="font-size:14px">上一篇说的是一个简单的应用，说明JNI是怎么工作的，这一篇主要来说一下，那个本地方法sayHello的参数的说明，以及其中方法的使用</span></p>&#13;
<p><span style="font-size:14px">首先来看一下C++中的sayHello方法的实现:</span></p>&#13;
<p><span style="font-size:14px"></span></p><pre code_snippet_id="125035" snippet_file_name="blog_20131223_1_2203133" name="code" class="cpp">JNIEXPORT void JNICALL Java_com_jni_demo_JNIDemo_sayHello (JNIEnv * env, jobject obj)
{
cout&lt;&lt;"Hello World"&lt;&lt;endl;
}</pre>&#13;
<p><span style="font-size:14px">对于这个方法参数中的JNIEnv* env参数的解释:</span></p>&#13;
<p><span style="font-size:14px">JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Jaa类中俄对象，调用Java对象的方法，获取Java对象中的属性等等。JNIEnv的指针会被JNI传入到本地方法的实现函数中来对Java端的代码进行操作。</span></p>&#13;
<p><span style="font-size:14px">JNIEnv类中有很多函数可以用：</span></p>&#13;
<p><span style="font-size:14px">NewObject:创建Java类中的对象</span></p>&#13;
<p><span style="font-size:14px">NewString:创建Java类中的String对象</span></p>&#13;
<p><span style="font-size:14px">New&lt;Type&gt;Array:创建类型为Type的数组对象</span></p>&#13;
<p><span style="font-size:14px">Get&lt;Type&gt;Field:获取类型为Type的字段</span></p>&#13;
<p><span style="font-size:14px">Set&lt;Type&gt;Field:设置类型为Type的字段的值</span></p>&#13;
<p><span style="font-size:14px">GetStatic&lt;Type&gt;Field:获取类型为Type的static的字段</span></p>&#13;
<p><span style="font-size:14px">SetStatic&lt;Type&gt;Field:设置类型为Type的static的字段的值</span></p>&#13;
<p><span style="font-size:14px">Call&lt;Type&gt;Method:调用返回类型为Type的方法</span></p>&#13;
<p><span style="font-size:14px">CallStatic&lt;Type&gt;Method:调用返回值类型为Type的static方法</span></p>&#13;
<p><span style="font-size:14px">等许多的函数，具体的可以查看jni.h文件中的函数名称。</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">参数:jobject obj的解释:</span></p>&#13;
<p><span style="font-size:14px">如果native方法不是static的话，这个obj就代表这个native方法的类实例</span></p>&#13;
<p><span style="font-size:14px">如果native方法是static的话，这个obj就代表这个native方法的类的class对象实例(static方法不需要类实例的，所以就代表这个类的class对象)</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">下面来看一下Java和C++中的基本类型的映射关系:</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131221140115156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">具体的说明可以查看jni.h文件。</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">为了能够在C/C++中使用Java类，jni.h头文件中专门定义了jclass类型来表示Java中的Class类</span></p>&#13;
<p><span style="font-size:14px">JNIEnv类中有如下几个简单的函数可以取得jclass:</span></p>&#13;
<p><span style="font-size:14px">jclass FindClass(const char* clsName):通过类的名称(类的全名，这时候包名不是用.号，而是用/来区分的)来获取jclass</span></p>&#13;
<p><span style="font-size:14px">如: jclass str = env-&gt;FindClass("java/lang/String");获取Java中的String对象的class对象。</span></p>&#13;
<p><span style="font-size:14px">jclass GetObjectClass(jobject obj):通过对象实例来获取jclass，相当于java中的getClass方法</span></p>&#13;
<p><span style="font-size:14px">jclass GetSuperClass(jclass obj):通过jclass可以获取其父类的jclass对象</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">在C/C++本地代码中访问Java端的代码，一个常见的应用就是获取类的属性和调用类的方法，为了在C/C++中表示属性和方法，JNI在jni.h头文件中定义了jfieldId,jmethodID类型来分别代表Java端的属性和方法</span></p>&#13;
<p><span style="font-size:14px">我们在访问，或者设置Java属性的时候，首先就要先在本地代码取得代表该Java属性的jfieldID,然后才能在本地代码中进行Java属性操作，同样的，我们需要呼叫Java端的方法时，也是需要取得代表该方法的jmethodID才能进行Java方法调用</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">使用JNIEnv的：</span></p>&#13;
<p><span style="font-size:14px">GetFieldID/GetMethodID</span></p>&#13;
<p><span style="font-size:14px">GetStaticFieldID/GetStaticMethodID</span></p>&#13;
<p><span style="font-size:14px">来取得相应的jfieldID和jmethodID</span></p>&#13;
<p><span style="font-size:14px">下面来具体看一下这几个方法：</span></p>&#13;
<p><span style="font-size:14px">GetFieldID(jclass clazz,const char* name,const char* sign)</span></p>&#13;
<p><span style="font-size:14px">方法的参数说明:</span></p>&#13;
<p><span style="font-size:14px">clazz:这个简单就是这个方法依赖的类对象的class对象</span></p>&#13;
<p><span style="font-size:14px">name:这个是这个字段的名称</span></p>&#13;
<p><span style="font-size:14px">sign:这个是这个字段的签名(我们知道每个变量，每个方法都是有签名的)</span></p>&#13;
<p><span style="font-size:14px">怎么查看类中的字段和方法的签名:</span></p>&#13;
<p><span style="font-size:14px">使用javap命令:</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131221142503906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">GetMethodID也能够取得构造函数的jmethodID,创建一个Java对象时可以调用指定的构造方法，这个将在后面向大家介绍:</span></p>&#13;
<p><span style="font-size:14px">如:env-&gt;GetMethodID(data_Class,"&lt;init&gt;","()V");</span></p>&#13;
<p><span style="font-size:14px">下面看一下签名的格式:</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131221142524640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">下面来看一下例子:</span></p>&#13;
<p><span style="font-size:14px">这里没有上代码了：真正演示的时候等下一篇内容，这一篇只是说一下方法的使用:</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131221142910828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131221142742906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">下一篇我们将来说一下这些方法到底是怎么用的。</span></p>&#13;
<p><br />&#13;
</p>&#13;
   &#13;
