
                <p><br/>&#13;
</p>&#13;
<h1>前言</h1>&#13;
<div><br/>&#13;
</div>&#13;
<div>前两篇文章介绍了Spring3、Hibernate4、SpringMVC的整合以及Ext界面MVC的实现，这次介绍的内容是处理Ext的分页和前后台的数据传输。</div>&#13;
<div>目前Ext大部分组件使用的都是JSON数据格式（如果有不知道JSON数据格式的同学可以去网上找点资料看下，在这里就不赘述了）。包括表格控件、树控件、报表控件以及表单空间等等，所以说对于整合Ext来说如何向前台空间传输JSON数据很关键。</div>&#13;
<div>Ext框架中表格控件用的的最多的，也是用的最广泛的。表格控件也是非常强大的，可扩展性也非常强。使用表格自然就涉及到了分页的问题，如何将代码降低到最小、更方便、更快捷的实现分页也自然是非常重要的。说了这么多下面就开始介绍下如何使用SpingMVC进行数据传输！</div>&#13;
<div><br/>&#13;
</div>&#13;
<h1>前台界面</h1>&#13;
<div><br/>&#13;
</div>&#13;
<div>下面大家看到这一张图片，这张图片的内容是SpringMVC的url映射详细情况，url的映射是在后台获取的，通过对url映射数据的组织发送到前台让表格空间展示出来：</div>&#13;
<div style="text-align:center"><img src="http://img.my.csdn.net/uploads/201210/06/1349499358_2605.jpg" width="800" height="400" alt=""/></div>&#13;
<div style="text-align:left">下面是这个界面的具体实现，首先看到前台界面的代码：</div>&#13;
<div style="text-align:left"><pre name="code" class="javascript">Ext.define('Fes.system.spring.URLMapping', {&#13;
			extend : 'Ext.grid.Panel',&#13;
			alias : 'widget.rolelist',&#13;
			iconCls : 'icon-grid-list',&#13;
			rowLines : true,&#13;
			columnLines : true,&#13;
			viewConfig : {&#13;
				loadingText : '正在加载角色列表'&#13;
			},&#13;
			columns : [{&#13;
					xtype : 'rownumberer'&#13;
				}, {&#13;
					text : '映射',&#13;
					columns : [{text : '路径',width : 200,sortable : true,dataIndex : 'url'},&#13;
					{text : '需求',width : 100,sortable : true,dataIndex : 'consumes'}, &#13;
					{text : '自定义',width : 100,sortable : true,dataIndex : 'custom'},&#13;
					{text : '头信息',width : 100,sortable : true,dataIndex : 'headers'}, &#13;
					{text : '参数值',width : 100,sortable : true,dataIndex : 'params'}, &#13;
					{text : '请求方法',width : 100,sortable : true,dataIndex : 'methods'},&#13;
					{text : '处理',width : 100,sortable : true,dataIndex : 'produces'}]&#13;
				}, &#13;
				{text : '方法',width : 200,sortable : true,dataIndex : 'methodName'},&#13;
				{text : '返回值',width : 350,sortable : true,dataIndex : 'returnType'},&#13;
				{text : '注解',width : 300,sortable : true,dataIndex : 'annotationName'},&#13;
				{text : '参数',width : 300,sortable : true,dataIndex : 'parameters'},&#13;
				{text : '类',width : 100,sortable : true,dataIndex : 'className',width : 500}&#13;
			],&#13;
			initComponent : function() {&#13;
				var groupingFeature = Ext.create('Ext.grid.feature.Grouping',{&#13;
				        groupHeaderTpl: '{name}({rows.length})',&#13;
				        hideGroupedHeader: true,&#13;
				        groupByText:'对该列进行分组',&#13;
				        showGroupsText : '是否分组'&#13;
				    });&#13;
				this.features = [groupingFeature];&#13;
				this.createStore();&#13;
				this.callParent();&#13;
			},&#13;
&#13;
			createStore : function() {&#13;
				var me = this;&#13;
				Ext.define('Fes.system.spring.URLMappingModel', {&#13;
							extend : 'Ext.data.Model',&#13;
							fields : [{name : 'url',type : 'string'}, &#13;
									  {name : 'className',type : 'string'},&#13;
									  {name : 'methodName'}, &#13;
									  {name : 'returnType'},&#13;
									  {name : 'annotationName'}, &#13;
									  {name : 'consumes'},&#13;
									  {name : 'custom'},&#13;
									  {name : 'headers'}, &#13;
									  {name : 'params'},&#13;
									  {name : 'methods'}, &#13;
									  {name : 'produces'},&#13;
									  {name : 'parameters'}&#13;
									 ]&#13;
						});&#13;
				me.store = Ext.create('Ext.data.Store', {&#13;
							model : 'Fes.system.spring.URLMappingModel',&#13;
							groupField: 'className',&#13;
							autoLoad : true,&#13;
							proxy : {&#13;
								type : 'ajax',&#13;
								url : 'spring/url-mapping',&#13;
								reader : {&#13;
									type : 'json',&#13;
									root : 'root'&#13;
								}&#13;
							}&#13;
						});&#13;
			}&#13;
&#13;
		});</pre>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
这个就是SpringMVC URL映射界面的代码实现，这段代码很简单就是定义了一个表格，并对数据做了简单的排序。给表格配置了一个数据源，访问的路径是"spring/url-mapping"。</div>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<h1>后台实现JSON数据格式传输</h1>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<div style="text-align:left">接下来我们就可以看看后台Java代码的实现：</div>&#13;
<div style="text-align:left"><pre name="code" class="java">package com.avicit.fes.system.spring.controller;&#13;
&#13;
import java.util.ArrayList;&#13;
import java.util.Iterator;&#13;
import java.util.List;&#13;
import java.util.Map;&#13;
&#13;
import org.springframework.core.MethodParameter;&#13;
import org.springframework.stereotype.Controller;&#13;
import org.springframework.web.bind.annotation.RequestMapping;&#13;
import org.springframework.web.bind.annotation.ResponseBody;&#13;
import org.springframework.web.method.HandlerMethod;&#13;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;&#13;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;&#13;
&#13;
import com.avicit.fes.system.spring.vo.URLMapping;&#13;
import com.avicit.framework.context.spring.SpringContextBeanFactory;&#13;
import com.avicit.framework.util.ResponseUtils;&#13;
&#13;
/***&#13;
 * Spring相关控制器&#13;
 * */&#13;
@Controller&#13;
@RequestMapping("spring")&#13;
public class SpringController {&#13;
&#13;
	/**&#13;
	 * 获取Spring映射&#13;
	 * **/&#13;
	@RequestMapping("url-mapping")&#13;
	public @ResponseBody Object getURLMapping() {&#13;
		List&lt;URLMapping&gt; list = new ArrayList&lt;URLMapping&gt;();&#13;
		Map&lt;RequestMappingInfo, HandlerMethod&gt; map2 = SpringContextBeanFactory&#13;
				.getBean(RequestMappingHandlerMapping.class)&#13;
				.getHandlerMethods();&#13;
		for (Iterator&lt;RequestMappingInfo&gt; iterator = map2.keySet().iterator(); iterator&#13;
				.hasNext();) {&#13;
			RequestMappingInfo info = iterator.next();&#13;
			URLMapping m = new URLMapping();&#13;
			m.setConsumes(String.valueOf(info.getConsumesCondition()));&#13;
			m.setCustom(String.valueOf(info.getCustomCondition()));&#13;
			m.setHeaders(String.valueOf(info.getHeadersCondition()));&#13;
			m.setMethods(String.valueOf(info.getMethodsCondition()));&#13;
			m.setParams(String.valueOf(info.getParamsCondition()));&#13;
			m.setProduces(String.valueOf(info.getProducesCondition()));&#13;
			m.setUrl(info.getPatternsCondition().toString());&#13;
			HandlerMethod method = map2.get(info);&#13;
			m.setMethodName(method.getMethod().getName());&#13;
			m.setClassName(method.getBeanType().getName());&#13;
			m.setReturnType(method.getReturnType().getParameterType()&#13;
					.toString());&#13;
			MethodParameter[] parameters = method.getMethodParameters();&#13;
			List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();&#13;
			for (MethodParameter methodParameter : parameters) {&#13;
				list2.add(methodParameter.getParameterType().getName());&#13;
			}&#13;
			m.setParameters(String.valueOf(list2));&#13;
			ResponseBody annotationClass = method.getMethodAnnotation(ResponseBody.class);&#13;
			if(annotationClass != null){&#13;
				m.setAnnotationName(annotationClass.toString());&#13;
			}&#13;
			list.add(m);&#13;
		}&#13;
		return ResponseUtils.sendList(list);&#13;
	}&#13;
}&#13;
</pre>这个就是SpringMVC Controller层的代码，首先SpringMVC拦截了spring/url-mapping的访问交给了getURLMapping方法进行处理，这个方法和一般的方法的不一样的方法在于多了一个注解：@ResponseBody，这个注解的作用是将该方法的返回者转换成JSON的数据格式。下面我们可以看看ResponseUtils.sendList这个方法返回的什么东东：</div>&#13;
<div style="text-align:left"><pre name="code" class="java">	public static &lt;T&gt; Map&lt;String, Object&gt; sendList(List&lt;T&gt; T) {&#13;
		Map&lt;String, Object&gt; map = getInstanceMap();&#13;
		map.put("root", T);&#13;
		map.put("success", true);&#13;
		return map;&#13;
	}</pre>这个方法返回的是一个Map对象，Map中包含了两个值，一个是root : List&lt;T&gt;的列表数据，还有一个是success:true的状态标记。Map对象和JSON数据格式有极大的相似性，所以将Map对象转换成数据格式应该是最多的方法。@ResponseBody不但会把Map对象转换成JSON数据格式，也会把对象转换成JSON数据格式。通过断点调试的观察到这个Map的属性：</div>&#13;
<div style="text-align:left"><pre name="code" class="java">{root=[com.avicit.fes.system.spring.vo.URLMapping@49b700, com.avicit.fes.system.spring.vo.URLMapping@18d9055, com.avicit.fes.system.spring.vo.URLMapping@fef39d, com.avicit.fes.system.spring.vo.URLMapping@2bd643, com.avicit.fes.system.spring.vo.URLMapping@1fff5ee, com.avicit.fes.system.spring.vo.URLMapping@16aefbf, com.avicit.fes.system.spring.vo.URLMapping@1a2093a, com.avicit.fes.system.spring.vo.URLMapping@10bde72, com.avicit.fes.system.spring.vo.URLMapping@393c0a, com.avicit.fes.system.spring.vo.URLMapping@194c1f9, com.avicit.fes.system.spring.vo.URLMapping@14ad4ae, com.avicit.fes.system.spring.vo.URLMapping@1d12abe, com.avicit.fes.system.spring.vo.URLMapping@14d5845, com.avicit.fes.system.spring.vo.URLMapping@de3a7a, com.avicit.fes.system.spring.vo.URLMapping@1d15873, com.avicit.fes.system.spring.vo.URLMapping@10606c0, com.avicit.fes.system.spring.vo.URLMapping@a54cb4, com.avicit.fes.system.spring.vo.URLMapping@4ed34b, com.avicit.fes.system.spring.vo.URLMapping@1120709, com.avicit.fes.system.spring.vo.URLMapping@8c2005, com.avicit.fes.system.spring.vo.URLMapping@18a3e15, com.avicit.fes.system.spring.vo.URLMapping@f20092], success=true}</pre>通过前台可以看到：</div>&#13;
<div style="text-align:left"><img src="http://img.my.csdn.net/uploads/201210/10/1349799423_1261.PNG" alt=""/><br/>&#13;
从这张图片上可以看到转行后的JSON数据格式。Spring提供支持@ResponseBody注解的，这个是对象转换成JSON数据的，当然也提供将页面上传过来的数据转换成对象的注解@RequestBody。@RequestBody和Ext提供的RESTful方法完成CURD。个人觉得SringMVC对JSON数据格式的支持比Struts2更灵活更方便，不很繁琐的配置。并且能够处理输出、输入两个方向。开发起来应该会更方便。</div>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<div style="text-align:left">Ext还能做什么？只有想不到的，没有做不到了，进入<a href="http://113.194.15.215:81/"/><a href="http://blog.csdn.net/leecho571/article/details/8207102">http://blog.csdn.net/leecho571/article/details/8207102</a>感受Ext带来的新的体验</div>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<div style="text-align:left">个人对SpringMVC的学习见解，</div>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<h1>实例下载</h1>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<div style="text-align:left"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><a href="http://download.csdn.net/detail/leecho571/4619860" style="color:rgb(34,0,0); text-decoration:none; font-family:Arial; font-size:14px; line-height:26px">http://download.csdn.net/detail/leecho571/4619860</a><br/>&#13;
</span></div>&#13;
<div style="text-align:left">PS：资源分是5分，不是要大家的分，只是希望大家评论一下，给点意见！</div>&#13;
<div style="text-align:left"/>&#13;
<div style="text-align:left"><br/>&#13;
</div>&#13;
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0"/>&#13;
            