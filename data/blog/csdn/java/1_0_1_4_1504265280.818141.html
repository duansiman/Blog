

<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<span style="color:rgb(255,0,0); font-size:18px"><strong>转载请注明出处：<a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39721563" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39755577" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39759199" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39784403" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39804057" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39805069" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39805735" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39806973" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39828653" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39856435" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39863125" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/39997337" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/40008711" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/40018231" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/40018967" style="color:rgb(202,0,0); text-decoration:none"></a><a target="_blank" href="http://blog.csdn.net/lhy_ycu/article/details/40019829">http://blog.csdn.net/lhy_ycu/article/details/40019829</a></strong></span><br />&#13;
</p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<span style="font-size:18px; color:rgb(255,0,0)"><br />&#13;
</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
</p>&#13;
<span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span><span style="font-family:Arial; font-size:14px; line-height:26px; text-align:left"></span>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
解释器模式(Interpreter)：它定义了对象与对象之间进行某种操作之后会得到什么值。一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>&#13;
<h2>一、uml建模：</h2>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<img src="http://img.blog.csdn.net/20141012171610623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGh5X3ljdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<br />&#13;
</p>&#13;
<h2>二、代码实现</h2>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
</p>&#13;
<pre name="code" class="java">/**
 * 解释器模式(Interpreter)：它定义了对象与对象之间进行某种操作之后会得到什么值。
 * 
 * 一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。
 * 
 * 示例：先定义一个实体类，封装两个变量num1、num2
 */
class Entity {
	private double num1;
	private double num2;

	public Entity(double num1, double num2) {
		this.num1 = num1;
		this.num2 = num2;
	}

	public double getNum1() {
		return num1;
	}

	public void setNum1(double num1) {
		this.num1 = num1;
	}

	public double getNum2() {
		return num2;
	}

	public void setNum2(double num2) {
		this.num2 = num2;
	}
}

/**
 * 运算接口
 */
interface Operatable {
	public double interpreter(Entity entity);
}

/**
 * 加法运算
 */
class AddOperation implements Operatable {

	@Override
	public double interpreter(Entity entity) {
		return entity.getNum1() + entity.getNum2();
	}
}

/**
 * 减法运算
 */
class MinusOperation implements Operatable {

	@Override
	public double interpreter(Entity entity) {
		return entity.getNum1() - entity.getNum2();
	}
}

/**
 * 客户端测试类
 * 
 * @author Leo
 */
public class Test {
	public static void main(String[] args) {
		/**
		 * 创建加法、减法运算
		 */
		AddOperation addOperation = new AddOperation();
		MinusOperation minusOperation = new MinusOperation();
		/**
		 * 一、分步运算
		 */
		double addResult = addOperation.interpreter(new Entity(20, 30));
		double minusResult = minusOperation.interpreter(new Entity(20, 30));
		System.out.println("addResult = " + addResult);
		System.out.println("minusResult = " + minusResult);
		/**
		 * 二、混合运算
		 */
		double mixResult = new AddOperation().interpreter(new Entity(
				addOperation.interpreter(new Entity(20, 30)), minusOperation
						.interpreter(new Entity(40, 50))));
		System.out.println("mixResult = " + mixResult);
	}
}</pre><br />&#13;
<p></p>&#13;
<h2>三、总结</h2>&#13;
<p></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
解释器模式用来做各种各样的解释器，如正则表达式的解释器等等。<br />&#13;
</p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px; text-align:left">&#13;
<br />&#13;
</p>&#13;
   &#13;
