
                
<h1>&#13;
</h1><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:center">&#13;
<span style="font-size:24px">要想正确理解设计模式，首先必须明确它是为了解决什么问题而提出来的。</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:center">&#13;
<span style="font-size:24px">设计模式学习笔记</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:right">&#13;
<span style="font-size:24px">——Shulin</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:right">&#13;
<span style="font-size:24px">转载请注明出处：<a target="_blank" href="http://blog.csdn.net/zhshulin" style="color:rgb(202,0,0); text-decoration:none">http://blog.csdn.net/zhshulin</a></span></p>&#13;
&#13;
<h1>1、概念</h1>&#13;
<p/>&#13;
<p>           <span style="font-size:14px">工厂模式<span style="background:rgb(0,255,0)">定义</span>：实例化对象，用工厂方法<span style="background:rgb(255,255,0)">代替<span style="font-family:Times New Roman">new</span><span style="font-family:宋体">操作</span></span>。达到解耦的目的（避免硬编码耦合）。工厂方法模式是类的创建模式，又叫做<span style="background-color:rgb(255,255,0)">虚拟构造子</span><span style="font-family:Times New Roman">(Virtual Constructor)</span><span style="font-family:宋体">模式或者<span style="background-color:rgb(255,255,0)">多态性工厂（</span></span><span style="font-family:Times New Roman">Polymorphic Factory</span><span style="font-family:宋体">）模式。</span></span></p>&#13;
<p><span style="font-family:宋体"><span style="font-size:14px"><br/>&#13;
</span></span></p>&#13;
<p><span style="font-size:14px">        工厂模式是我们最常用的模式了，著名的<span style="font-family:Times New Roman">Jive</span><span style="font-family:宋体">论坛 </span><span style="font-family:Times New Roman">,</span><span style="font-family:宋体">就大量使用了工厂模式，工厂模式在</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的</span><span style="font-family:Times New Roman">new</span><span style="font-family:宋体">，我们经常要根据类</span><span style="font-family:Times New Roman">Class</span><span style="font-family:宋体">生成实例对象，如</span><span style="font-family:Times New Roman">A a=new A() </span><span style="font-family:宋体">工厂模式也是用来创建实例对象的，所以</span><span style="color:rgb(0,0,255)">以后<span style="font-family:Times New Roman">new</span><span style="font-family:宋体">时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量</span></span>。</span></p>&#13;
<p><span style="font-size:14px"><br/>&#13;
</span></p>&#13;
<p><span style="font-size:14px">       常用的<span style="font-family:Times New Roman">java ee</span><span style="font-family:宋体">框架：</span><span style="font-family:Times New Roman">Spring</span><span style="font-family:宋体">，</span><span style="background:rgb(255,255,0)">Spring<span style="font-family:宋体">容器就是一个巨大的工厂</span></span>。</span></p>&#13;
<br/>&#13;
<h1>2、目的</h1>&#13;
<p/>&#13;
<p><strong>   <span style="font-size:18px">    </span><span style="font-size:14px"/></strong><span style="font-size:14px; color:#ff0000">解耦，使程序的扩展性更强。</span></p>&#13;
<br/>&#13;
<h1>3、举例说明</h1>&#13;
<p><br/>&#13;
</p>&#13;
<p/>&#13;
<p>      <span style="font-size:14px">  比如现在有<span style="font-family:Times New Roman">2</span><span style="font-family:宋体">个工作</span><span style="font-family:Times New Roman">AWork</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">BWork</span><span style="font-family:宋体">，以后可能更多。如果此时我们使用简单工厂方法，那么我们会设计一个</span><span style="font-family:Times New Roman">WorkFactory</span><span style="font-family:宋体">然后实现一个静态方法，通过参数来控制生成哪个工作。看似简单工厂也能完成任务，但是如果以后需要加上</span><span style="font-family:Times New Roman">CWork</span><span style="font-family:宋体">，那么需要添加</span><span style="font-family:Times New Roman">CWork</span><span style="font-family:宋体">实现类以及修改工厂方法，如果更多，那么会导致工厂类过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。</span></span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">        这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。</span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">        这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计<span style="font-family:Times New Roman">UML</span><span style="font-family:宋体">图：</span></span></p>&#13;
<p><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<img src="http://img.blog.csdn.net/20140801164754156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""/><br/>&#13;
<p><br/>&#13;
</p>&#13;
<p/>&#13;
<p><span style="font-size:14px">从上图可以看出，这个使用的工厂方法模式的系统涉及到以下角色：</span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">　　<span style="background:rgb(255,255,0)">抽象工厂（<span style="font-family:Times New Roman">IWorkFactory</span><span style="font-family:宋体">）角色</span></span>：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">　<span style="background:rgb(255,255,0)">　具体工厂（<span style="font-family:Times New Roman">AWorkFactory</span><span style="font-family:宋体">、</span><span style="font-family:Times New Roman">BWorkFactory</span><span style="font-family:宋体">）角色</span></span>：担任这个角色的是实现了抽象工厂接口的具体<span style="font-family:Times New Roman">JAVA</span><span style="font-family:宋体">类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建工作类。</span></span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">　<span style="background:rgb(255,255,0)">　抽象工作（<span style="font-family:Times New Roman">IWork</span><span style="font-family:宋体">）角色</span></span>：工厂方法模式所创建的对象的超类，也就是所有工作类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">　　<span style="background:rgb(255,255,0)">具体工作（<span style="font-family:Times New Roman">AWork</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">BWork</span><span style="font-family:宋体">）角色</span></span>：这个角色实现了抽象（<span style="font-family:Times New Roman">ExportFile</span><span style="font-family:宋体">）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体工作角色的实例。</span></span></p>&#13;
<br/>&#13;
<h1>4、源代码</h1>&#13;
<p><br/>&#13;
</p>&#13;
<p><span style="background-color:rgb(255,204,51)">抽象工作类：</span></p>&#13;
<p/>&#13;
<pre name="code" class="java">public interface IWork {
	public void doWork();
}</pre><br/>&#13;
<span style="background-color:rgb(255,204,0)">具体工作类：</span>&#13;
<p/>&#13;
<p/>&#13;
<pre name="code" class="java">public class AWork implements IWork {
	@Override
	public void doWork() {
		System.out.println("做的是A工作！");
	}
}</pre><br/>&#13;
<pre name="code" class="java">public class BWork implements IWork {
	@Override
	public void doWork() {
		System.out.println("做的是B工作！");
	}
}</pre>&#13;
<p/>&#13;
<p><br/>&#13;
</p>&#13;
<span style="background-color:rgb(255,204,0)">抽象工厂：</span>&#13;
<p/>&#13;
<pre name="code" class="java">public interface IWorkFactory {
	public IWork createWork();
}</pre><br/>&#13;
<span style="background-color:rgb(255,204,0)">具体工厂：</span><br/>&#13;
<pre name="code" class="java">public class AWorkFactory implements IWorkFactory {

	@Override
	public IWork createWork() {
		return new AWork();
	}

}</pre><br/>&#13;
<pre name="code" class="java">public class BWorkFactory implements IWorkFactory {

	@Override
	public IWork createWork() {
		return new BWork();
	}

}</pre><br/>&#13;
<p/>&#13;
<p><span style="background-color:rgb(255,204,0)">客户端角色类源代码：</span></p>&#13;
<pre name="code" class="java">public class Test {

	public static void main(String[] args) {
		IWorkFactory aWorkFactory = new AWorkFactory();
		IWork aWork = aWorkFactory.createWork();
		aWork.doWork();
		
		IWorkFactory bWorkFactory = new BWorkFactory();
		IWork bWork = bWorkFactory.createWork();
		bWork.doWork();
	}

}</pre>&#13;
<p><br/>&#13;
</p>&#13;
<h1>5、工厂模式和简单工厂模式</h1>&#13;
<p/>&#13;
<p>     <span style="font-size:14px">     工厂方法模式和简单工厂模式在结构上的不同很明显。<span style="background:rgb(255,255,0)">工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上</span>。</span></p>&#13;
<p><span style="font-size:14px"><br/>&#13;
</span></p>&#13;
<p><span style="font-size:14px">　　工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</span></p>&#13;
<p><span style="font-size:14px"> </span></p>&#13;
<p><span style="font-size:14px">　　如果系统需要加入一个新的工作<span style="font-family:Times New Roman">CWork</span><span style="font-family:宋体">，那么所需要的就是向系统中加入一个这个导类以及所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。对于增加新的导出类型而言，这个系统完全支持“开</span><span style="font-family:Times New Roman">-</span><span style="font-family:宋体">闭原则”。</span></span></p>&#13;
<p><br/>&#13;
</p>&#13;
<div style="text-align:center"><span style="color:rgb(51,51,255)">（原文地址：</span><span style="color:rgb(51,51,255)">http://blog.csdn.net/zhshulin/article/details/38339085</span><span style="color:rgb(51,51,255)">）</span></div>&#13;
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0"/>&#13;
            