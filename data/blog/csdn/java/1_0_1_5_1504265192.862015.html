
        <div class="markdown_views"><p><strong>摘要：</strong></p>

<p>　　Spring是一个分层的Java SE/EE应用一站式的轻量级开源框架，其从持久层、业务层到表现层都拥有相应的支持，几乎为企业应用提供了所需的一切。本文首先概述了Spring容器的IoC控制反转和DI依赖注入两大概念， 然后详述了Spring的IoC容器BeanFactory、Spring容器ApplicationContext和Spring的Web容器WebApplicationContext，并介绍了三者的异同。最后，本文介绍了Spring的资源访问神器Resource接口、基于XML在IoC容器中装配Bean以及Bean的生命周期等主要概念。</p>

<hr />

<p><strong>版权声明：</strong></p>

<p>　　本文转载于CSDN博友春水上行的原创博文<a href="http://blog.csdn.net/c99463904/article/details/73003558" target="_blank">《Spring 深入浅出核心技术 (一)》</a>。</p>

<hr />



<h2 id="一-spring-简介">一. Spring 简介</h2>

<p>　　Spring是一个分层的Java SE/EE应用一站式的轻量级开源框架，它的核心是IOC和AOP。如下图所示，整个spring框架按其所属功能可以划分为五个主要模块，这五个模块几乎为企业应用提供了所需的一切，从持久层、业务层到表现层都拥有相应的支持，这就是为什么称Spring是一站式框架的原因。</p>

<p>　　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/c7iy93efv5mn8y1t3awsvbnu/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Spring体系结构.png-50.8kB" title="" /></p>

<hr />

<p><strong>1、核心模块(Core Container)</strong> </p>

<p>　　Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述。由IoC容器负责类的创建，管理，获取等。BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。</p>

<p>　　Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化，资源加载，邮件服务，任务调度等多项功能。ApplicationContext是Context模块的核心接口。</p>

<p>　　表达式语言(Expression Language)是统一表达式语言(EL)的一个扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。</p>

<hr />

<p><strong>2、AOP模块</strong> </p>

<p>　　Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。</p>

<hr />

<p><strong>3、数据访问集成模块（Data Access/Integration ）</strong> </p>

<p>　该模块包括了JDBC、ORM、OXM、JMS和事务管理：</p>

<ul>
<li><p>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</p></li>
<li><p>JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p></li>
<li><p>ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。</p></li>
<li><p>OXM模块：提供了一个对Object/XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</p></li>
<li><p>JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p></li>
</ul>

<hr />

<p><strong>4、Web模块</strong> </p>

<p>　　该模块建立在ApplicationContext模块之上，提供了Web应用的功能，如文件上传、FreeMarker等。Spring可以整合Struts2等MVC框架。此外，Spring自己提供了MVC框架Spring MVC。</p>

<hr />

<p><strong>5、测试模块</strong></p>

<p>　　Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。</p>

<hr />



<h2 id="二-初识spring的ioc容器">二. 初识Spring的IoC容器</h2>

<p>　　我们首先来讲解一下IoC的概念。IoC(控制反转:Inverse of Control)是Spring容器的核心，但是IoC这个概念却比较晦涩，让人不太容易望文生义。</p>

<hr />

<p><strong>1、IoC控制反转和DI依赖注入</strong></p>

<p>　　传统程序设计中，我们需要使用某个对象的方法，需要先通过new创建一个该对象，我们这时是主动行为；而IoC是我们将创建对象的控制权交给IoC容器，这时是由容器帮忙创建及注入依赖对象，我们的程序被动的接受IoC容器创建的对象，控制权反转，所以叫控制反转。</p>

<p>　　由于IoC确实不够开门见山，所以提出了DI（依赖注入：Dependency Injection）的概念，即让第三方来实现注入，以移除我们类与需要使用的类之间的依赖关系。总的来说，<font color="red"><b>IoC是目的，DI是手段，创建对象的过程往往意味着依赖的注入。</b></font>我们为了实现IoC，让生成对象的方式由传统方式(new)反转过来，需要创建相关对象时由IoC容器帮我们注入(DI)。</p>

<p>　　简单的说，就是我们类里需要另一个类，只需要让Spring帮我们创建 ，这叫做控制反转；然后Spring帮我们将需要的对象设置到我们的类中，这叫做依赖注入。</p>

<hr />

<p><strong>2、常见的几种注入方法</strong></p>

<ul>
<li>使用有参构造方法注入</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">User</span>{</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(String name){
        <span class="hljs-keyword">this</span>.name=name;
    }
} 

    User user=<span class="hljs-keyword">new</span> User(<span class="hljs-string">"tom"</span>);</code></pre>

<hr />

<ul>
<li>使用属性注入</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">User</span>{</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name=name;
    }
}

     User user=<span class="hljs-keyword">new</span> User();
     user.setName(<span class="hljs-string">"jack"</span>);</code></pre>

<hr />

<ul>
<li>使用接口注入</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 将调用类所有依赖注入的方法抽取到接口中，调用类通过实现该接口提供相应的注入方法。 </span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dao</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span>(String name);
} 

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DapIml</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Dao</span>{</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span>(String name){
        <span class="hljs-keyword">this</span>.name=name;
    }
}</code></pre>

<hr />

<ul>
<li>通过容器完成依赖关系的注入</li>
</ul>

<p>上面的注入方式都需要我们手动的进行注入，如果有一个第三方容器能帮助我们完成类的实例化，以及依赖关系的装配，那么我们只需要专注于业务逻辑的开发即可。Spring就是这样的容器，<font color="red"><b>它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。</b></font></p>

<hr />

<p><strong>3、Spring的IoC例子</strong></p>

<p>(1). 创建工程，导入jar包</p>

<p>　　这里我们只是做IoC的操作，所以只需要导入核心模块里的jar包，beans、core、context、expression等。因为spring中并没有日志相关的jar包，所以我们还需要导入log4j和commons-logging。</p>

<hr />

<p>(2). 创建一个类</p>



<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(){
        System.out.println(<span class="hljs-string">"add....."</span>);
    }
}</code></pre>

<hr />

<p>(3). 创建一个xml配置文件</p>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span> 

    //配置要创建的类  
    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"user"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.User"</span>/&gt;</span>        
<span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span>  </code></pre>

<hr />

<p>(4). 进行测试</p>



<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-comment">//这只是用来测试的代码，后期不会这么写</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>

    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        <span class="hljs-comment">//加载配置文件</span>
        ApplicationContext context=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        <span class="hljs-comment">//获取对象</span>
        User user=(User) context.getBean(<span class="hljs-string">"user"</span>);
        System.out.println(user);
        <span class="hljs-comment">//调用方法</span>
        user.add();
    }
} </code></pre>

<p>　　在容器启动时，Spring会根据配置文件的描述信息，自动实例化Bean并完成依赖关系的装配，从容器中即可获得Bean实例，就可以直接使用。Spring为什么仅凭一个简单的配置文件，就能神奇的实例化并配置好程序使用的Bean呢？答案是通过 <font color="red"><b>Java的反射技术</b></font>。</p>

<hr />

<p><strong>4、Spring的DI例子</strong></p>

<p>　　我们的service层总是用到dao层，以前我们总是在Service层new出dao对象，现在我们使用依赖注入的方式向Service层注入dao层。</p>



<pre class="prettyprint"><code class="language-java hljs ">

<span class="hljs-comment">// UserDao</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(){
        System.out.println(<span class="hljs-string">"dao....."</span>);
    }
}

<span class="hljs-comment">// UserService</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> {</span>
    UserDao userdao;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserdao</span>(UserDao userdao){
        <span class="hljs-keyword">this</span>.userdao=userdao;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(){
        System.out.println(<span class="hljs-string">"service......."</span>);
        userdao.add();
    }
}

-------------------------------分割线--------------------------

<span class="hljs-comment">// 配置文件</span>
&lt;bean id=<span class="hljs-string">"userdao"</span> class=<span class="hljs-string">"com.cad.domain.UserDao"</span>&gt;&lt;/bean&gt; 
<span class="hljs-comment">//这样在实例化service的时候，同时装配了dao对象，实现了依赖注入</span>
&lt;bean id=<span class="hljs-string">"userservice"</span> class=<span class="hljs-string">"com.cad.domain.UserService"</span>&gt;
    <span class="hljs-comment">//ref为dao的id值</span>
    &lt;property name=<span class="hljs-string">"userdao"</span> ref=<span class="hljs-string">"userdao"</span>&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<hr />



<h2 id="三-spring的资源访问神器-resource接口">三. Spring的资源访问神器 —— Resource接口</h2>

<p>　　JDK提供的访问资源的类(如java.NET.URL,File)等并不能很好很方便的满足各种底层资源的访问需求。Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。</p>

<hr />

<p><strong>1、Resource接口的主要方法</strong></p>

<ul>
<li><p>boolean exists():资源是否存在</p></li>
<li><p>boolean isOpen():资源是否打开</p></li>
<li><p>URL getURL():返回对应资源的URL</p></li>
<li><p>File getFile():返回对应的文件对象</p></li>
<li><p>InputStream getInputStream():返回对应资源的输入流</p></li>
</ul>

<p>Resource在Spring框架中起着不可或缺的作用，Spring框架使用Resource装载各种资源，包括配置文件资源，国际化属性资源等。</p>

<hr />

<p><strong>2、Resource接口的具体实现类</strong></p>

<ul>
<li><p>ByteArrayResource：二进制数组表示的资源</p></li>
<li><p>ClassPathResource：类路径下的资源 ，资源以相对于类路径的方式表示</p></li>
<li><p>FileSystemResource：文件系统资源，资源以文件系统路径方式表示，如d:/a/b.txt</p></li>
<li><p>InputStreamResource：对应一个InputStream的资源</p></li>
<li><p>ServletContextResource:为访问容器上下文中的资源而设计的类。负责以相对于web应用根目录的路径加载资源</p></li>
<li><p>UrlResource：封装了java.net.URL。用户能够访问任何可以通过URL表示的资源，如Http资源，Ftp资源等</p></li>
</ul>

<hr />

<p><strong>3、Spring的资源加载机制</strong></p>

<p>　　为了访问不同类型的资源，必须使用相应的Resource实现类，这是比较麻烦的。Spring提供了一个强大的加载资源的机制，仅通过资源地址的特殊标识就可以加载相应的资源。首先，我们了解一下Spring支持哪些资源类型的地址前缀:</p>

<ul>
<li><p>classpath: 例如classpath:com/cad/domain/bean.xml。从类路径中加载资源</p></li>
<li><p>file:例如 file:com/cad/domain/bean.xml.使用UrlResource从文件系统目录中加载资源。</p></li>
<li><p>http:// 例如<a href="http://www.baidu.com/resource/bean.xml" target="_blank">http://www.baidu.com/resource/bean.xml</a> 使用UrlResource从web服务器加载资源</p></li>
<li><p>ftp:// 例如frp://10.22.10.11/bean.xml 使用UrlResource从ftp服务器加载资源</p>

<p>　　Spring定义了一套资源加载的接口。ResourceLoader接口仅有一个getResource(String location)的方法，可以根据资源地址加载文件资源。资源地址仅支持带资源类型前缀的地址，不支持Ant风格的资源路径表达式。ResourcePatternResolver扩展ResourceLoader接口，定义新的接口方法getResources(String locationPattern)，该方法支持带资源类型前缀以及Ant风格的资源路径的表达式。PathMatchingResourcePatternResolver是Spring提供的标准实现类。</p></li>
</ul>

<hr />

<p><strong>4、例子</strong></p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> IOException {
        ResourceLoader resloLoader = <span class="hljs-keyword">new</span> DefaultResourceLoader();
        Resource res = resloLoader
                .getResource(<span class="hljs-string">"https://www.baidu.com/"</span>);
        System.out.println(res <span class="hljs-keyword">instanceof</span> UrlResource); <span class="hljs-comment">// true</span>
        BufferedReader bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(res.getInputStream()));
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        String temp = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">while</span> ((temp = bf.readLine())!= <span class="hljs-keyword">null</span>) {
            sb.append(temp);
        }
        System.out.println(sb.toString());

        System.out.println(<span class="hljs-string">"\n-----------------------------\n"</span>);
        res = resloLoader.getResource(<span class="hljs-string">"classpath:test.txt"</span>);
        bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(res.getInputStream()));
        sb = <span class="hljs-keyword">new</span> StringBuilder();
        temp = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">while</span> ((temp = bf.readLine())!= <span class="hljs-keyword">null</span>) {
            sb.append(temp);
        }
        System.out.println(sb.toString());

        System.out.println(<span class="hljs-string">"\n-----------------------------\n"</span>);
        res = resloLoader.getResource(<span class="hljs-string">"file:C:\\Users\\ricco\\Desktop\\test\\test.txt"</span>);
        bf = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(res.getInputStream()));
        sb = <span class="hljs-keyword">new</span> StringBuilder();
        temp = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">while</span> ((temp = bf.readLine())!= <span class="hljs-keyword">null</span>) {
            sb.append(temp);
        }
        System.out.println(sb.toString());
    }
}</code></pre>

<hr />



<h2 id="四-详解spring的ioc容器beanfactoryapplicationcontext-和-webapplicationcontext">四. 详解Spring的IoC容器：BeanFactory、ApplicationContext 和 WebApplicationContext</h2>

<p><strong>1、BeanFactory</strong></p>

<p>　　BeanFactory是一个类工厂，和传统的类工厂不同，传统的类工厂仅负责构造一个类或几个类的实例；而BeanFactory可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。</p>

<p>　　BeanFactory是一个接口，Spring为BeanFactory提供了多种实现，最常用的就是XmlBeanFactory。其中，BeanFactory接口最主要的方法就是getBean(String beanName)，该方法从容器中返回指定名称的Bean。此外，BeanFactory接口的功能可以通过实现它的接口进行扩展(比如ApplicationContext)。看下面的示例：</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//我们使用Spring配置文件为User类提供配置信息，然后通过BeanFactory装载配置文件，启动Spring IoC容器。 </span>
&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;
&lt;beans xmlns=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>
    xmlns:xsi=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    xsi:schemaLocation=<span class="hljs-string">"http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;

&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span>&gt;&lt;/bean&gt;   
&lt;/beans&gt;  </code></pre>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们通过XmlBeanFactory实现类启动Spring IoC容器 </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){ 
        <span class="hljs-comment">//获取配置文件</span>
        ResourcePatternResolver  resolver=<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver(); 
        Resource rs=resolver.getResource(<span class="hljs-string">"classpath:bean.xml"</span>);

        <span class="hljs-comment">//加载配置文件并启动IoC容器</span>
        BeanFactory bf=<span class="hljs-keyword">new</span> XmlBeanFactory(rs);

        <span class="hljs-comment">//从容器中获取Bean对象</span>
        User user=(User) bf.getBean(<span class="hljs-string">"user"</span>);

        user.speak();
    }
}  </code></pre>

<p>　　XmlBeanFactory装载Spring配置文件并启动IoC容器，通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化创建动作在第一个调用时。在初始化BeanFactory，必须提供一种日志框架，我们使用Log4J。</p>

<hr />

<p><strong>2、ApplicationContext</strong></p>

<p>　　ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要编程方式来实现，而ApplicationContext中可以通过配置的方式来实现。ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中加载配置文件，如下所示：</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 和BeanFactory初始化相似，ApplicationContext初始化也很简单</span>
ApplicationContext ac=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);</code></pre>

<p>　　ApplicationContext的初始化和BeanFactory初始化有一个重大的区别，<font color="red"><b>BeanFactory初始化容器时并未初始化Bean，只有第一次访问Bean时才创建；而ApplicationContext则在初始化时就实例化所有的单实例的Bean。</b></font>因此，ApplicationContext的初始化时间会稍长一点。</p>

<hr />

<p><strong>3、WebApplicationContext</strong></p>

<p>　　WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作。从WebApplicationContext中可以获取ServletContext的引用，整个WebApplicationContext对象作为属性放置到ServletContext中，以便Web应用环境中可以访问Spring应用上下文。ConfigurableWebApplicationContext扩展了WebApplicationContext,允许通过配置方式实例化WebApplicationContext，定义了两个重要方法。</p>

<ul>
<li><p>setServletContext(ServletContext servletcontext):为Spring设置ServletContext</p></li>
<li><p>setConfigLocation(String[] configLocations):设置Spring配置文件地址。</p></li>
</ul>

<p><font color="red"><b>WebApplicationContext初始化的时机和方式是：利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，当ServletContext对象创建时，创建并初始化WebApplicationContext对象。</b></font>因此，我们只需要在web.xml配置监听器即可。</p>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!-- 利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，并初始化WebApplicationContext对象 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-title">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">listener</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- Context Configuration locations for Spring XML files(默认查找/WEB-INF/applicationContext.xml) --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-title">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-title">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">context-param</span>&gt;</span></code></pre>

<hr />

<p><strong>4、BeanFactory、ApplicationContext和WebApplicationContext的联系与区别</strong></p>

<p>　　Spring通过一个配置文件描述Bean与Bean之间的依赖关系，通过Java语言的反射技术能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了bean实例缓存、生命周期管理、事件发布，资源装载等高级服务。</p>

<p>　　BeanFactory是Spring最核心的接口，提供了高级IoC的配置机制。ApplicationContext建立在BeanFactory的基础上，是BeanFactory的子接口，提供了更多面向应用的功能。<font color="red"><b>我们一般称BeanFactory为IoC容器，ApplicationContext为应用上下文，也称为Spring容器。</b></font>WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作，是ApplicationContext接口的子接口。</p>

<p>　　<font color="red"><b>BeanFactory是Spring框架的基础，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用我们都直接使用ApplicationContext而非底层的BeanFactory；WebApplicationContext是专门用于Web应用。</b></font></p>

<hr />

<p><strong>5、父子容器</strong></p>

<p>　　通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的体系：<font color="red"><b>子容器可以访问父容器的Bean，父容器不能访问子容器的Bean。</b></font></p>

<p>　　Spring使用父子容器实现了很多功能，比如在Spring MVC中，控制器Bean位于子容器中，业务层和持久层Bean位于父容器中。但即使这样，控制器Bean也可以引用持久层和业务层的Bean，而业务层和持久层就看不到控制器Bean。</p>

<hr />



<h2 id="五-基于xml在ioc容器中装配bean">五. 基于XML在IoC容器中装配Bean</h2>

<p>　　为了让IoC容器帮我们创建和管理对象，我们必须在Spring IoC容器中装配好Bean，并建立好Bean和Bean之间的关联关系。Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系。</p>

<hr />

<p><strong>1、Bean的基本配置</strong></p>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!-- id:Bean的名称; class:指定了Bean对应的实现类 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">“userdaoid”</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">“UserDao”</span>/&gt;</span></code></pre>

<hr />

<p><strong>2、Bean的命名</strong></p>

<p>　　一般情况下，配置Bean时需要为其指定一个id属性作为Bean的名称。<font color="red"><b>id在IoC容器中必须是唯一的。</b></font>id的命名需要满足xml的命名规范：必须以字母开始，后面可以使字母数字、下划线、句号、冒号等符号，逗号和空格等字符是非法的。</p>

<p>　　&lt;bean&gt;还有一个name属性，和id属性作用一样，但是name几乎可以使用任何字符。Spring配置文件中不允许出现相同的id，却允许出现相同的name。如果有相同的name，通过getBean(beanName)获取Bean时，将返回最后生命的Bean，原因是最后的Bean覆盖了前面同名的Bean。一般地，应该尽量使用id。</p>

<hr />

<p><strong>3、Bean的实例化方式</strong></p>

<ul>
<li>使用默认的无参构造方法实例化</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-comment">// 创建一个类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>{</span>
}  

 <span class="hljs-comment">// 配置xml文件</span>
&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span> &gt;&lt;/bean&gt;</code></pre>

<hr />

<ul>
<li>使用默认的无参构造方法实例化 <br />
工厂方法是非静态的，即必须实例化工厂类后才能调用工厂方法。</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 创建一个工厂类，提供一个普通的方法，返回指定的对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> {</span>
    <span class="hljs-keyword">public</span>  User <span class="hljs-title">getUser</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();
    }
}

<span class="hljs-comment">//------------------------------- 配置xml文件 ---------------------------------</span>

<span class="hljs-comment">//先要实例工厂</span>
&lt;bean id=<span class="hljs-string">"factory"</span> class=<span class="hljs-string">"com.cad.domain.UserFactory"</span> &gt;&lt;/bean&gt; 
<span class="hljs-comment">//通过实例化工厂调用工厂方法获取对象，factory-bean属性引用工厂实例，factory-method指定工厂方法</span>
&lt;bean id=<span class="hljs-string">"user"</span> factory-bean=<span class="hljs-string">"factory"</span> factory-method=<span class="hljs-string">"getUser"</span>&gt;&lt;/bean&gt;</code></pre>

<hr />

<ul>
<li>使用静态工厂方法实例化 <br />
工厂类方法是静态的，可以不用创建工厂类实例直接使用。</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 创建一个工厂类，提供一个静态方法，返回指定的对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">getUser</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();
    }
}

<span class="hljs-comment">//------------------------------- 配置xml文件 ---------------------------------</span>

<span class="hljs-comment">//class指定工厂类，factory指定工厂方法</span>
&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.UserFactory"</span> factory-method=<span class="hljs-string">"getUser"</span>&gt;&lt;/bean&gt;</code></pre>

<hr />

<p><strong>4、Bean的属性注入</strong></p>

<p>　　Spring支持两种依赖注入方式，分别是属性注入和构造方法注入。用户不但可以将String，int等类型参数注入到Bean中，还可以将集合、Map类型注入到Bean中。</p>

<hr />

<ul>
<li>属性注入(使用属性的set方法)</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 属性注入要求Bean提供一个默认的构造方法，并为需要注入的属性提供对应的set方法。</span>
<span class="hljs-comment">// Spring调Bean的默认构造方法创建对象，然后通过反射的方式调用set方法注入属性。 </span>

<span class="hljs-comment">// 创建类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span>(String username){
        <span class="hljs-keyword">this</span>.username=username;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span>(){
        System.out.println(<span class="hljs-string">"my name is"</span>+username);
    }
}

<span class="hljs-comment">//------------------------------- 配置xml文件 ---------------------------------</span>

&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span>&gt; 
&lt;!--&lt;property&gt;对应一个属性，name是属性的名称，value是属性的值，ref用来引用其他bean--&gt;
    &lt;property name=<span class="hljs-string">"username"</span> value=<span class="hljs-string">"张三"</span>&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<hr />

<ul>
<li>使用有参数构造方法注入</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 使用构造方法注入前提是Bean必须提供带参的构造方法。 </span>
<span class="hljs-comment">//创建User类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(String username){
        <span class="hljs-keyword">this</span>.username=username;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span>(){
        System.out.println(<span class="hljs-string">"my name is"</span>+username);
    }
}

<span class="hljs-comment">//------------------------------- 配置xml文件 ---------------------------------</span>
&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span>&gt;
    &lt;!--&lt;constructor-arg&gt;标签对应构造方法的参数，name是参数名称，value是参数值--&gt;
    &lt;constructor-arg name=<span class="hljs-string">"username"</span> value=<span class="hljs-string">"jack"</span>&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </code></pre>

<p>　　这里有一个小问题，如果类中有两个带参构造方法，我们应该怎样注入？&lt;constructor-arg&gt;标签有两个属性 index和type。type是指定要注入的属性的类型，index指定注入的属性的顺序，从0开始。</p>

<hr />

<ul>
<li>注入null值 <br />
如果需要为某个属性注入null值，必须使用专用的&lt;null/&gt;标签。</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 如果需要为某个属性注入null值，必须使用专用的&lt;null/&gt;标签。</span>
&lt;bean id=<span class="hljs-string">"userdaoid"</span> class=<span class="hljs-string">"UserDao"</span>&gt; 
    &lt;property name=<span class="hljs-string">"username"</span>&gt;&lt;<span class="hljs-keyword">null</span>/&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<hr />

<ul>
<li>注入集合类型 <br />
java.util包中的集合类是最常用的数据结构类型。主要包括List、Set、map、Properties等，Spring为这些集合提供了专门的标签来配置。</li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们创建一个类，包含了各种集合类型 </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionDemo</span> {</span>
    <span class="hljs-keyword">private</span> List&lt;String&gt; list; 
    <span class="hljs-keyword">private</span> Set&lt;String&gt; set; 
    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map; 
    <span class="hljs-keyword">private</span> Properties properties;

    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getList</span>() {
        <span class="hljs-keyword">return</span> list;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setList</span>(List&lt;String&gt; list) {
        <span class="hljs-keyword">this</span>.list = list;
    }
    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSet</span>() {
        <span class="hljs-keyword">return</span> set;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSet</span>(Set&lt;String&gt; set) {
        <span class="hljs-keyword">this</span>.set = set;
    }
    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">getMap</span>() {
        <span class="hljs-keyword">return</span> map;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMap</span>(Map&lt;String, String&gt; map) {
        <span class="hljs-keyword">this</span>.map = map;
    }
    <span class="hljs-keyword">public</span> Properties <span class="hljs-title">getProperties</span>() {
        <span class="hljs-keyword">return</span> properties;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span>(Properties properties) {
        <span class="hljs-keyword">this</span>.properties = properties;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"CollectionDemo [list="</span> + list + <span class="hljs-string">", set="</span> + set + <span class="hljs-string">", map="</span> + map + <span class="hljs-string">", properties="</span> + properties + <span class="hljs-string">"]"</span>;
    } 
}

<span class="hljs-comment">//------------------------------- 配置xml文件 ---------------------------------</span>

&lt;bean id=<span class="hljs-string">"collid"</span> class=<span class="hljs-string">"com.cad.domain.CollectionDemo"</span>&gt; 
    &lt;!--配置list集合--&gt;
    &lt;property name=<span class="hljs-string">"list"</span>&gt;
        &lt;list&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;李四&lt;/value&gt;
        &lt;/list&gt; 
    &lt;/property&gt; 

    &lt;!--配置set集合--&gt;
    &lt;property name=<span class="hljs-string">"set"</span>&gt;
        &lt;set&gt;
            &lt;value&gt;java&lt;/value&gt;
            &lt;value&gt;c#&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt; 

    &lt;!--配置map集合--&gt;
    &lt;property name=<span class="hljs-string">"map"</span>&gt;
        &lt;map&gt;
            &lt;entry key=<span class="hljs-string">"jack"</span> value=<span class="hljs-string">"杰克"</span>&gt;&lt;/entry&gt;
            &lt;entry key=<span class="hljs-string">"tom"</span>  value=<span class="hljs-string">"汤姆"</span>&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt; 

    &lt;!--配置properties类型--&gt;
    &lt;property name=<span class="hljs-string">"properties"</span>&gt;
        &lt;props&gt;
            &lt;prop key=<span class="hljs-string">"prop1"</span>&gt;prop1&lt;/prop&gt;
            &lt;prop key=<span class="hljs-string">"prop2"</span>&gt;prop2&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<hr />

<p><strong>5、使用p命名空间</strong></p>

<p>　　为了简化Xml的配置，Spring引入了一个P命名空间。</p>

<p>未使用P命名空间之前:</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 创建一个User类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.age = age;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span>(){
        System.out.println(name+<span class="hljs-string">":"</span>+age);
    }
} </code></pre>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!-- 配置文件 --&gt;</span>
<span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"user"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.User"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"name"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"张三"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"age"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"18"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span>  </code></pre>

<hr />

<p>使用P命名空间之后:</p>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!-- 配置文件 --&gt;</span>
<span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!--使用p:属性名="xxx" 或者 p:属性名-ref="引用id"来指定属性--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"user"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.User"</span> <span class="hljs-attribute">p:name</span>=<span class="hljs-value">"李四"</span> <span class="hljs-attribute">p:age</span>=<span class="hljs-value">"88"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span>  </code></pre>

<hr />

<p><strong>6、Bean的作用域</strong></p>

<p>　　Bean的作用域会对Bean的生命周期和创建方式产生影响，其一共有五种作用域：</p>

<p>　　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/3g52ijrgssplxs3dvkntpk6o/Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="Bean的作用域.png-23.5kB" title="" /></p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们来演示一下，将User类的作用域设置为singleton</span>
&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span> p:name=<span class="hljs-string">"李四"</span> p:age=<span class="hljs-string">"88"</span> scope=<span class="hljs-string">"singleton"</span>/&gt;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        ApplicationContext ac=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        User user1=(User) ac.getBean(<span class="hljs-string">"user"</span>);  <span class="hljs-comment">//获得的两个对象是一样的</span>
        User user2=(User) ac.getBean(<span class="hljs-string">"user"</span>); 
        System.out.println(user1);
        System.out.println(user2);
    }
}<span class="hljs-javadoc">/**Output
        com.cad.domain.User@1c3a4799
        com.cad.domain.User@1c3a4799
**/</span></code></pre>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 将User的作用域设置为多例</span>
&lt;bean id=<span class="hljs-string">"user"</span> class=<span class="hljs-string">"com.cad.domain.User"</span> p:name=<span class="hljs-string">"李四"</span> p:age=<span class="hljs-string">"88"</span> scope=<span class="hljs-string">"prototype"</span>/&gt;

<span class="hljs-comment">// 输出 </span>
com.cad.domain.User@<span class="hljs-number">5</span>d76b067
com.cad.domain.User@<span class="hljs-number">2</span>a17b7b6</code></pre>

<hr />

<p><strong>7、FactoryBean</strong></p>

<p>　　我们前面的&lt;bean&gt;都是普通bean，Spring利用反射机制通过bean的class属性来实例化Bean。如果有的Bean属性特别多，我们就需要编写大量的配置信息。Spring提供了一个FactoryBean&lt;T&gt;接口。我们可以通过实现该接口来返回特定的Bean，该接口定义了三个方法：</p>

<ul>
<li><p>T getObject():返回由FactoryBean创建的Bean实例。</p></li>
<li><p>boolean isSingleton():确定创建的Bean的作用域是singleton还是prototype</p></li>
<li><p>Class&lt; ? &gt; getObjectType():返回FactoryBean创建Bean的类型</p></li>
</ul>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们创建一个类实现FactoryBean接口 </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">User</span>&gt; {</span>

    <span class="hljs-comment">//返回对象</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title">getObject</span>() <span class="hljs-keyword">throws</span> Exception {
        User user=<span class="hljs-keyword">new</span> User();
        user.setAge(<span class="hljs-number">14</span>);
        user.setName(<span class="hljs-string">"tom"</span>);
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">//返回bean的类型</span>
    <span class="hljs-keyword">public</span> Class&lt;User&gt; <span class="hljs-title">getObjectType</span>() {
        <span class="hljs-keyword">return</span> User.class;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span>() {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}</code></pre>



<pre class="prettyprint"><code class="language-xml hljs ">// 配置 
<span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"userfactory"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.UserFactory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span></code></pre>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//测试 </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        ApplicationContext ac=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        User user=(User) ac.getBean(<span class="hljs-string">"userfactory"</span>); 
        user.say();
    }
}<span class="hljs-javadoc">/**Output
        tom:14 
**/</span></code></pre>

<p>　　<font color="red"><b>当我们&lt;bean&gt;标签的class属性配置的类实现了FactoryBean接口时，通过getBean返回的就不是该类本身，而是getObject()方法所返回的对象，相当于getObject()方法代理了getBean()。</b></font></p>

<hr />



<h2 id="六-bean的生命周期">六. Bean的生命周期</h2>

<p>　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/1q4hobhntiqj0d538h6yr8tq/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Bean的生命周期.png-27.8kB" title="" /></p>

<p>步骤如下:</p>

<p>1)、实例化BeanFactoryPostProcessor，调用postProcessBeanFactory()方法对工厂定义信息进行后处理。</p>

<p>2)、调用者通过getBean向容器请求bean时，如果容器注册了InstantiationAwareBeanPostProcessor接口，在实例化Bean之前，会调用接口的postProcessBeforeInstantiation()方法。</p>

<p>3)、根据配置文件调用Bean的构造方法或者工厂方法实例化Bean。</p>

<p>4)、实例化Bean后，调用InstantiationAwareBeanPostProcessor接口的postProcessAfterInstantiation()方法，在这里可以对已经实例化的对象进行一些修饰。</p>

<p>5)、如果Bean配置了属性信息，在设置每个属性之前将先调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法。</p>

<p>6)、调用Bean的属性设置方法为Bean设置属性。</p>

<p>7)、如果Bean实现了BeanNameAware接口，会调用该接口的setBeanName()方法，将配置文件中该Bean对应的名称设置到Bean中。</p>

<p>8)、如果Bean实现了BeanFactoryAware接口，会调用该接口的setBeanFactory方法，将BeanFactory容器实例设置到Bean中。</p>

<p>9)、如果BeanFactory装配了BeanPostProcessor后处理器，将调用Object postProcessBeforeInitialization(Object bean,String beanName)方法对Bean进行加工操作，bean是当前处理的Bean，beanName是当前bean的配置名，返回的对象是加工处理后的Bean。用户可以使用该方法对Bean进行特殊处理。<font color="red"><b>BeanPostProcessor在Spring框架中占有重要地位，AOP等都通过该BeanPostProcessor实施。</b></font></p>

<p>10)、如果Bean实现了InitializingBean接口，会调用该接口的afterPropertiesSet()方法。</p>

<p>11)、如果&lt;bean&gt;中配置了init-method属性，执行指定的初始化方法。</p>

<p>12)、调用BeanPostProcessor后处理器的Object postProcessAfterInitialization(Object bean,String beanName)方法再次获得对Bean的加工处理机会。</p>

<p>13)、将Bean返回给调用者。</p>

<p>14)、当容器关闭时， 如果Bean实现了DisposableBean接口，调用接口的destory方法。</p>

<p>15)、如果&lt;bean&gt;设置了destory-method属性，执行指定的销毁方法。</p>

<hr />

<p><strong>1、生命周期中方法的划分</strong></p>

<p>　　Bean的完整生命周期从Spring容器着手实例化bean开始，直到销毁Bean。其中有很多关键的方法。  <br />
这些方法大致分为三类：</p>

<ul>
<li><p>Bean自身的方法：如Bean的构造方法，调用set方法设置属性，和init-method和destory-method指定的方法。</p></li>
<li><p>Bean的生命周期接口方法：如BeanNameAware、BeanFactoryAware、InitializingBean、DisposableBean等接口的方法由Bean自己直接实现</p></li>
<li><p>容器级生命周期接口方法：如InstantiationAwareBeanPostProcessor和BeanPostProcessor接口，一般称为后处理器。这些接口的实现类与Bean无关，直接装配到Spring容器中。当Spring容器创建任何Bean时，这些后处理器都会起作用。</p></li>
</ul>

<hr />

<p><strong>2、测试Bean生命周期的例子</strong></p>

<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//实现Bean级生命周期接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryAware</span>,<span class="hljs-title">BeanNameAware</span>,<span class="hljs-title">InitializingBean</span>,<span class="hljs-title">DisposableBean</span>{</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myinit</span>(){
        System.out.println(<span class="hljs-string">"初始化..."</span>); 
        name=<span class="hljs-string">"王五"</span>;
        age=<span class="hljs-number">55</span>;
    }  

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span>(){
        System.out.println(name+<span class="hljs-string">":"</span>+age);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mydestory</span>(){
        System.out.println(<span class="hljs-string">"销毁中..."</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>() <span class="hljs-keyword">throws</span> Exception {
        System.out.println(<span class="hljs-string">"听说我是最后被调用"</span>);

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span>() <span class="hljs-keyword">throws</span> Exception {
        System.out.println(<span class="hljs-string">"听说我是第三个被调用"</span>);

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span>(String arg0) {
        System.out.println(<span class="hljs-string">"听说我是第一个被调用"</span>);

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span>(BeanFactory arg0) <span class="hljs-keyword">throws</span> BeansException {
        System.out.println(<span class="hljs-string">"听说我是第二个被调用"</span>);

    }
}</code></pre>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!--我们在配置时配置init-method和destory-method属性来指定初始化和销毁的方法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"user"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.User"</span> <span class="hljs-attribute">init-method</span>=<span class="hljs-value">"myinit"</span> <span class="hljs-attribute">destroy-method</span>=<span class="hljs-value">"mydestory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span> </code></pre>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们进行测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        ClassPathXmlApplicationContext ac=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        User user=(User) ac.getBean(<span class="hljs-string">"user"</span>);  
        user.say();
        <span class="hljs-comment">//destory方法执行必须在容器关闭之后才能执行</span>
        ac.close();
    }
} </code></pre>

<p>　　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/528su4odxwy1w90qr549zxu4/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9E%9C1.png" alt="Bean的生命周期结果1.png-21.4kB" title="" /></p>

<hr />

<p><strong>3、装配后处理器</strong></p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//提供BeanPostProcessor的实现类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> {</span>

    <span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span>(Object arg0, String arg1) <span class="hljs-keyword">throws</span> BeansException {
        System.out.println(<span class="hljs-string">"后处理器：初始化方法之后执行"</span>);
        <span class="hljs-keyword">return</span> arg0;
    }

    <span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span>(Object arg0, String arg1) <span class="hljs-keyword">throws</span> BeansException {
        System.out.println(<span class="hljs-string">"后处理器：初始化方法之前执行"</span>);
        <span class="hljs-keyword">return</span> arg0;
    }

}</code></pre>



<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-comment">&lt;!--在配置文件中装配后处理器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"myBeanPostProcessor"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"com.cad.domain.MyBeanPostProcessor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span> </code></pre>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">// 我们进行测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> {</span>
    <span class="hljs-annotation">@org</span>.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        ClassPathXmlApplicationContext ac=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        User user=(User) ac.getBean(<span class="hljs-string">"user"</span>);  
        ac.close();
    }
} </code></pre>

<p>　　仔细观察输出结果，就会发现验证了我们说的Bean的生命周期过程:</p>

<p>　　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/dx2e18ro3ffgr70ib2w0gho6/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9E%9C2.png" alt="Bean的生命周期结果2.png-18.9kB" title="" /></p>

<hr />

<p><strong>4、关于Bean生命周期接口的一些问题</strong></p>

<p>　　通过实现Bean的生命周期接口对Bean进行额外的一些控制，虽然具有一些优点，但是带来了一个很严重的问题，我们的类必须实现这些接口，Bean和Spring紧密的结合在了一起，这就带来了很大的麻烦，所以，我们一般不使用这些接口，而是通过&lt;bean&gt;的init-method和destory-method属性来达到我们的初始化和销毁效果，达到框架解耦的问题。</p>

<p>　　此外，BeanPostProcessor接口是像插件一样注册到Spring容器中，使应用与框架解耦，同时可以为我们完成一些额外的功能。例如可以获取动态代理，还有实现AOP功能。</p>

<hr />

<blockquote>
  <h2 id="引用">引用</h2>
  
  <p><a href="http://blog.csdn.net/c99463904/article/details/73003558" target="_blank">Spring 深入浅出核心技术 (一)</a></p>
</blockquote></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
