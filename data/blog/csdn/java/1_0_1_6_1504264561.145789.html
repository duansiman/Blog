

<h1><span style="font-size:14px">首先来看一下C/C++中的引用</span></h1>&#13;
<p><span style="font-size:14px">从Java虚拟机创建的对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不会触发该引用指向的Java对象的垃圾回收</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">第一、局部引用：</span></p>&#13;
<p><span style="font-size:14px">最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用<strong>NewObject</strong>就会返回创建出来的实例的局部引用，局部引用只在该native函数中有效，所有在该函数中产生的局部引用，都会在函数返回的时候自动释放，也可以使用DeleteLocalRef函数手动释放该引用</span></p>&#13;
<p><span style="font-size:14px">想一想既然局部引用能够在函数返回时自动释放，为什么还需要<strong>DeleteLocalRef</strong>函数呢</span></p>&#13;
<p><span style="font-size:14px">实际上局部引用存在，就会防止其指向的对象被垃圾回收，尤其是当一个局部引用指向一个很庞大的对象，或是在一个循环中生成了局部引用，最好的做法就是在使用完该对象后，活在该循环尾部把这个引用释放掉，以确保在垃圾回收器被触发的时候被回收</span></p>&#13;
<p><span style="font-size:14px">在局部引用的有效期中，可以传递到别的本地函数中，要强调的是他的有效期任然只在一次的Java本地函数调用中，所以千万不能用C++全局变量保存他或是把他定义为C++静态局部变量</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">第二、全局引用</span></p>&#13;
<p><span style="font-size:14px">全局引用可以跨越当前线程，在多个native函数中有效，不过需要编程人员手动来释放该引用，全局引用存在期间会防止在Java的垃圾回收器的回收</span></p>&#13;
<p><span style="font-size:14px">与局部引用不同，全局引用的创建不是由JNI自动创建的，全局引用是需要调用<strong>NewGlobalRef</strong>函数，而释放他需要使用<strong>ReleaseGlobalRef</strong>函数</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">弱全局引用</span></p>&#13;
<p><span style="font-size:14px">Java1.2新出来的功能，与全局引用相似，创建和删除都需要由编程人员来进行，这种引用与全局引用一样可以在多个本地代码中有效，也跨越多线程有效，不一样的是，这种引用将不会阻止垃圾回收器回收这个引用所指向的对象</span></p>&#13;
<p><span style="font-size:14px">使用<strong>NewWeakGlobalRef</strong>和<strong>ReleaseWeakGlobalRef</strong>来产生和解除引用</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">关于引用的一个函数:</span></p>&#13;
<p><span style="font-size:14px"><strong>jobject NewGlobalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>jobject NewLocalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>jobject new WeakGlobalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>void DeleteGobalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>void DeleteLocalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>void DeleteWeakGlobalRef(jobject obj);</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>上述的六种方法很好理解的，这里就不做揭示了</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>jboolean IsSameObject(jobject obj1 , jobject obj2);</strong></span></p>&#13;
<p><span style="font-size:14px">这个函数就是用来比较两个引用是否相等，但是对于弱全局引用还有一个特别的功能，如果把NULL传入要比较的对象中，就能够判断弱全局引用所指向的Java对象是否被回收</span></p>&#13;
<h1><span style="font-size:14px">缓存jfieldID/jmethodID</span></h1>&#13;
<p><span style="font-size:14px">取得jfieldID和jmethodID的时候会通过该属性/方法名称加上签名来查询相应的jfieldID/jmethodID.这种查询相对于来说开销大，我们可以将这些FieldID/MethodID缓存起来，这样就需要查询一次，以后就是用缓存起来的FieldID/MethodID了</span></p>&#13;
<p><span style="font-size:14px">下面介绍两种缓存方法是：</span></p>&#13;
<p><span style="font-size:14px"><strong>1.在用的时候缓存</strong></span></p>&#13;
<p><span style="font-size:14px">在native code 中使用static 局部变量来保存已经查询过的id,这样就不会在每次的函数调用时查询，而只要第一次查询成功后就保存起来了</span></p>&#13;
<p><span style="font-size:14px">不过在这种情况下就不得不考虑多线程同时呼叫此函数时可能会招致同时查询的危机，不过这种情况是无害的，因为查询同一个属性/方法的ID通常返回的是一样的值</span></p>&#13;
<p><span style="font-size:14px"><img src="http://img.blog.csdn.net/20131229145531468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">在static jfieldID fieldID_string = NULL；这段代码只执行一次</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px"><strong>2.在Java类初始化时缓存</strong></span></p>&#13;
<p><span style="font-size:14px">更好的一个方式就是在任何native函数调用前把id全部存起来</span></p>&#13;
<p><span style="font-size:14px">我们可以让Java在第一次加载这个类的时候首先调用本地代码初始化所有的jfieldID/jmethodID,这样的话就可以省去多次的确定id是否存在的语句，当然，这些jfieldID/jmethodID是定义在C/C++的全局</span></p>&#13;
<p><span style="font-size:14px">使用这种方式还有好处，当Java类卸载或是从新加载的时候，也会重新呼叫该本地代码来从新计算IDs<img src="http://img.blog.csdn.net/20131229150129234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></span></p>&#13;
<p><span style="font-size:14px">在Java中使用静态代码块中进行初始化</span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">使用JNI中的两个弊端：</span></p>&#13;
<p><span style="font-size:14px"><strong>1.使用了JNI,那么这个Java Application将不能跨平台了，如果要移植到别的平台上，那么native代码就需要从新进行编写</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>2. Java是强类型语言，而C/C++不是，因此，你必须在写JNI的时候更加小心</strong></span></p>&#13;
<p><span style="font-size:14px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:14px">介绍两本资料：</span></p>&#13;
<p><span style="font-size:14px"><strong>The Java Native Interface Programmer's Guide and Specification<br />&#13;
</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>JNI++ User Guide</strong></span></p>&#13;
<p><span style="font-size:14px"><strong><br />&#13;
</strong></span></p>&#13;
<p><span style="font-size:14px"><strong>关于JNI的学习到此结束！</strong></span></p>&#13;
   &#13;
