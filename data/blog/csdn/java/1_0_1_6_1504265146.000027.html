
                
<p><span style="font-size:14px"/></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:center">&#13;
<span style="font-size:24px">要想正确理解设计模式，首先必须明确它是为了解决什么问题而提出来的。</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:center">&#13;
<span style="font-size:24px">设计模式学习笔记</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:right">&#13;
<span style="font-size:24px">——Shulin</span></p>&#13;
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:13.63636302947998px; line-height:25.99431800842285px; text-align:right">&#13;
<span style="font-size:24px">转载请注明出处：<a target="_blank" href="http://blog.csdn.net/zhshulin" style="color:rgb(202,0,0); text-decoration:none">http://blog.csdn.net/zhshulin</a></span></p>&#13;
       &#13;
<p><span style="font-size:14px"><br/>&#13;
</span></p>&#13;
<p><span style="font-size:14px">       单例模式属于设计模式中的<span style="background-color:rgb(255,255,0)">创建模式</span>，即</span><span style="font-size:14px">创建对象时，</span><span style="font-size:14px; color:rgb(0,0,255)">不再由我们直接实例化对象</span><span style="font-size:14px">，而是根据特定场景，由程序来确定创建对象的方式，从而保证更大的性能、更好的架构优势。</span></p>&#13;
<p><span style="font-size:14px"><br/>&#13;
</span></p>&#13;
<h2><span style="font-size:14px">1、概念</span></h2>&#13;
<p/>&#13;
<p style="font-size:14px">        单例模式<span style="background:rgb(255,255,0)">确保某个类只有一个实例</span>，而且自行实例化并向整个系统提供这个实例。选择单例模式就是为了<span style="background:rgb(255,255,0)">避免不一致状态。</span>使用<span style="font-family:Times New Roman">Singleton</span><span style="font-family:宋体">的好处还在于可以节省内存，因为它限制了实例的个数，有利于</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">垃圾回收（</span><span style="font-family:Times New Roman">garbage collection</span><span style="font-family:宋体">）。</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<p style="font-size:14px">       Singleton<span style="font-family:宋体">模式看起来简单，使用方法也很方便，但是真正用好，是非常不容易，需要对</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">的类 线程 内存等概念有相当的了解。</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<p style="font-size:14px">       总之：如果你的应用基于容器，那么<span style="font-family:Times New Roman">Singleton</span><span style="font-family:宋体">模式少用或者不用，可以使用相关替代技术。</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<h2><span style="font-family:宋体; font-size:14px">2、特点</span></h2>&#13;
<p><span style="font-family:宋体; font-size:14px">   </span><span style="font-size:14px"><span style="font-family:宋体">1）</span><span style="font-family:宋体">单例类只能有一个实例</span></span></p>&#13;
<p><span style="font-size:14px"><span style="font-family:宋体"/></span></p>&#13;
<p><span style="font-size:14px">     2）单例类必须自己创建自己的唯一实例</span></p>&#13;
<p><span style="font-size:14px">     3）单例类必须给所有其他对象提供这一实例</span></p>&#13;
<br/>&#13;
<h2><span style="font-family:宋体">3、应用举例</span></h2>&#13;
<p><span style="font-family:宋体"/></p>&#13;
<p style="font-size:14px">    在很多操作中，比如<span style="background:rgb(255,255,0)">建立目录、数据库连接</span>都需要这样的单线程操作。还有<span style="font-family:Times New Roman">, singleton</span><span style="font-family:宋体">能够被状态化</span><span style="font-family:Times New Roman">; </span><span style="font-family:宋体">这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要</span><span style="background:rgb(255,255,0)">论坛中的帖子计数器</span>，每次浏览一次需要计数，单态类能否保持住这个计数，并且能<span style="font-family:Times New Roman">synchronize</span><span style="font-family:宋体">的安全自动加</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。</span></p>&#13;
<p><span style="font-size:10px"> </span></p>&#13;
<p style="font-size:14px">    在计算机系统中，<span style="background:rgb(255,255,0)">线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象</span>常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个<span style="font-family:Times New Roman">Printer Spooler</span><span style="font-family:宋体">，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。</span></p>&#13;
<br/>&#13;
<h2><span style="font-family:宋体">4、实现</span></h2>&#13;
<p style="font-size:14px"><span style="font-family:宋体">    几种常见单例模式实现方法。<span style="background-color:rgb(255,255,0)">通用的单例模式创建思想</span>：</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><span style="white-space:pre"/>1）使用private修改该类构造器，从而将其隐藏起来，避免程序自由创建该类实例</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体">        2）提供一个public方法获取该类实例，且此方法必须使用static修饰（调用之前还不存在对象，因此只能用类调用）</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体">        3）该类必须缓存已经创建的对象，否则该类无法知道是否曾经创建过实例，也就无法保证只创建一个实例。为此，该类需要一个静态属性来保持曾经创建的实例。</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<h3><span style="font-family:宋体">4.1、饿汉模式</span></h3>&#13;
<p style="font-size:14px"><span style="font-family:宋体">基本结构：</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"/></p>&#13;
<pre code_snippet_id="450532" snippet_file_name="blog_20140814_1_3878997" name="code" class="java">public class EagerSingleton {
    private static EagerSingleton instance = new EagerSingleton();
    /**
     * 私有默认构造方法
     */
    private EagerSingleton(){}
    /**
     * 静态工厂方法
     */
    public static EagerSingleton getInstance(){
        return instance;
    }
}</pre><br/>&#13;
<p/>&#13;
<p>   饿汉式是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，于是在装载类的时候就创建对象实例。<span style="background-color:rgb(255,255,0)">饿汉式是典型的空间换时间</span>，当类装载的时候就会创建类的实例，<span style="color:#3333ff">不管你用不用，先创建出来</span>，然后每次调用的时候，就不需要再判断，节省了运行时间。</p>&#13;
<br/>&#13;
<p style="font-size:14px"><span style="font-family:宋体"><br/>&#13;
</span></p>&#13;
<h3><span style="font-family:宋体">4.2、懒汉模式</span></h3>&#13;
<p style="font-size:14px"><span style="font-family:宋体">基本结构：</span></p>&#13;
<p style="font-size:14px"><span style="font-family:宋体"/></p>&#13;
<pre code_snippet_id="450532" snippet_file_name="blog_20140814_2_1480209" name="code" class="java">package org.zsl.designmode;
/**
 * 懒汉式，需要的时候才创建，典型的时间换空间
 * @author ZSL
 *
 */
public class LazySingleton {
	//静态属性用来缓存创建实例
	private static LazySingleton instance = null;
	//私有构造方法避免程序自由创建实例
	private LazySingleton(){}
	//静态公共方法用于取得该类实例
	public static synchronized LazySingleton getLazySingletonInstance(){
		if(instance == null){
			instance = new LazySingleton();
		}
		return instance;
	}
}</pre>&#13;
<p/>&#13;
<p style="font-size:14px"><span style="font-family:宋体"/></p>&#13;
<p>    上面的懒汉式单例类实现里<span style="color:#ff0000">对静态工厂方法使用了同步化</span>，以处理多线程环境。</p>&#13;
<p><br/>&#13;
</p>&#13;
<p>    懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。</p>&#13;
<p> </p>&#13;
<p>　　<span style="background:rgb(255,255,0)">懒汉式是典型的时间换空间</span>,<span style="font-family:宋体">就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间</span></p>&#13;
<p> </p>&#13;
<p>　　由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？</p>&#13;
<br/>&#13;
<h3><span style="font-family:宋体">4.3、<span style="font-family:宋体; font-size:14px">双重检查加锁</span></span></h3>&#13;
<p style="font-size:14px"><span style="font-family:宋体"/></p>&#13;
<p>    可以使用“双重检查加锁”的方式来实现，就可以<span style="background-color:rgb(255,255,0)">既实现线程安全，又能够使性能不受很大的影响</span>。</p>&#13;
<p> </p>&#13;
<p>　　“双重检查加锁”指的是：并不是每次进入<span style="font-family:Times New Roman">getInstance</span><span style="font-family:宋体">方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</span></p>&#13;
<p> </p>&#13;
<p>　　“双重检查加锁”机制的实现会使用关键字<span style="background:rgb(255,255,0)">volatile</span>，它的意思是：被<span style="font-family:Times New Roman">volatile</span><span style="font-family:宋体">修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</span></p>&#13;
<p> </p>&#13;
<p><span style="color:rgb(255,0,0)">注意：在<span style="font-family:Times New Roman">java1.4</span><span style="font-family:宋体">及以前版本中，很多</span><span style="font-family:Times New Roman">JVM</span><span style="font-family:宋体">对于</span><span style="font-family:Times New Roman">volatile</span><span style="font-family:宋体">关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在</span><span style="font-family:Times New Roman">java5</span><span style="font-family:宋体">及以上的版本。</span></span></p>&#13;
<br/>&#13;
<p style="font-size:14px"><span style="font-family:宋体"/></p>&#13;
<pre code_snippet_id="450532" snippet_file_name="blog_20140814_3_9637045" name="code" class="java">package org.zsl.designmode;
/**
 * 双重检查加锁，既实现线程安全，又能够使性能不受很大的影响
 * @author ZSL
 *
 */
public class Singleton {
	//被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。
	private volatile static Singleton instance = null;
	//私有构造方法
	private Singleton(){};
	//公共静态方法获取实例
	public static Singleton getSingletonInstance(){
		if(instance == null){	//先检查实例是否存在，不存在，在进行同步
			synchronized (Singleton.class) {	//同步块，线程安全的创建实例
				if(instance == null){	//再次检查实例是否存在，如果不存在才真正的创建实例
					instance = new Singleton();
				}
			}
			
		}
		return instance;
	}
	
}
</pre><br/>&#13;
<p/>&#13;
<p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。</p>&#13;
<p> </p>&#13;
<p>　　<span style="background:rgb(255,255,0)">提示：由于<span style="font-family:Times New Roman">volatile</span><span style="font-family:宋体">关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。</span></span>因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并<span style="background:rgb(255,255,0)">不建议大量采用</span>，可以根据情况来选用。</p>&#13;
<br/>&#13;
<p style="text-align:center"><span style="font-size:18px; color:#ff0000">（原文地址：<a target="_blank" href="http://blog.csdn.net/zhshulin">http://blog.csdn.net/zhshulin</a>）</span></p>&#13;
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0"/>&#13;
            