

<p>原型模式也是一种创建型模式， 只不过他创建的对象是通过克隆来实现。为什么要通过克隆而不是new呢？</p>&#13;
<p>举个例子：比如一个对象的创建需要读取本地文件（Excel）中的信息，而且需要读很多个excel的信息<br />&#13;
才能创建成功。这时候创建一个对象的成本是很高的。如果每次都new的话是行不通的。这时候原型模式就</p>&#13;
<p>派上用场了。我们不重新new一个对象，而是通过之前的对象进行克隆一个。</p>&#13;
<p>看代码：</p>&#13;
<pre class="java" name="code">package com.pattern.build.prototype;

public abstract class Prototype {

	protected String name;
	public abstract Prototype copy();
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	
}
</pre>&#13;
<p><br />&#13;
</p>&#13;
<pre class="java" name="code">package com.pattern.build.prototype;

public class ConcretePrototype extends Prototype {

	@Override
	public Prototype copy() {
		ConcretePrototype cp = new ConcretePrototype();
		cp.setName(this.getName());
		return cp;
	}

	
	
	
}
</pre>&#13;
<p><br />&#13;
 </p>&#13;
<pre class="java" name="code">package com.pattern.build.prototype;


public class Client {

	public static void main(String[] args) {
		Prototype p = new ConcretePrototype();
		
		p.setName("aaa");
		
		Prototype copy = p.copy();
		System.out.println(copy.getName());
		
		
	}

}
</pre>&#13;
<p>对象拷贝分为浅拷贝和深拷贝。</p>&#13;
<p>浅拷贝：<br />&#13;
至拷贝值，不拷贝引用。如果一个对象包含梁一个对象的引用，那么此引用是不会被拷贝（拷贝前后都是指向同一块内存）。</p>&#13;
<p>深拷贝：<br />&#13;
即拷贝值，也拷贝引用。可以利用序列化实现深拷贝。</p>&#13;
<p>java的Object对象中有clone这个方法。也就是所有的类的对象都有clone方法。但是如果这个类没有实现Cloneable</p>&#13;
<p>接口，调用clone方法的时候就会抛出CloneNotSupportedException异常。</p>&#13;
<p><br />&#13;
 </p>&#13;
   &#13;
