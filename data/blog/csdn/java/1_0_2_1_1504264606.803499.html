

<p>类图</p>&#13;
<p><img src="http://img.blog.csdn.net/20141014153155221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamp3d21scDQ1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="536" height="347" alt="" /><br />&#13;
</p>&#13;
<p></p><pre name="code" class="java">public interface IMediator {

	public void createMediator();

	public void work();
}
</pre><br />&#13;
<pre name="code" class="java">/**
 * 中介、调节实际上需要交互的两个元素，让其松耦合
 * @author stone
 *
 */
public class Mediator implements IMediator {
	
	private XmlCode xmlCode;
	private XmlPreview xmlPreview;
	
	@Override
	public void createMediator() {
		this.xmlCode = new XmlCode();
		this.xmlPreview = new XmlPreview();
	}

	@Override
	public void work() {
		this.xmlCode.work();
		this.xmlPreview.work();
	}

}
</pre><pre name="code" class="java">public interface IWork {
	void work();
}</pre><pre name="code" class="java">/**
 * 本类描述Android布局里的 预览界面
 * 在预览界面中拖拽组件，代码会变化
 * @author stone
 *
 */
public class XmlPreview implements IWork {

	@Override
	public void work() {
		System.out.println("预览里的组件变化了");
	}

}</pre><pre name="code" class="java">/**
 * 本类描述Android布局里的 xml代码
 * 加入了代码，预览界面会变化
 * @author stone
 *
 */
public class XmlCode implements IWork {

	@Override
	public void work() {
		System.out.println("加入布局代码");
	}


}</pre><pre name="code" class="java">/*
 * 中介者(Mediator)模式 	Mediator的意思是中介者、调节者、传递物,顾名思义,这个模式在程式中必然负担一个中介、调节、传递的工作
 * 中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互
 */
public class Test {
	public static void main(String[] args) {
		IMediator mediator = new Mediator();
		mediator.createMediator();//内部创建元素，维护元素
		mediator.work();//执行内部元素的work接口
	}
}
</pre><br />&#13;
打印&#13;
<p></p><pre name="code" class="plain">加入布局代码
预览里的组件变化了</pre><br />&#13;
<br />&#13;
<br />&#13;
&#13;
   &#13;
