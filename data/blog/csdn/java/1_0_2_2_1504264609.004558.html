

<pre code_snippet_id="484163" snippet_file_name="blog_20141014_1_5817968" name="code" class="java">/**
 * 声明一个抽象的解释操作
 * @author stone
 *
 */
public interface Interpreter {
	
	public void interpret(Context context);  //实际中，可以有个返回的类型，定义解释出的数据对象
}
</pre><pre code_snippet_id="484163" snippet_file_name="blog_20141014_2_3767844" name="code" class="java">public class XmlSaxInterpreter implements Interpreter {

	@Override
	public void interpret(Context context) {
		System.out.println("xml sax Interpreter:" + context.getData());
	}

}</pre><pre code_snippet_id="484163" snippet_file_name="blog_20141014_3_6941190" name="code" class="java">public class XmlDomInterpreter implements Interpreter {

	@Override
	public void interpret(Context context) {
		System.out.println("xml dom Interpreter:" + context.getData());
	}

}
</pre><pre code_snippet_id="484163" snippet_file_name="blog_20141014_4_7781005" name="code" class="java">/**
 * 包含解释器之外的一些信息
 * @author stone
 *
 */
public class Context {
	private String data;
	
	public String getData() {
		return data;
	}
	
	public void setData(String data) {
		this.data = data;
	}
}</pre><br />&#13;
<pre code_snippet_id="484163" snippet_file_name="blog_20141014_5_3113943" name="code" class="java">/*
 * 解释器(Interpreter)模式
 * 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。 属于行为型模式
 * 应用场合，如编译器、正则表达式、语言规范...
 * 解释器模式在实际的系统开发中使用的非常少，因为它会引起效率、性能以及维护等问题，
 */
public class Test {
	public static void main(String[] args) {
		Context context = new Context();
		context.setData("一段xml数据");
		new XmlSaxInterpreter().interpret(context);
		new XmlDomInterpreter().interpret(context);
	}
}</pre><br />&#13;
<br />&#13;
<br />&#13;
   &#13;
