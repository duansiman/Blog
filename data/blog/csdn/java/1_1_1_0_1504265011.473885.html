

<p style="margin:0in; font-size:14pt"><span lang="en-US" style="font-family:Calibri" xml:lang="en-US">java</span><span lang="zh-CN" style="font-family:华文楷体" xml:lang="zh-CN">中的流按照不同的方式，可以有不同的分类标准</span><span lang="en-US" style="font-family:Calibri" xml:lang="en-US"> </span><span lang="zh-CN" style="font-family:华文楷体" xml:lang="zh-CN">。</span></p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">但还是有基本的公有方法，读，写，关闭，缓冲等。</p>&#13;
<p style="margin:0in"><br />&#13;
</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> <img src="http://img.blog.csdn.net/20140225154543828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3lhbmt1bjIwMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">不同的标准有不同的类型。</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">按照功能分配，有节点和处理。节点和处理流中又可以有字符和字节流的处理方法。所以说要分的很清楚是不可能的、</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">不同的数据流之间要进行数据的转换和交流。其中嵌套是难免的。下面看实例</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">数据流的处理</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"></p>&#13;
<pre code_snippet_id="204110" snippet_file_name="blog_20140225_1_2608168" name="code" class="java">import java.io.*;
public classTestDataStream {
  public static void main(String[] args) {
    ByteArrayOutputStream baos =
                        newByteArrayOutputStream();
    DataOutputStream dos =
                        newDataOutputStream(baos);
    try {
      dos.writeDouble(Math.random());
      dos.writeBoolean(true);
      ByteArrayInputStream bais =
          newByteArrayInputStream(baos.toByteArray());
      System.out.println(bais.available());
      DataInputStream dis = newDataInputStream(bais);
      System.out.println(dis.readDouble());
      System.out.println(dis.readBoolean());
      dos.close();  dis.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}</pre><br />&#13;
<br />&#13;
<p></p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt">该实例是用数据流套结在字节流上，进行对数据更强大的读写功能。处理已存在的流。这就是处理流的作用。</p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
<p style="margin:0in; font-family:&#x534E;&#x6587;&#x6977;&#x4F53;; font-size:14pt"> </p>&#13;
   &#13;
