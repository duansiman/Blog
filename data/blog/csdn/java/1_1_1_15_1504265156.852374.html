
                
这里将介绍Java环境下Memcached应用，Memcached主要是集群环境下的缓存解决方案.
<div>&#13;
<div><span/></div>&#13;
<p>　　本文将对在Java环境下Memcached应用进行详细介绍。Memcached主要是集群环境下的缓存解决方案，可以运行在Java或者<a href="http://whatis.ctocio.com.cn/searchwhatis/261/5949261.shtml" rel="nofollow" target="_blank"><strong><span><span style="color:#4466bb">.NET</span></span></strong></a>平台上，这里我们主要讲的是Windows下的Memcached应用。</p>&#13;
<p>　　提供了一个缓存工具类，在配置文件中配置使用哪种缓存(memcached或ehcached)，使其它程序对具体的缓存不依赖，同时使用AOP方式来对方法执行结果进行缓存。</p>&#13;
<p>　　首先是工具类的实现： </p>&#13;
<p>　　在Spring中配置 </p>&#13;
<p>　　Java代码 </p>&#13;
<span><span/></span>&#13;
<table border="0" cellspacing="0" cellpadding="6" align="center">&#13;
<tbody>&#13;
<tr>&#13;
<td><span/><br/>&#13;
&lt;bean id="cacheManager"      <br/>&#13;
<a href="http://whatis.ctocio.com.cn/searchwhatis/213/5947213.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">class</span></span></a>="<a href="http://whatis.ctocio.com.cn/searchwhatis/20/6093020.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">org</span></span></a>.springframework.<a href="http://whatis.ctocio.com.cn/searchwhatis/459/5946959.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">cache</span></span></a>.ehcache.EhCacheManagerFactoryBean"&gt;      <br/>&#13;
&lt;property name="configLocation"&gt;       <br/>&#13;
&lt;value&gt;classpath:ehcache.xmlvalue&gt;       <br/>&#13;
property&gt;       <br/>&#13;
bean&gt;       <br/>&#13;
  <br/>&#13;
&lt;bean id="localCache"      <br/>&#13;
class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt;       <br/>&#13;
&lt;property name="cacheManager" ref="cacheManager" /&gt;       <br/>&#13;
&lt;property name="cacheName"      <br/>&#13;
value="×××.cache.LOCAL_CACHE" /&gt;       <br/>&#13;
bean&gt;       <br/>&#13;
  <br/>&#13;
&lt;bean id="cacheService"      <br/>&#13;
class="×××.core.cache.CacheService" init-<a href="http://whatis.ctocio.com.cn/searchwhatis/229/5948729.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">method</span></span></a>="init" destroy-method="destory"&gt;      <br/>&#13;
&lt;property name="cacheServerList" value="${cache.servers}"/&gt;       <br/>&#13;
&lt;property name="cacheServerWeights" value="${cache.cacheServerWeights}"/&gt;       <br/>&#13;
&lt;property name="cacheCluster" value="${cache.<a href="http://whatis.ctocio.com.cn/searchwhatis/247/5947247.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">cluster</span></span></a>}"/&gt;      <br/>&#13;
&lt;property name="localCache" ref="localCache"/&gt;       <br/>&#13;
bean&gt;      <br/>&#13;
   <br/>&#13;
&lt;bean id="cacheManager"   <br/>&#13;
class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt;   <br/>&#13;
&lt;property name="configLocation"&gt;   <br/>&#13;
&lt;value&gt;classpath:ehcache.xmlvalue&gt;   <br/>&#13;
property&gt;   <br/>&#13;
bean&gt;   <br/>&#13;
&lt;bean id="localCache"   <br/>&#13;
class="org.springframework.cache.ehcache.EhCacheFactoryBean"&gt;   <br/>&#13;
&lt;property name="cacheManager" ref="cacheManager" /&gt;   <br/>&#13;
&lt;property name="cacheName"   <br/>&#13;
value="×××.cache.LOCAL_CACHE" /&gt;   <br/>&#13;
bean&gt;   <br/>&#13;
  <br/>&#13;
&lt;bean id="cacheService"   <br/>&#13;
class="×××.core.cache.CacheService" init-method="init" destroy-method="destory"&gt;  <br/>&#13;
&lt;property name="cacheServerList" value="${cache.servers}"/&gt;   <br/>&#13;
&lt;property name="cacheServerWeights" value="${cache.cacheServerWeights}"/&gt;   <br/>&#13;
&lt;property name="cacheCluster" value="${cache.cluster}"/&gt;   <br/>&#13;
&lt;property name="localCache" ref="localCache"/&gt;   <br/>&#13;
bean&gt; </td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p>　　在properties文件中配置${cache.servers} ${cache.cacheServerWeights} ${cache.cluster}</p>&#13;
<p>　　具体工具类的代码 </p>&#13;
<p>　　Java代码 </p>&#13;
<span/>&#13;
<table border="0" cellspacing="0" cellpadding="6" align="center">&#13;
<tbody>&#13;
<tr>&#13;
<td><span/><br/>&#13;
/**     <br/>&#13;
* @author Marc     <br/>&#13;
*      <br/>&#13;
*/      <br/>&#13;
public class CacheService {       <br/>&#13;
private Log logger = LogFactory.getLog(getClass());       <br/>&#13;
private Cache localCache;       <br/>&#13;
<a href="http://whatis.ctocio.com.cn/searchwhatis/400/6026400.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">String</span></span></a> cacheServerList;      <br/>&#13;
String cacheServerWeights;       <br/>&#13;
boolean cacheCluster = false;       <br/>&#13;
<a href="http://whatis.ctocio.com.cn/searchwhatis/69/6025569.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">int</span></span></a> initialConnections = 10;      <br/>&#13;
int minSpareConnections = 5;       <br/>&#13;
int maxSpareConnections = 50;       <br/>&#13;
long maxIdleTime = 1000 * 60 * 30; // 30 minutes      <br/>&#13;
long maxBusyTime = 1000 * 60 * 5; // 5 minutes      <br/>&#13;
long maintThreadSleep = 1000 * 5; // 5 seconds      <br/>&#13;
int socketTimeOut = 1000 * 3; // 3 seconds to block on reads      <br/>&#13;
int socketConnectTO = 1000 * 3; // 3 seconds to block on initial      <br/>&#13;
// connections. If 0, then will use blocking      <br/>&#13;
// connect (default)      <br/>&#13;
boolean failover = false; // turn off auto-failover in event of server      <br/>&#13;
// down      <br/>&#13;
boolean nagleAlg = false; // turn off Nagle's <a href="http://whatis.ctocio.com.cn/searchwhatis/146/6025146.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">algorithm</span></span></a> on all sockets in     <br/>&#13;
// pool      <br/>&#13;
MemCachedClient mc;       <br/>&#13;
public CacheService(){       <br/>&#13;
mc = new MemCachedClient();       <br/>&#13;
mc.setCompressEnable(false);       <br/>&#13;
}       <br/>&#13;
/**     <br/>&#13;
* 放入     <br/>&#13;
*      <br/>&#13;
*/      <br/>&#13;
public void put(String <a href="http://whatis.ctocio.com.cn/searchwhatis/25/5948525.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">key</span></span></a>, <a href="http://whatis.ctocio.com.cn/searchwhatis/330/6025830.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">Object</span></span></a> obj) {      <br/>&#13;
Assert.hasText(key);       <br/>&#13;
Assert.notNull(obj);       <br/>&#13;
Assert.notNull(localCache);       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
mc.<a href="http://whatis.ctocio.com.cn/searchwhatis/23/5949023.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">set</span></span></a>(key, obj);      <br/>&#13;
} else {       <br/>&#13;
<a href="http://whatis.ctocio.com.cn/searchwhatis/325/5947825.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">Element</span></span></a> element = new Element(key, (Serializable) obj);      <br/>&#13;
localCache.put(element);       <br/>&#13;
}       <br/>&#13;
}       <br/>&#13;
/**     <br/>&#13;
* 删除      <br/>&#13;
*/      <br/>&#13;
public void remove(String key){       <br/>&#13;
Assert.hasText(key);       <br/>&#13;
Assert.notNull(localCache);       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
mc.delete(key);       <br/>&#13;
}else{       <br/>&#13;
localCache.remove(key);       <br/>&#13;
}       <br/>&#13;
}       <br/>&#13;
/**     <br/>&#13;
* 得到     <br/>&#13;
*/      <br/>&#13;
public Object get(String key) {       <br/>&#13;
Assert.hasText(key);       <br/>&#13;
Assert.notNull(localCache);       <br/>&#13;
Object rt = null;       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
rt = mc.get(key);       <br/>&#13;
} else {       <br/>&#13;
Element element = null;       <br/>&#13;
try {       <br/>&#13;
element = localCache.get(key);       <br/>&#13;
} catch (CacheException cacheException) {       <br/>&#13;
throw new DataRetrievalFailureException("Cache failure: "      <br/>&#13;
+ cacheException.getMessage());       <br/>&#13;
}       <br/>&#13;
if(element != null)       <br/>&#13;
rt = element.getValue();       <br/>&#13;
}       <br/>&#13;
return rt;       <br/>&#13;
}       <br/>&#13;
/**     <br/>&#13;
* 判断是否存在     <br/>&#13;
*      <br/>&#13;
*/      <br/>&#13;
public boolean exist(String key){       <br/>&#13;
Assert.hasText(key);       <br/>&#13;
Assert.notNull(localCache);       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
return mc.keyExists(key);       <br/>&#13;
}else{       <br/>&#13;
return this.localCache.isKeyInCache(key);       <br/>&#13;
}       <br/>&#13;
}       <br/>&#13;
private void init() {       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
String[] serverlist = cacheServerList.split(",");       <br/>&#13;
<a href="http://whatis.ctocio.com.cn/searchwhatis/70/6025570.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">Integer</span></span></a>[] weights = this.split(cacheServerWeights);      <br/>&#13;
// initialize the pool for memcache servers      <br/>&#13;
SockIOPool pool = SockIOPool.getInstance();       <br/>&#13;
pool.setServers(serverlist);       <br/>&#13;
pool.setWeights(weights);       <br/>&#13;
pool.setInitConn(initialConnections);       <br/>&#13;
pool.setMinConn(minSpareConnections);       <br/>&#13;
pool.setMaxConn(maxSpareConnections);       <br/>&#13;
pool.setMaxIdle(maxIdleTime);       <br/>&#13;
pool.setMaxBusyTime(maxBusyTime);       <br/>&#13;
pool.setMaintSleep(maintThreadSleep);       <br/>&#13;
pool.setSocketTO(socketTimeOut);       <br/>&#13;
pool.setSocketConnectTO(socketConnectTO);       <br/>&#13;
pool.setNagle(nagleAlg);       <br/>&#13;
pool.setHashingAlg(SockIOPool.NEW_COMPAT_HASH);       <br/>&#13;
pool.initialize();       <br/>&#13;
logger.info("初始化memcached pool!");       <br/>&#13;
}       <br/>&#13;
}       <br/>&#13;
  <br/>&#13;
private void destory() {       <br/>&#13;
if (this.cacheCluster) {       <br/>&#13;
SockIOPool.getInstance().shutDown();       <br/>&#13;
}       <br/>&#13;
}       <br/>&#13;
}      <br/>&#13;
/**    <br/>&#13;
* @author Marc    <br/>&#13;
*     <br/>&#13;
*/   <br/>&#13;
public class CacheService {    <br/>&#13;
private Log logger = LogFactory.getLog(getClass());    <br/>&#13;
private Cache localCache;    <br/>&#13;
String cacheServerList;    <br/>&#13;
String cacheServerWeights;    <br/>&#13;
boolean cacheCluster = false;    <br/>&#13;
int initialConnections = 10;    <br/>&#13;
int minSpareConnections = 5;    <br/>&#13;
int maxSpareConnections = 50;    <br/>&#13;
long maxIdleTime = 1000 * 60 * 30; // 30 minutes    <br/>&#13;
long maxBusyTime = 1000 * 60 * 5; // 5 minutes    <br/>&#13;
long maintThreadSleep = 1000 * 5; // 5 seconds    <br/>&#13;
int socketTimeOut = 1000 * 3; // 3 seconds to block on reads    <br/>&#13;
int socketConnectTO = 1000 * 3; // 3 seconds to block on initial    <br/>&#13;
// connections. If 0, then will use blocking    <br/>&#13;
// connect (default)    <br/>&#13;
boolean failover = false; // turn off auto-failover in event of server    <br/>&#13;
// down    <br/>&#13;
boolean nagleAlg = false; // turn off Nagle's algorithm on all sockets in    <br/>&#13;
// pool    <br/>&#13;
MemCachedClient mc;    <br/>&#13;
public CacheService(){    <br/>&#13;
mc = new MemCachedClient();    <br/>&#13;
mc.setCompressEnable(false);    <br/>&#13;
}    <br/>&#13;
/**    <br/>&#13;
* 放入    <br/>&#13;
*     <br/>&#13;
*/   <br/>&#13;
public void put(String key, Object obj) {    <br/>&#13;
Assert.hasText(key);    <br/>&#13;
Assert.notNull(obj);    <br/>&#13;
Assert.notNull(localCache);    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
mc.set(key, obj);    <br/>&#13;
} else {    <br/>&#13;
Element element = new Element(key, (Serializable) obj);    <br/>&#13;
localCache.put(element);    <br/>&#13;
}    <br/>&#13;
}    <br/>&#13;
/**    <br/>&#13;
* 删除     <br/>&#13;
*/   <br/>&#13;
public void remove(String key){    <br/>&#13;
Assert.hasText(key);    <br/>&#13;
Assert.notNull(localCache);    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
mc.delete(key);    <br/>&#13;
}else{    <br/>&#13;
localCache.remove(key);    <br/>&#13;
}    <br/>&#13;
}    <br/>&#13;
/**    <br/>&#13;
* 得到    <br/>&#13;
*/   <br/>&#13;
public Object get(String key) {    <br/>&#13;
Assert.hasText(key);    <br/>&#13;
Assert.notNull(localCache);    <br/>&#13;
Object rt = null;    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
rt = mc.get(key);    <br/>&#13;
} else {    <br/>&#13;
Element element = null;    <br/>&#13;
try {    <br/>&#13;
element = localCache.get(key);    <br/>&#13;
} catch (CacheException cacheException) {    <br/>&#13;
throw new DataRetrievalFailureException("Cache failure: "   <br/>&#13;
+ cacheException.getMessage());    <br/>&#13;
}    <br/>&#13;
if(element != null)    <br/>&#13;
rt = element.getValue();    <br/>&#13;
}    <br/>&#13;
return rt;    <br/>&#13;
}    <br/>&#13;
/**    <br/>&#13;
* 判断是否存在    <br/>&#13;
*     <br/>&#13;
*/   <br/>&#13;
public boolean exist(String key){    <br/>&#13;
Assert.hasText(key);    <br/>&#13;
Assert.notNull(localCache);    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
return mc.keyExists(key);    <br/>&#13;
}else{    <br/>&#13;
return this.localCache.isKeyInCache(key);    <br/>&#13;
}    <br/>&#13;
}    <br/>&#13;
private void init() {    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
String[] serverlist = cacheServerList.split(",");    <br/>&#13;
Integer[] weights = this.split(cacheServerWeights);    <br/>&#13;
// initialize the pool for memcache servers    <br/>&#13;
SockIOPool pool = SockIOPool.getInstance();    <br/>&#13;
pool.setServers(serverlist);    <br/>&#13;
pool.setWeights(weights);    <br/>&#13;
pool.setInitConn(initialConnections);    <br/>&#13;
pool.setMinConn(minSpareConnections);    <br/>&#13;
pool.setMaxConn(maxSpareConnections);    <br/>&#13;
pool.setMaxIdle(maxIdleTime);    <br/>&#13;
pool.setMaxBusyTime(maxBusyTime);    <br/>&#13;
pool.setMaintSleep(maintThreadSleep);    <br/>&#13;
pool.setSocketTO(socketTimeOut);    <br/>&#13;
pool.setSocketConnectTO(socketConnectTO);    <br/>&#13;
pool.setNagle(nagleAlg);    <br/>&#13;
pool.setHashingAlg(SockIOPool.NEW_COMPAT_HASH);    <br/>&#13;
pool.initialize();    <br/>&#13;
logger.info("初始化memcachedpool!");    <br/>&#13;
}    <br/>&#13;
}    <br/>&#13;
private void destory() {    <br/>&#13;
if (this.cacheCluster) {    <br/>&#13;
SockIOPool.getInstance().shutDown();    <br/>&#13;
}    <br/>&#13;
}    <br/>&#13;
} </td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p>　　然后实现函数的AOP拦截类，用来在函数执行前返回缓存内容 </p>&#13;
<p>　　Java代码 </p>&#13;
<span/>&#13;
<table border="0" cellspacing="0" cellpadding="6" align="center">&#13;
<tbody>&#13;
<tr>&#13;
<td><span/><br/>&#13;
public class CachingInterceptor implements MethodInterceptor {       <br/>&#13;
  <br/>&#13;
private CacheService cacheService;       <br/>&#13;
private String cacheKey;       <br/>&#13;
  <br/>&#13;
public void setCacheKey(String cacheKey) {       <br/>&#13;
this.cacheKey = cacheKey;       <br/>&#13;
}       <br/>&#13;
  <br/>&#13;
public void setCacheService(CacheService cacheService) {       <br/>&#13;
this.cacheService = cacheService;       <br/>&#13;
}       <br/>&#13;
  <br/>&#13;
public Object invoke(MethodInvocation invocation) throws Throwable {       <br/>&#13;
Object result = cacheService.get(cacheKey);       <br/>&#13;
//如果函数返回结果不在Cache中,执行函数并将结果放入Cache      <br/>&#13;
if (result == null) {       <br/>&#13;
result = invocation.proceed();       <br/>&#13;
cacheService.put(cacheKey,result);       <br/>&#13;
}       <br/>&#13;
return result;       <br/>&#13;
}       <br/>&#13;
}      <br/>&#13;
public class CachingInterceptor implements MethodInterceptor {    <br/>&#13;
  <br/>&#13;
private CacheService cacheService;    <br/>&#13;
private String cacheKey;    <br/>&#13;
  <br/>&#13;
public void setCacheKey(String cacheKey) {    <br/>&#13;
this.cacheKey = cacheKey;    <br/>&#13;
}    <br/>&#13;
  <br/>&#13;
public void setCacheService(CacheService cacheService) {    <br/>&#13;
this.cacheService = cacheService;    <br/>&#13;
}    <br/>&#13;
  <br/>&#13;
public Object invoke(MethodInvocation invocation) throws Throwable {    <br/>&#13;
Object result = cacheService.get(cacheKey);    <br/>&#13;
//如果函数返回结果不在Cache中,执行函数并将结果放入Cache    <br/>&#13;
if (result == null) {    <br/>&#13;
result = invocation.proceed();    <br/>&#13;
cacheService.put(cacheKey,result);    <br/>&#13;
}    <br/>&#13;
return result;    <br/>&#13;
}    <br/>&#13;
} </td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p>　　Spring的AOP配置如下： </p>&#13;
<p>　　Java代码 </p>&#13;
<table border="0" cellspacing="0" cellpadding="6" align="center">&#13;
<tbody>&#13;
<tr>&#13;
<td><span/><br/>&#13;
&lt;aop:config <a href="http://whatis.ctocio.com.cn/searchwhatis/351/6026351.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">proxy</span></span></a>-target-class="true"&gt;      <br/>&#13;
&lt;aop:advisor       <br/>&#13;
pointcut="execution(* ×××.PoiService.getOne(..))"      <br/>&#13;
advic<a href="http://whatis.ctocio.com.cn/searchwhatis/246/5947746.shtml" rel="nofollow" target="_blank"><span><span style="color:#4466bb">e-</span></span></a>ref="PoiServiceCachingAdvice" /&gt;      <br/>&#13;
aop:config&gt;       <br/>&#13;
  <br/>&#13;
&lt;bean id="BasPoiServiceCachingAdvice"      <br/>&#13;
class="×××.core.cache.CachingInterceptor"&gt;       <br/>&#13;
&lt;property name="cacheKey" value="PoiService" /&gt;       <br/>&#13;
&lt;property name="cacheService" ref="cacheService" /&gt;       <br/>&#13;
bean&gt;  </td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<div/>&#13;
<div/>&#13;
<div>&#13;
<div>&#13;
<p><span/>  </p>&#13;
</div>&#13;
</div>&#13;
<link rel="stylesheet" href="http://static.blog.csdn.net/public/res-min/markdown_views.css?v=1.0"/>&#13;
            