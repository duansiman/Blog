

<p align="left"><span style="font-size:18px">转载请注明出处：http://blog.csdn.net/supera_li/article/details/45034203 <br />&#13;
</span></p>&#13;
<p align="left"><span style="font-size:18px"><span style="font-size:18px">Effective java系列<br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/44940277&quot;打开连接&quot;">1.Effective java经验之谈，创建和销毁对象</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45064081">2.Effective java经验之谈，泛型</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/44940563">3.Effective java经验之谈，类与接口</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45034203">4.Effective java经验之谈，通用方法</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45155857">5.Effective java经验之谈，枚举，注解，方法，通用设计，异常</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45198341">6.Effective java经验之谈，并发编程</a></span><br />&#13;
</span></p>&#13;
<p align="left"><span style="font-size:18px">       对于通用方法，其实应用的场景是比较多的，我们在写一个类的时候，就要考虑是否要编写该方法的通用方法。这使得我们为以后该类的扩展性与使用方面提供很大的便利。</span><br />&#13;
</p>&#13;
<p align="left"><span style="font-size:18px">1.      <strong>覆盖equals时请遵守通用约定</strong>。自反性，对称性，传递性，一致性，非空性。编写子类equals的方法的时候，可以考虑是否可以用复合，不使用继承来解决问题。Instanceof进行参数检测，如果参数null，也将返回false。</span></p>&#13;
<p align="left"><span style="font-size:18px">2.      <strong>覆盖equals时总要覆盖hashCode。</strong></span></p>&#13;
<p align="left"><span style="font-size:18px">       1.对象属性不变化，返回的hashcode永远相等。</span></p>&#13;
<p align="left"><span style="font-size:18px">       2.如果对象通过equals方法比较是相等的，那么调用这两个对象中任意一个对象的hashcode产生同样的结果</span></p>&#13;
<p align="left"><span style="font-size:18px">       3.对象的equals方法比较不相等，这两个对象任意的hashcode不一样</span></p>&#13;
<p align="left"><span style="font-size:18px"><strong>       设计equals()</strong></span></p>&#13;
<p align="left"><span style="font-size:18px">       [1]使用instanceof操作符检查“实参是否为正确的类型”。</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2]对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2.1]对于非float和double类型的原语类型域，使用==比较；</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2.2]对于对象引用域，递归调用equals方法；</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2.3]对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2.4]对于double域，使用Double.doubleToLongBits(adouble)转换为int，再使用==比较；</span></p>&#13;
<p align="left"><span style="font-size:18px">       [2.5]对于数组域，调用Arrays.equals方法。</span></p>&#13;
<p align="left"><span style="font-size:18px"><strong>      设计hashCode()</strong></span></p>&#13;
<p align="left"><span style="font-size:18px">      [1]把某个非零常数值，例如17，保存在int变量result中；</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2]对于对象中每一个关键域f（指equals方法中考虑的每一个域）：</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.1]boolean型，计算(f ? 0 : 1);</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.2]byte,char,short型，计算(int);</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.3]long型，计算(int) (f ^ (f&gt;&gt;&gt;32));</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.4]float型，计算Float.floatToIntBits(afloat);</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.5]double型，计算Double.doubleToLongBits(adouble)得到一个long，再[2.3];</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.6]对象引用，递归调用它的hashCode方法;</span></p>&#13;
<p align="left"><span style="font-size:18px">      [2.7]数组域，对其中每个元素调用它的hashCode方法。</span></p>&#13;
<p align="left"><span style="font-size:18px">      [3]将上面计算得到的散列码保存到int变量c，然后执行 result=37*result+c;</span></p>&#13;
<p align="left"><span style="font-size:18px">      [4]返回result。</span></p>&#13;
<p align="left"><span style="font-size:18px"><strong> 3.始终要覆盖toString方法。</strong>只有覆盖这个方法，其他例如Arrays.toString()，以及集合类的toString。当你某一个调用该类输出的时候，就会调用该类已经实现的toString。</span></p>&#13;
<p align="left"><span style="font-size:18px"><strong>4．谨慎的调用clone方法。</strong>当你为一个继承而设计的类的时候，如果无法提供安全受保护的clone，那么子类就不可能实现Cloneable，因为子类实现需要调用父类的clone。Clone方法中对可变引用对象的copy可以通过递归clone完成。总结来说，对于clone不直接使用，而采用拷贝构造器以及拷贝工厂的方案来代替他。即入参和返回都是同类。</span></p>&#13;
<p align="left"><span style="font-size:18px"><strong>5.考虑实现Comparable接口。</strong>对于该接口的约定参考着equals。该接口指出了实现类的内在排序，实现该接口的类，可以参与排序算法[Collections.sort()等]。可以利用该接口的约定简略代码，返回值正负与0，并不关心值是多少。</span></p>&#13;
<p align="left"><br />&#13;
</p>&#13;
<p align="left"><span style="font-size:32px">像博主这么逗比的人还有吗？</span><img alt="委屈" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/wronged.gif" />(卖萌吗？)<br />&#13;
</p>&#13;
<p align="left"><span style="font-size:18px"><br />&#13;
</span></p>&#13;
   &#13;
