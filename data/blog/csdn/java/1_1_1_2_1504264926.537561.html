
        <div class="markdown_views"><p>Builder:将一个复杂对象的构建层与其表示层相互分离，同样的构件过程可采用不同的表示．</p>



<pre class="prettyprint"><code class="language-javascript hljs ">    <span class="hljs-comment">//创建一位人类</span>
    <span class="hljs-keyword">var</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(param)</span>{</span>
        <span class="hljs-comment">//技能</span>
        <span class="hljs-keyword">this</span>.skill = param &amp;&amp; parma.skill || <span class="hljs-string">'保密'</span>;
        <span class="hljs-comment">//兴趣爱好</span>
        <span class="hljs-keyword">this</span>.hobby = param &amp;&amp; param.hobby || <span class="hljs-string">'保密'</span>;
    }
    <span class="hljs-comment">//类人原型方法</span>
    Human.prototype = {
        getSkill : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.skill;
        },
        getHobby : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hobby;
        }
    }
    <span class="hljs-comment">//实例化姓名类</span>
    <span class="hljs-keyword">var</span> Named = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
        <span class="hljs-keyword">var</span> that  = <span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//构造器</span>
        <span class="hljs-comment">//构造函数解析姓名的姓和名</span>
        (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name,that)</span>{</span>
            that.wholeName = name;
            <span class="hljs-keyword">if</span>(name.indexOf(<span class="hljs-string">' '</span>)&gt;-<span class="hljs-number">1</span>){
                that.FirstName = name.slice(<span class="hljs-number">0</span>,name.indexOf(<span class="hljs-string">' '</span>));
                that.secondName = name.slice(name.indexOf(<span class="hljs-string">' '</span>));
            }
        })
    }
    <span class="hljs-comment">//实例化职位类</span>
    <span class="hljs-keyword">var</span> Work = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(work)</span>{</span>
        <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
        <span class="hljs-comment">//构造器</span>
        ...
    }
    <span class="hljs-comment">//更新期望的职位</span>
    Work.prototype.changeWork = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(work)</span>{</span>
        <span class="hljs-keyword">this</span>.work = work;
    }
    <span class="hljs-comment">//添加对职位的描述</span></code></pre>



<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">/***
*应聘者建造者
*参数　name 
*参数 work
**/</span>
<span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name,work)</span>{</span>
    <span class="hljs-comment">//创建应聘者缓存对象</span>
    <span class="hljs-keyword">var</span> _person = <span class="hljs-keyword">new</span> Human();
    <span class="hljs-comment">//创建应聘者姓名解析对象</span>
    _person.name = New Named(name);
    <span class="hljs-comment">//创建应聘者期望职位</span>
    _person.work = <span class="hljs-keyword">new</span> Work(work);
    <span class="hljs-comment">//将创建者返回</span>
    <span class="hljs-keyword">return</span> _person;
}</code></pre>

<p>使用方式</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span>　Person(<span class="hljs-string">'xiao ming'</span>,<span class="hljs-string">'code'</span>);</code></pre>

<p>工厂模式创建的是一个对象，他追求的是创建的结果，别无他求，所以那仅仅是一个实实在在的创建过程.而建造者模式就有所不同，它不仅仅可得到创建的结果，然而也参与了创建的具体过程．而创建的具体实现的细节也参与了干涉，可以说创建的对象更复杂，或者所这种模式创建的是一个复合对象．</p></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
