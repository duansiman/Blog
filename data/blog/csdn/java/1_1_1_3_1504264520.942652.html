

<p align="left"><span style="font-size:18px">转载请注明出处：http://blog.csdn.net/supera_li/article/details/44940563<br />&#13;
</span></p>&#13;
<p align="left"><span style="font-size:18px"><span style="font-size:18px">Effective java系列<br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/44940277&quot;打开连接&quot;">1.Effective java经验之谈，创建和销毁对象</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45064081">2.Effective java经验之谈，泛型</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/44940563">3.Effective java经验之谈，类与接口</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45034203">4.Effective java经验之谈，通用方法</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45155857">5.Effective java经验之谈，枚举，注解，方法，通用设计，异常</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/supera_li/article/details/45198341">6.Effective java经验之谈，并发编程</a></span><br />&#13;
</span></p>&#13;
<p align="left"><span style="font-size:18px">本章描述的是，自己在做系统重构的时候，阅读的章节，给自己在架构方面提供很大帮助。总结出一些干货分享一下啊啊啊~~主要应用场景是编写类与接口的时候需要注意的问题。每一章不一定按照顺序更新。<span style="font-size:18px">欢迎拍砖补充。</span></span></p>&#13;
<p align="left"><br />&#13;
<span style="font-size:18px"></span></p>&#13;
<p align="left"><span style="font-size:18px">1.<strong>类与成员的访问权限最小化</strong>。Public staticfinal 如果指向的是对象（数组也是对象），那么往往是错误的写法，【private static final  A=指向该对象，同时采用public static final指向A.clone()（A的副本）】【private staticfinal  A=指向该对象，public static final List通过Collections.unmodifiableList(Arrays.asList(A))返回一个List列表，存放数组】</span></p>&#13;
<p align="left"><span style="font-size:18px">2.<strong>在公有类使用访问方法而非开放数据域，即公有类不应该暴露可变域</strong>。例如javabean采用setter/getter方法来操作对象数据域</span></p>&#13;
<p align="left"><span style="font-size:18px">3<strong>.复合优于继承</strong>，将继承类当做一个组件放到复合类中，通过一系列转发方法实现继承类。然后通过外界函数调用此复合类。</span></p>&#13;
<p align="left"><span style="font-size:18px">4.<strong>要么为继承而设计，并提供文档说明，要么就禁止继承。</strong>禁止继承，可以通过final，以及构造器私有化完成。如果需要继承，那么需要考虑继承类在任何时候不能调用该类可覆盖的方法，可以机械消除可覆盖方法的自用特性，通过将该覆盖的方法代码复制一份私有辅助方法。通过调用私有辅助方法消除自用特性。</span></p>&#13;
<p align="left"><span style="font-size:18px">5.<strong>接口优于抽象类，抽象类是为继承而设计的</strong>，抽象类演变比接口容易的多，例如，后期需要增加方法，抽象类可以，但接口却不行。</span></p>&#13;
<p align="left"><span style="font-size:18px">6.<strong>接口只用于定义类型</strong>，例如常量接口是对接口的不良使用。对于常量的设计，如果常量紧密关联某一个类，将写入该类内部。如果能看错枚举常量就用枚举代替。否则将采用不可实例化的工具类来导出这些常量。</span></p>&#13;
<p align="left"><span style="font-size:18px">7.<strong>类层次优于标签类</strong>。如果代码中存在根据某一个标志位而产生不同的方法结果，也就是代码模板，那么需要考虑是否可以层次化代码，将模板代码提取为抽象类中的方法进行类层次化。</span></p>&#13;
<p align="left"><span style="font-size:18px">8.<strong>用函数对象表示策略</strong>，函数对象作为参数传递到方法，代表着java中的“指针”，通过可以将函数对象采用接口的形式来包装成策略，提供一个 “宿主类”通过一个公有的静态方法来调用私有的静态成员，该静态成员就是此策略的实现方式。</span></p>&#13;
<p align="left"><span style="font-size:18px"><br />&#13;
</span></p>&#13;
<p align="left"><span style="font-size:18px">在系统架构编码的时候优先能统一为接口吗？该类能使用复合吗？该类是一定被继承下去的，采用抽象类可以吗？其他类能继承吗？该类编写前，X属性能public吗？大致就这些一般性思考方向。<br />&#13;
</span></p>&#13;
<p align="left"><br />&#13;
</p>&#13;
<p align="left"><br />&#13;
</p>&#13;
<p align="left"><span style="font-size:18px"><br />&#13;
</span></p>&#13;
   &#13;
