

<span style="font-size:18px">1.模板方法模式的定义：<br />&#13;
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br />&#13;
<br />&#13;
2.模板方法模式的结构和说明：<br />&#13;
AbstractClass: 抽象类。用来定义算法骨架和原语操作，具体的子类通过重定义这些原语操作来实现一个算法的各个步骤。在这个类里面，还可以提供算法中通用的实现。<br />&#13;
ConcreteClass: 具体实现类。用来实现算法骨架中的某些步骤，完成与特定子类相关的功能。<br />&#13;
<br />&#13;
3.模式实现<br />&#13;
</span>&#13;
<p><span style="font-size:18px">AbstractClass.java </span></p>&#13;
<p></p><pre code_snippet_id="1851111" snippet_file_name="blog_20160825_1_2648558" name="code" class="java">package com.java.pattern.templateMethod;

/**
 * 定义模板方法、原语操作等的抽象类
 */
public abstract class AbstractClass {

	/**
	 * 原语操作1，原语操作就是抽象操作，必要要有子类提供实现
	 * 
	 */
	public abstract void doPrimitiveOperation1();

	/**
	 * 原语操作2
	 * 
	 */
	public abstract void doPrimitiveOperation2();

	/**
	 * 模板方法，定义算法骨架
	 */
	public final void templateMethod() {
		doPrimitiveOperation1();
		doPrimitiveOperation2();
	}
}
</pre><br />&#13;
<span style="font-size:18px">ConcreteClass.java</span><br />&#13;
&#13;
<p></p><pre code_snippet_id="1851111" snippet_file_name="blog_20160825_2_8951040" name="code" class="java">package com.java.pattern.templateMethod;

/**
 * 具体实现类，实现原语操作
 */
public class ConcreteClass extends AbstractClass {

	public void doPrimitiveOperation1() {
		// 具体实现
		System.out.println("ConcreteClass--doPrimitiveOperation1");
	}

	public void doPrimitiveOperation2() {
		// 具体实现
		System.out.println("ConcreteClass--doPrimitiveOperation2");
	}
}
</pre><span style="font-size:18px"><br />&#13;
Client.java<br />&#13;
</span>&#13;
<p></p><pre code_snippet_id="1851111" snippet_file_name="blog_20160825_3_8809336" name="code" class="java">package com.java.pattern.templateMethod;

/**
 * 客户端
 */
public class Client {

	public static void main(String[] args) {
		AbstractClass abstractClass = new ConcreteClass();
		abstractClass.doPrimitiveOperation1();
		abstractClass.doPrimitiveOperation2();
	}
}
</pre><br />&#13;
<br />&#13;
&#13;
<p><br />&#13;
</p>&#13;
<span style="font-size:18px">运行结果：<br />&#13;
ConcreteClass--doPrimitiveOperation1<br />&#13;
ConcreteClass--doPrimitiveOperation2<br />&#13;
<br />&#13;
4.思考模板方法模式<br />&#13;
A，模板方法模式的本质：固定算法骨架<br />&#13;
模板方法模式的功能在于固定算法骨架，而让具体算法实现可扩展。<br />&#13;
这在实际使用中非常广泛，尤其是在设计框架级功能的时候非常有用。框架定义好了算法的步骤，在合适的点让开发人员进行扩展，实现具体的算法。<br />&#13;
模板方法模式还额外提供了一个好处，就是可以控制子类的扩展，因为在父类中定义好了算法的步骤，只是在某几个固定的点才会调用到被子类实现的方法，因此也就只允许在这几个点来扩展功能。这些可以被子类覆盖以扩展功能的方法通常被成为"钩子"方法。<br />&#13;
<br />&#13;
B，何时选用模板方法模式，建议在以下情况中选用：<br />&#13;
1), 需要固定定义算法骨架，实现一个算法的不变的部分，并把可变的部分留给子类来实现的情况。<br />&#13;
2), 各个子类中具有公共行为，应该抽取出来，集中在一个公共类中去实现，从而避免代码重复。<br />&#13;
3)，需要控制子类扩展的情况，模版方法模式会在特定的点调用子类的方法，这样只允许在这些点进行扩展。</span>&#13;
   &#13;
