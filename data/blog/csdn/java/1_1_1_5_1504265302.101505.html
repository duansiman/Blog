

<span style="font-size:18px">1.外观模式的定义：<br />&#13;
为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br />&#13;
<br />&#13;
2.外观模式的结构和说明：<br />&#13;
Facade: 定义子系统的多个模块对外的高层接口，通过需要调用内部多个模块，从而把客户的请求代理给适当的子系统对象。<br />&#13;
模块：接受Facade对象的委派，真正实现功能，各个模块之间可能有交互。但是请注意，Facade对象知道各个模块，但是各个模块不应该知道Facade对象。<br />&#13;
<br />&#13;
3.模式实现<br />&#13;
</span>&#13;
<p><span style="font-size:18px">AModuleApi.java</span></p>&#13;
<p><span style="font-size:18px"></span></p><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_1_6145492" name="code" class="java">package com.java.pattern.facade;

/**
 * A模块的接口
 * 
 */
public interface AModuleApi {
	// A模块对外的一个功能方法
	public void testA();
}
</pre><br />&#13;
AModuleImpl.java&#13;
<p><span style="font-size:18px"></span></p><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_2_7160030" name="code" class="java">package com.java.pattern.facade;

public class AModuleImpl implements AModuleApi {

	public void testA() {
		System.out.println("现在在A模块里面操作testA方法");
	}
}
</pre><br />&#13;
BModuleApi.java&#13;
<p><span style="font-size:18px"></span></p><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_3_7301734" name="code" class="java">package com.java.pattern.facade;

/**
 * B模块的接口
 * 
 */
public interface BModuleApi {
	// B模块对外的一个功能方法
	public void testB();
}
</pre><br />&#13;
BModuleImpl.java&#13;
<p><span style="font-size:18px"></span></p><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_4_8523233" name="code" class="java">package com.java.pattern.facade;

public class BModuleImpl implements BModuleApi {

	public void testB() {
		System.out.println("现在在B模块里面操作testB方法");
	}
}
</pre><br />&#13;
Facade.java&#13;
<span style="font-size:18px"></span><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_5_3889190" name="code" class="java">package com.java.pattern.facade;

/**
 * 定义外观对象
 * 
 */
public class Facade {

	// 满足客户需要的功能
	public void test() {
		AModuleApi a = new AModuleImpl();
		a.testA();

		BModuleApi b = new BModuleImpl();
		b.testB();
	}
}
</pre><br />&#13;
<p><span style="font-size:18px">Client.java</span></p>&#13;
<p><span style="font-size:18px"></span></p><pre code_snippet_id="1847857" snippet_file_name="blog_20160824_6_7618944" name="code" class="java">package com.java.pattern.facade;

/**
 * 客户端
 */
public class Client {
	public static void main(String[] args) {
		// 使用Facade
		new Facade().test();
	}
}
</pre><br />&#13;
<br />&#13;
&#13;
<span style="font-size:18px">运行结果：<br />&#13;
现在在A模块里面操作testA方法<br />&#13;
现在在B模块里面操作testB方法<br />&#13;
<br />&#13;
4.思考外观模式<br />&#13;
4.1 外观模式的本质是：封装交互，简化调用。<br />&#13;
4.2 何时选用外观模式，建议在以下情况中选用：<br />&#13;
A，如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。使用外观对象来实现大部分客户需要的功能，从而简化客户的使用。<br />&#13;
B，如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提供子系统的独立性和可移植行。<br />&#13;
C，如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。<br />&#13;
<br />&#13;
</span>&#13;
   &#13;
