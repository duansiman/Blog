

<div id="art-body" style="margin-bottom:12px; line-height:1.6em; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; background-color:rgb(238,238,238)">&#13;
Prototype模式定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br />&#13;
<br />&#13;
Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节，工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。&#13;
<h2 style="margin:15px auto; font-size:18px; line-height:18px">如何使用原型模式</h2>&#13;
因为Java中的提供clone()方法来实现对象的克隆，所以Prototype模式实现一下子变得很简单。以勺子为例：&#13;
<div class="code">public abstract class AbstractSpoon implements Cloneable{<br />&#13;
　String spoonName;<br />&#13;
　public void setSpoonName(String spoonName) {this.spoonName = spoonName;}<br />&#13;
　public String getSpoonName() {return this.spoonName;}<br />&#13;
　public Object clone(){<br />&#13;
　　Object object = null;<br />&#13;
　　try {<br />&#13;
　　　object = super.clone();<br />&#13;
　　} catch (CloneNotSupportedException exception) {<br />&#13;
　　　System.err.println("AbstractSpoon is not Cloneable");<br />&#13;
　　}<br />&#13;
　　　return object;<br />&#13;
　}<br />&#13;
}</div>&#13;
有两个具体实现(ConcretePrototype)：&#13;
<ul style="margin-top:0px; margin-bottom:0px; list-style-position:initial; margin-left:0px; padding-left:20px">&#13;
<li>public class SoupSpoon extends AbstractSpoon{<br />&#13;
　public SoupSpoon(){<br />&#13;
　　setSpoonName("Soup Spoon");<br />&#13;
　}<br />&#13;
}</li><li>public class SaladSpoon extends AbstractSpoon{<br />&#13;
　public SaladSpoon(){<br />&#13;
　　setSpoonName("Salad Spoon");<br />&#13;
　}<br />&#13;
}</li></ul>&#13;
<br />&#13;
调用Prototype模式很简单：&#13;
<ul style="margin-top:0px; margin-bottom:0px; list-style-position:initial; margin-left:0px; padding-left:20px">&#13;
<li>AbstractSpoon spoon = new SoupSpoon();</li><li>AbstractSpoon spoon = new SaladSpoon();</li></ul>&#13;
<br />&#13;
当然也可以结合工厂模式来创建AbstractSpoon实例。<br />&#13;
<br />&#13;
在Java中Prototype模式变成clone()方法的使用，由于Java的纯洁的面向对象特性，使得在Java中使用设计模式变得很自然，两者已经几乎是浑然一体了。这反映在很多模式上，如Interator遍历模式。<br />&#13;
</div>&#13;
<div id="ad-arc-bottom" class="clearfix" style="padding-bottom:12px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; background-color:rgb(238,238,238)">&#13;
</div>&#13;
<div id="ad-arc-bottom" class="clearfix" style="padding-bottom:12px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; background-color:rgb(238,238,238)">&#13;
<div class="TITLE">原型模式</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> <strong>概述</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> <strong>适用性</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    1.当一个系统应该独立于它的产品创建、构成和表示时。

    2.当要实例化的类是在运行时刻指定时，例如，通过动态装载。

    3.为了避免创建一个与产品类层次平行的工厂类层次时。

    4.当一个类的实例只能有几个不同状态组合中的一种时。

    建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
			</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> <strong>参与者</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    1. Prototype
       声明一个克隆自身的接口。

    2. ConcretePrototype
       实现一个克隆自身的操作。

    3. Client
       让一个原型克隆自身从而创建一个新的对象。
</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> <strong>类图</strong></h5>&#13;
</div>&#13;
<div class="theContent"><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> </div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45647087" alt="" /> <strong>例子</strong></h5>&#13;
</div>&#13;
<div class="theContent"><strong>Prototype</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class Prototype implements Cloneable {

    private String name;
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }

    public Object clone(){
        try {
            return super.clone();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>ConcretePrototype</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class ConcretePrototype extends Prototype {

    public ConcretePrototype(String name) {
        setName(name);
    }
}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>Client</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class Test {

    public static void main(String[] args) {
        Prototype pro = new ConcretePrototype("prototype");
        Prototype pro2 = (Prototype)pro.clone();
        System.out.println(pro.getName());
        System.out.println(pro2.getName());
    }
}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>result</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>prototype
prototype

</pre>&#13;
</div>&#13;
</div>&#13;
<br />&#13;
</div>&#13;
   &#13;
