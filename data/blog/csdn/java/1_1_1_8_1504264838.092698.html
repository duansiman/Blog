

<div class="TITLE">工厂方法</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> <strong>概述</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。
</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> <strong>适用性</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    1.当一个类不知道它所必须创建的对象的类的时候。

    2.当一个类希望由它的子类来指定它所创建的对象的时候。

    3.当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。
			</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> <strong>参与者</strong></h5>&#13;
</div>&#13;
<div class="theContent">&#13;
<pre>    1.Product
      定义工厂方法所创建的对象的接口。

    2.ConcreteProduct
      实现Product接口。

    3.Creator
      声明工厂方法，该方法返回一个Product类型的对象。
      Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。
      可以调用工厂方法以创建一个Product对象。

    4.ConcreteCreator
      重定义工厂方法以返回一个ConcreteProduct实例。
</pre>&#13;
</div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> <strong>类图</strong></h5>&#13;
</div>&#13;
<div class="theContent"><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> </div>&#13;
</div>&#13;
<div class="currency_area">&#13;
<div class="theTitle">&#13;
<h5><img src="http://blog.csdn.net/qq_27073205/article/details/45371815" alt="" /> <strong>例子</strong></h5>&#13;
</div>&#13;
<div class="theContent"><strong>Product</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public interface Work {

    void doWork();
}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>ConcreteProduct</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class StudentWork implements Work {

    public void doWork() {
        System.out.println("学生写作业!");
    }

}
</pre>&#13;
</div>&#13;
<div class="theContent"></div>&#13;
<div class="theContent2">&#13;
<pre>public class TeacherWork implements Work {

    public void doWork() {
        System.out.println("老师批作业!");
    }

}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>Creator</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public interface IWorkFactory {

    Work getWork();
}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>ConcreteCreator</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class StudentWorkFactory implements IWorkFactory {

    public Work getWork() {
        return new StudentWork();
    }

}
</pre>&#13;
</div>&#13;
<div class="theContent"></div>&#13;
<div class="theContent2">&#13;
<pre>public class TeacherWorkFactory implements IWorkFactory {

    public Work getWork() {
        return new TeacherWork();
    }

}
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>Test</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>public class Test {

    public static void main(String[] args) {
        IWorkFactory studentWorkFactory = new StudentWorkFactory();
        studentWorkFactory.getWork().doWork();
        
        IWorkFactory teacherWorkFactory = new TeacherWorkFactory();
        teacherWorkFactory.getWork().doWork();
    }

}
</pre>&#13;
<pre>&#13;
</pre>&#13;
<pre>&#13;
</pre>&#13;
</div>&#13;
<div class="theContent"><strong>result</strong> </div>&#13;
<div class="theContent2">&#13;
<pre>学生写作业!
老师批作业!
</pre>&#13;
<pre>&#13;
</pre>&#13;
<pre><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">工厂模式定义：提供创建对象的接口。</span><h2 style="margin:15px auto; font-size:18px; line-height:18px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; background-color:rgb(238,238,238)">为何使用工厂模式</h2><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">工厂模式是我们最常用的模式了，著名的Jive论坛，就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">为什么工厂模式是如此常用？</span><span style="font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238); color:rgb(178,34,34)">因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑实用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">我们以类Sample为例， 如果我们要创建Sample的实例对象：</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">    Sample sample=new Sample();</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">可是，实际情况是，通常我们都要在创建sample实例时做点初始化的工作,比如赋值查询数据库等。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">首先，我们想到的是，可以使用Sample的构造函数，这样生成实例就写成：</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">    Sample sample=new Sample(参数);</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">但是，如果创建sample实例时所做的初始化工作不是象赋值这样简单的事，可能是很长一段代码，如果也写入构造函数中，那你的代码很难看了（就需要Refactor重整）。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">为什么说代码很难看，初学者可能没有这种感觉，我们分析如下，初始化工作如果是很长一段代码，说明要做的工作很多，将很多工作装入一个方法中，相当于将很多鸡蛋放在一个篮子里，是很危险的，这也是有背于Java面向对象的原则，面向对象的封装(Encapsulation)和分派(Delegation)告诉我们，尽量将长的代码分派“切割”成每段，将每段再“封装”起来(减少段和段之间偶合联系性)，这样，就会将风险分散，以后如果需要修改，只要更改每段，不会再发生牵一动百的事情。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">在本例中，首先，我们需要将创建实例的工作与使用实例的工作分开，也就是说，让创建实例所需要的大量初始化工作从Sample的构造函数中分离出去。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">这时我们就需要Factory工厂模式来生成对象了，不能再用上面简单new Sample(参数)。还有,如果Sample有个继承如MySample，按照面向接口编程，我们需要将Sample抽象成一个接口。现在Sample是接口，有两个子类MySample 和HisSample。我们要实例化他们时,如下：</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">    Sample mysample=new MySample(); Sample hissample=new HisSample();</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">随着项目的深入，Sample可能还会"生出很多儿子出来"，那么我们要对这些儿子一个个实例化，更糟糕的是，可能还要对以前的代码进行修改：加入后来生出儿子的实例.这在传统程序中是无法避免的。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">但如果你一开始就有意识使用了工厂模式，这些麻烦就没有了。</span><h2 style="margin:15px auto; font-size:18px; line-height:18px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; background-color:rgb(238,238,238)">工厂方法</h2><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">你会建立一个专门生产Sample实例的工厂：</span><div class="code" style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">public class Factory{&#13;
    public static Sample creator(int which){&#13;
        //getClass 产生Sample 一般可使用动态类装载装入类。&#13;
        if (which==1)&#13;
            return new SampleA();&#13;
        else if (which==2)&#13;
            return new SampleB();&#13;
    }&#13;
}</div><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">那么在你的程序中，如果要实例化Sample时就使用</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">    Sample sampleA=Factory.creator(1);</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">这样，在整个就不涉及到Sample的具体子类，达到封装效果，也就减少错误修改的机会，这个原理可以用很通俗的话来比喻：就是具体事情做得越多，越容易范错误。这每个做过具体工作的人都深有体会，相反，官做得越高，说出的话越抽象越笼统，范错误可能性就越少。好象我们从编程序中也能悟出人生道理？</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">使用工厂方法要注意几个角色，首先你要定义产品接口，如上面的Sample，产品接口下有Sample接口的实现类，如SampleA，其次要有一个factory类，用来生成产品Sample，如下图，最右边是生产的对象Sample：</span><div style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238); text-align:center"><img alt="Java工厂模式" src="http://www.weixueyuan.net/uploads/allimg/130301/8-1303010950391Q.png" style="border:none; max-width:728px!important; width:526px; height:178px" /></div><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">进一步稍微复杂一点，就是在工厂类上进行拓展，工厂类也有继承它的实现类concreteFactory了。</span><h2 style="margin:15px auto; font-size:18px; line-height:18px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; background-color:rgb(238,238,238)">抽象工厂</h2><span style="font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238); color:rgb(178,34,34)">工厂模式中有：工厂方法(Factory Method)和抽象工厂(Abstract Factory)。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">这两个模式区别在于需要创建对象的复杂程度上。如果我们创建对象的方法变得复杂了，如上面工厂方法中是创建一个对象Sample，如果我们还有新的产品接口Sample2。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">这里假设：Sample有两个concrete类SampleA和SamleB，而Sample2也有两个concrete类Sample2A和SampleB2，那么，我们就将上例中Factory变成抽象类，将共同部分封装在抽象类中，不同部分使用子类实现，下面就是将上例中的Factory拓展成抽象工厂：</span><div class="code" style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">public abstract class Factory{&#13;
    public abstract Sample creator();&#13;
    public abstract Sample2 creator(String name);&#13;
}&#13;
public class SimpleFactory extends Factory{&#13;
    public Sample creator(){ ......... return new SampleA }&#13;
    public Sample2 creator(String name){ ......... return new Sample2A }&#13;
}&#13;
public class BombFactory extends Factory{&#13;
    public Sample creator(){ ...... return new SampleB }&#13;
    public Sample2 creator(String name){ ...... return new Sample2B }&#13;
}</div><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">从上面看到两个工厂各自生产出一套Sample和Sample2，也许你会疑问，为什么我不可以使用两个工厂方法来分别生产Sample和Sample2？</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">抽象工厂还有另外一个关键要点，是因为 SimpleFactory内，生产Sample和生产Sample2的方法之间有一定联系，所以才要将这两个方法捆绑在一个类中，这个工厂类有其本身特征，也许制造过程是统一的，比如：制造工艺比较简单，所以名称叫SimpleFactory。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">在实际应用中，工厂方法用得比较多一些，而且是和动态类装入器组合在一起应用，</span><h2 style="margin:15px auto; font-size:18px; line-height:18px; color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; background-color:rgb(238,238,238)">Java工厂模式举例</h2><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">我们以Jive的ForumFactory为例，这个例子在前面的Singleton模式中我们讨论过，现在再讨论其工厂模式：</span><div class="code" style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">public abstract class ForumFactory {&#13;
    private static Object initLock = new Object(); private static String className ="com.jivesoftware.forum.database.DbForumFactory"; private static ForumFactory factory = null;&#13;
    public static ForumFactory getInstance(Authorization authorization) {&#13;
        //If no valid authorization passed in, return null.&#13;
        if (authorization == null) { return null; }&#13;
        //以下使用了Singleton 单态模式&#13;
        if (factory == null) {&#13;
            synchronized(initLock) {&#13;
                if (factory == null) { ......&#13;
                        try {&#13;
                            //动态转载类&#13;
                            Class c = Class.forName(className);&#13;
                            factory = (ForumFactory)c.newInstance();&#13;
                        } catch (Exception e) { return null; }&#13;
                 }&#13;
            }&#13;
        }&#13;
        //Now, 返回 proxy.用来限制授权对forum的访问&#13;
        return new ForumFactoryProxy(authorization, factory,factory.getPermissions(authorization));&#13;
    }&#13;
    //真正创建forum的方法由继承forumfactory的子类去完成.&#13;
    public abstract Forum createForum(String name, String description)&#13;
        throws UnauthorizedException, ForumAlreadyExistsException;&#13;
    ....&#13;
}</div><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">因为现在的Jive是通过数据库系统存放论坛帖子等内容数据，如果希望更改为通过文件系统实现，这个工厂方法ForumFactory就提供了提供动态接口：</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">    private static String className = "com.jivesoftware.forum.database.DbForumFactory";</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">你可以使用自己开发的创建forum的方法代替com.jivesoftware.forum.database.DbForumFactory就可以。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">在上面的一段代码中一共用了三种模式，除了工厂模式外，还有Singleton单态模式，以及proxy模式,proxy模式主要用来授权用户对forum的访问，因为访问forum有两种人：一个是注册用户一个是游客guest，那么那么相应的权限就不一样，而且这个权限是贯穿整个系统的，因此建立一个proxy，类似网关的概念，可以很好的达到这个效果。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">看看Java宠物店中的CatalogDAOFactory：</span><div class="code" style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">public class CatalogDAOFactory {&#13;
    /**&#13;
      * 本方法制定一个特别的子类来实现DAO模式。&#13;
      * 具体子类定义是在J2EE的部署描述器中。&#13;
    */&#13;
        public static CatalogDAO getDAO() throws CatalogDAOSysException{&#13;
            CatalogDAO catDao = null;&#13;
            try {&#13;
                InitialContext ic = new InitialContext();&#13;
                //动态装入CATALOG_DAO_CLASS&#13;
                //可以定义自己的CATALOG_DAO_CLASS，从而在无需变更太多代码&#13;
                //的前提下，完成系统的巨大变更。&#13;
                String className =(String) ic.lookup(JNDINames.CATALOG_DAO_CLASS);&#13;
                catDao = (CatalogDAO) Class.forName(className).newInstance();&#13;
            } catch (NamingException ne) {&#13;
                throw new CatalogDAOSysException(" CatalogDAOFactory.getDAO: NamingException while getting DAO type : \n" + ne.getMessage());&#13;
            } catch (Exception se) {&#13;
                throw new CatalogDAOSysException("CatalogDAOFactory.getDAO: Exception while getting DAO type : \n" + se.getMessage());&#13;
           }&#13;
           return catDao;&#13;
    }&#13;
}</div><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)">CatalogDAOFactory是典型的工厂方法，catDao是通过动态类装入器className获得CatalogDAOFactory具体实现子类，这个实现子类在Java宠物店是用来操作catalog数据库，用户可以根据数据库的类型不同，定制自己的具体实现子类，将自己的子类名给与CATALOG_DAO_CLASS变量就可以。</span><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><br style="color:rgb(51,51,51); font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238)" /><span style="font-family:'Microsoft Yahei',Arial,Helvetica,sans-serif; font-size:14px; line-height:22.390625px; background-color:rgb(238,238,238); color:rgb(178,34,34)">由此可见，工厂方法确实为系统结构提供了非常灵活强大的动态扩展机制，只要我们更换一下具体的工厂方法，系统其他地方无需一点变换，就有可能将系统功能进行改头换面的变化。</span>&#13;
</pre>&#13;
<pre>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
   &#13;
