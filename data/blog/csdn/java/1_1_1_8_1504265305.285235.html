

<span style="font-size:18px">1.抽象工厂的定义：        <span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">       </span><span style="font-size:18px">   </span><br />&#13;
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br />&#13;
<br />&#13;
2.抽象工厂的结构和说明：<br />&#13;
A，Abstract Factory: 抽象工厂，定义创建一系列产品对象的操作接口。<br />&#13;
B，Concrete Factory: 具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建。<br />&#13;
C，Abstract Product: 定义一类产品对象的接口。<br />&#13;
D，Concrete Product: 具体的产品实现对象，通常在具体工厂里面，会选择具体的产品实现对象，<br />&#13;
来创建符合抽象工厂定义的方法返回的产品类型的对象。<br />&#13;
E，Client：客户端，主要使用抽象工厂来获取一系列所需要的产品对象，然后面向这些产品对象的接口编程，<br />&#13;
以实现需要的功能。<br />&#13;
<br />&#13;
3.模式实现<br />&#13;
</span>&#13;
<p><span style="font-size:18px">AbstractFactory.java</span></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_1_8956955" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 抽象工厂的接口，声明创建抽象产品对象的操作
 */
public interface AbstractFactory {

	/**
	 * 创建抽象产品A的对象
	 * 
	 * @return
	 */
	public AbstractProductA createProductA();

	/**
	 * 创建抽象产品B的对象
	 * 
	 * @return
	 */
	public AbstractProductB createProductB();

}
</pre><br />&#13;
AbstractProductA.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_2_3526524" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 抽象产品A的接口
 * 
 */
public interface AbstractProductA {

}
</pre><br />&#13;
AbstractProductB.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_3_1159973" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 抽象产品B的接口
 * 
 */
public interface AbstractProductB {

}
</pre><br />&#13;
ProductA1.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_4_9349829" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 产品A的具体实现
 */
public class ProductA1 implements AbstractProductA {

}
</pre><br />&#13;
ProductA2.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_5_571329" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 产品A的具体实现
 */
public class ProductA2 implements AbstractProductA {

}
</pre><br />&#13;
ProductB1.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_6_3603754" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 产品B的具体实现
 */
public class ProductB1 implements AbstractProductB {

}
</pre><br />&#13;
ProductB2.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_7_2109255" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 产品B的具体实现
 */
public class ProductB2 implements AbstractProductB {

}
</pre><br />&#13;
ConcreteFactory1.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_8_5839009" name="code" class="java">/**
 * 具体的工厂实现对象，实现创建具体的产品对象的操作
 * 
 */
public class ConcreteFactory1 implements AbstractFactory {

	public AbstractProductA createProductA() {
		return new ProductA1();
	}

	public AbstractProductB createProductB() {
		return new ProductB1();
	}
}
</pre><br />&#13;
ConcreteFactory2.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_9_9568763" name="code" class="java">package com.java.pattern.abstractfactory;

/**
 * 具体的工厂实现对象，实现创建具体的产品对象的操作
 * 
 */
public class ConcreteFactory2 implements AbstractFactory {

	public AbstractProductA createProductA() {
		return new ProductA2();
	}

	public AbstractProductB createProductB() {
		return new ProductB2();
	}
}
</pre><br />&#13;
Client.java&#13;
<p></p>&#13;
<p><span style="font-size:18px"></span></p>&#13;
<pre code_snippet_id="1841565" snippet_file_name="blog_20160820_10_441599" name="code" class="java">package com.java.pattern.abstractfactory;

public class Client {
	public static void main(String[] args) {
		// 创建抽象工厂对象
		AbstractFactory af = new ConcreteFactory1();
		// 通过抽象工厂来获取一系列的对象，如产品A和产品B
		af.createProductA();
		af.createProductB();
	}
}
</pre><br />&#13;
<br />&#13;
<p></p>&#13;
<span style="font-size:18px">4.思考抽象工厂<br />&#13;
抽象工厂模式的本质：选择产品簇的实现<br />&#13;
A, 抽象工厂模式的本质<br />&#13;
工厂方法是选择单个产品的实现，虽然一个类里面可以有多个工厂方法，但是这些方法之间一般是没有联系的，即使看起来像有联系。但是抽象工厂着重的就是为一个产品簇选择实现，定义在抽象工厂 里面的方法通常是有联系的，它们都是产品的某一个部分或者相互依赖的。如果抽象工厂里面只定义一个方法，直接创建产品，那么就退化成为工厂方法了。<br />&#13;
<br />&#13;
B，何时选用抽象工厂模式<br />&#13;
建议在以下情况中选用抽象工厂模式：<br />&#13;
B1，如果希望一个系统独立于它的产品的创建、组合和表示的时候。换句话说，希望一个系统只是知道产品的接口，而不关心实现的时候。<br />&#13;
B2，如果一个系统要由多个产品系列中的一个来配置的时候。换句话说，就是可以动态地切换产品簇的时候。<br />&#13;
B3，如果要强调一系列相关产品的接口，以便联合使用它们的时候。<br />&#13;
<br />&#13;
</span><br />&#13;
<br />&#13;
   &#13;
