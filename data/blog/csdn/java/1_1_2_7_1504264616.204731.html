

<p>最后编辑时间：2017.07.12<br />&#13;
</p>&#13;
<p style="text-align:center"><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#ff0000">面向对象设计：原则、模式和应用(Java8)</span></strong></p>&#13;
<p style="text-align:center"><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8592375"><img alt="返回" src="http://img.blog.csdn.net/20140919170809965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXFqMjA2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></a></p>&#13;
<hr />&#13;
<h2>上机练习题</h2>&#13;
<p>实验1.使用<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8539977"><span style="font-size:18px">工具类God</span></a></p>&#13;
<p>实验2.行为参数化</p>&#13;
<p>实验3.框架设计者</p>&#13;
<p>实验4 求和方法的一般化<br />&#13;
</p>&#13;
<p>实验5 复合函数-桥接和装饰</p>&#13;
<p>实验6 表达式问题-访问者和解释器<br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<hr />&#13;
<p>yqj2065的讲义，一直会调整。</p>&#13;
<p>第1章 基础</p>&#13;
<blockquote>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8502681">1.1 面向对象编程范式</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48544811">脑图</a><br />&#13;
</p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/编程宗派的融合">编程宗派的融合</a>(从范式，到编程范式，到编程宗派(风格))  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/52833860">命令式编程范式</a>   <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/51345511">函数式编程之根-拉姆达运算/演算(λ-calculus)</a><br />&#13;
</p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><span style="color:#ffcc33"><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/46705103">1.1.1 柏拉图法则</a></span><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39183865">1.1.2 Liskov原则</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/36478517">1.1.3 Parnas原则</a> (接口与实现分离) <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48222385" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">《编程导论（Java）·6.1封装性》</a><br />&#13;
</p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>1.2 永恒的变化 开放封闭原则</p>&#13;
<p> 1.3 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48289501">&#13;
设计原则概述</a></p>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39104533"> 何谓设计模式</a><br />&#13;
</p>&#13;
</blockquote>&#13;
<p>第2章 抽象依赖原则</p>&#13;
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;
<p></p>&#13;
<p>2.1 Java接口类型 </p>&#13;
</blockquote>&#13;
<p></p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.2 例程为媒</p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.2.1 编译时依赖  介绍继承和使用</p>&#13;
<p>2.2.2 多态取代分支结构  针对接口编程<br />&#13;
</p>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38909293">2.2.3 策略模式(5.9)</a><br />&#13;
</p>&#13;
<p>2.2.4 框架设计者 介绍复用、控制反转、回调</p>&#13;
<p>2.2.5 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/70941763">&#13;
抛弃依赖倒置原则</a><br />&#13;
</p>&#13;
</blockquote>&#13;
<p>2.3 对象初始化</p>&#13;
</blockquote>&#13;
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.3.1 new与反射<br />&#13;
</p>&#13;
<p>2.3.2 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8539977">&#13;
工具类God</a> <br />&#13;
</p>&#13;
<p>2.3.3 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8510074">依赖注入模式</a> </p>&#13;
<p>2.3.4 配置文件Vs. 标注 @ <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/49328083">增强tool.God</a>  @<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48562687">Spring工具的简单使用</a> </p>&#13;
<p>2.3.5 工厂模式 准备将<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8561370">2.1.1 简单工厂模式</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39229481">2.1.2 工厂方法模式（3.3</a>）<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/49252837" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">工厂模式的enum实现</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39343193">2.1.3&#13;
 抽象工厂模式（3.1）</a> 压缩为一节。</p>&#13;
</blockquote>&#13;
<p>2.4 行为参数化<br />&#13;
</p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><br />&#13;
</p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<p>第3章 策略模式引申<br />&#13;
</p>&#13;
<p></p>&#13;
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39127231">3.1 策略模式的扩展</a><br />&#13;
</p>&#13;
<p>3.2 桥接模式(4.2)<br />&#13;
</p>&#13;
<p>3.3 模板方法模式(5.10)<br />&#13;
</p>&#13;
</blockquote>&#13;
<p></p>&#13;
<p>第4章 表达式问题<br />&#13;
</p>&#13;
<p></p>&#13;
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;
<p>4.1 模拟双分派</p>&#13;
<p>4.2 访问者模式(5.11)</p>&#13;
<p>4.3 解释器模式(5.3)<br />&#13;
</p>&#13;
</blockquote>&#13;
<p></p>&#13;
<p><br />&#13;
</p>&#13;
<p>第3章 其他创建型模式 </p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.4 装配厂模式 </p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8566378">2.2.1 伪建造者模式</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8570241">2.2.2 建造者模式(3.2)</a><br />&#13;
<span style="color:rgb(255,204,51)">2.2.3 串接式setter模式</span> 略</p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.5 零例、单例和对象池</p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>2.6  原型模式(3.4)</p>&#13;
</blockquote>&#13;
<p>第4章 行为参数化 <br />&#13;
</p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>4.1 引子</p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>4.1.1 值参数化  4.1.2 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/53969596">&#13;
强大的动态绑定</a> 4.1.3 行为参数化 4.1.4 <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/52957176">回调机制(Call back)</a> </p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>4.1单向依赖原则 @<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8758101">好莱坞原则</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39756427" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; word-break:break-all; word-wrap:break-word">最简单的Java框架</a> </p>&#13;
<p>4.3<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/53152213">模板方法模式</a>   @传统<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8475174">模板方法模式(5.10)</a>   <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8507825">+显式回调</a>&#13;
  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/49237327">脑图</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38970097">4.4 桥接模式(4.2) </a><br />&#13;
</p>&#13;
<p><span style="color:#ffcc0">4.6 观察者模式（5.7）</span> </p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor"><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38969965">5.3 适配器模式(4.1)</a>  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48260633" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">5.3.3&#13;
 可插入的适配器(Pluggable Adapter)</a><br />&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38930281">3.4 命令模式(5.2)</a>   <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39667587" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">命令模式之2&#13;
 Invoker Vs. Client</a>   模拟<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38960149">双分派</a>  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48710627" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">命令模式(5.2)的结构推导</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48652159">3.5 访问者模式(5.11)</a>  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39697081" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">访问者模式的意图</a>  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48734337" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">访问者模式与双分派</a> &#13;
  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/48652159" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">访问者模式(5.11)之对象结构</a>  <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39677689" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">访问者模式-好人打贱人</a>(这么分散！)<br />&#13;
<br />&#13;
<span style="color:#ffcc33">3.7 Null对象</span>  略<br />&#13;
</p>&#13;
</blockquote>&#13;
<p><br />&#13;
第5章 属性型模式 <br />&#13;
</p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><span style="color:#ffcc33">4.1虚域模式</span>  略<br />&#13;
4.3享元模式（4.6）<br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39346303">4.2 状态模式（5.8）</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39371487">有限状态机</a></p>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39371487"></a><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8575969">4.5 备忘录模式(5.6)</a><br />&#13;
</p>&#13;
</blockquote>&#13;
<p>第6章 委派型模式 154<br />&#13;
</p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><span style="color:#ffcc33">5.1 小方法模式</span>  略<br />&#13;
5.2 代理模式(4.7) </p>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p>5.2.1保护型代理(protection proxy) 106<br />&#13;
5.2.2动态代理(dynamic proxy) 106<br />&#13;
5.2.3 Java RMI (Remote Method Invocation，远程方法调用) 106</p>&#13;
</blockquote>&#13;
</blockquote>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38970499">5.5 装饰模式(4.4)</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/38978721">5.6 外观模式(4.5)</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39575455">5.7中介模式(5.5)</a></p>&#13;
</blockquote>&#13;
<p><br />&#13;
第7章 结构型模式213<br />&#13;
</p>&#13;
<blockquote style="margin:0px 0px 0px 40px; padding:0px; border:currentColor">&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39402607">6.1 责任链模式（5.1）</a><br />&#13;
<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39449253">6.2 组合模式（4.3）</a><br />&#13;
<span style="color:#ffcc00">6.3 迭代器模式</span><span style="white-space:pre"> </span>&#13;
 略</p>&#13;
</blockquote>&#13;
<p>第8章 目标型模式283</p>&#13;
<blockquote>&#13;
<p><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39304013">7.1 解释器模式</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39319493">解释器模式 2</a> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39317377" style="list-style:none; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; text-decoration:none; word-break:break-all; word-wrap:break-word">中序表达式&#13;
 to 后序表达式</a><br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
</blockquote>&#13;
<p>第9章 回顾<span style="white-space:pre"> </span>338</p>&#13;
<p><br />&#13;
附录<span style="white-space:pre"> </span><br />&#13;
附录A <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39481721" style="color:rgb(51,51,51); line-height:30px; font-family:Arial; text-decoration:none; white-space:nowrap">&#13;
Astah Community</a><br />&#13;
附录B 模式映射表<br />&#13;
附录C参考资料</p>&#13;
<br />&#13;
<p></p>&#13;
<hr />&#13;
<p></p>&#13;
<p><span style="font-family:KaiTi_GB2312; font-size:18px">在讲授“信息系统分析与设计”课程的时候，需要介绍一些设计模式；又由于在[编程导论]出版过程中，清华大学出版社的魏江江主任给我寄来了两本设计模式方面的书籍，因而yqj2065决定将设计模式方面的知识全面梳理一番。</span></p>&#13;
<p> ①推导出常用的设计模式。<br />&#13;
GoF在[设计模式•引言]中写道：“这本书的目的就是将面向对象软件的设计经验作为设计模式记录下来”。这种“记录”或者说归纳，对于广大程序员成功地共享设计经验作出了重大贡献。然而，<strong><span style="color:#ff0000">将设计模式作为前辈的经验总结或者既定事实，对于学习设计模式，特别是能够灵活使用设计模式是一个错误的诱导。</span></strong>许多设计模式的学习者如同拿一本字典学习英语一样。</p>&#13;
<p>本系列的基本方法是从各种假定出发，通过重构源代码或者遵循设计原则的编写源代码，以<strong>获得</strong>设计模式。<br />&#13;
虽然有点像作弊——知道最终结果的推导和证明，然而在推导的过程中，我们能够看到一个模式更多的变化、能够知道一个模式的优缺点/适应性、能够知道<span style="color:#cc0000"><strong>一个模式与其他模式的思路上的关联</strong></span>（而不是UML类图结构上的形似）。</p>&#13;
<p><br />&#13;
②解释更清晰和简明。这是站在巨人的肩膀上，对巨人的经典加以吹毛求疵。<br />&#13;
以我对面向对象的认识，[设计模式]中有许多解释显得晦涩、不严密、甚至错误。一个典型的例子是[设计模式]使用回调/好莱坞法则解释模板方法模式(5.10)，而在我看来，观察者模式则是回调/好莱坞法则的简单推论。[设计模式]对桥接模式(4.2)的解说非常难解。再例如，我认为备忘录模式(5.6)Memento对象可以是不变对象，不必要强调“封装性”。</p>&#13;
<p><br />&#13;
③补充常用的模式。如依赖注入等。</p>&#13;
<p>④以<strong><span style="color:#ff0000">内在的联系，将若干模式串联起来</span></strong>...</p>&#13;
<p></p>&#13;
<hr />&#13;
<p></p>&#13;
<p>2017.02.20：上课期间，本导航会改为<span style="color:#ff00"><strong>面向对象设计(Java)</strong></span>，汇集<span style="color:#6600">20:16-2017-1学期的教学资料</span>(32授课学时+12上机学时)。重新修改了许多博文内容。</p>&#13;
<p>(yqj2065提示：不时编辑中，转载请谨慎。欢迎拍砖。)</p>&#13;
<p>1.强烈建议学习设计模式(Java)时使用<strong><span style="color:#ff00">BlueJ</span></strong>。相关博文中，我不想画UML图而是采用BlueJ的界面截图。<br />&#13;
2.强烈建议学习设计模式时，除了文中列出的代码外，请你自己动手敲未列出的代码。</p>&#13;
<div style="top:177px">&#13;
<hr />&#13;
<p></p>&#13;
<p>2<a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/46669675">014-2015-2试题</a></p>&#13;
<div><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/8576491">23字真经</a> </div>&#13;
<div><a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39103857">如何学习设计模式</a></div>&#13;
<div> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39254507">学习难度系数排名</a></div>&#13;
<div> <a target="_blank" href="http://blog.csdn.net/yqj2065/article/details/39591119">乒乓球问题</a></div>&#13;
</div>&#13;
   &#13;
