

<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
设计模式分为三种类型，共23种。</div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px"><strong>创建型模式</strong>：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px"><strong>结构型模式</strong>：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px"><strong>行为型模式</strong>：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</div>&#13;
</li></ul>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
按字典序排列简介如下。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Abstract Factory（<a target="_blank" href="http://baike.baidu.com/view/1580269.htm" style="text-decoration:none; color:rgb(19,110,194)">抽象工厂模式</a>）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Adapter（<a target="_blank" href="http://baike.baidu.com/view/3371585.htm" style="text-decoration:none; color:rgb(19,110,194)">适配器模式</a>）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Bridge（<a target="_blank" href="http://baike.baidu.com/view/4520638.htm" style="text-decoration:none; color:rgb(19,110,194)">桥接模式</a>）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Builder（<a target="_blank" href="http://baike.baidu.com/view/7995255.htm" style="text-decoration:none; color:rgb(19,110,194)">建造者模式</a>）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Chain of Responsibility（职责链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Command（<a target="_blank" href="http://baike.baidu.com/view/1963264.htm" style="text-decoration:none; color:rgb(19,110,194)">命令模式</a>）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Composite（<a target="_blank" href="http://baike.baidu.com/view/3591789.htm" style="text-decoration:none; color:rgb(19,110,194)">组合模式</a>）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Decorator（<a target="_blank" href="http://baike.baidu.com/view/2787758.htm" style="text-decoration:none; color:rgb(19,110,194)">装饰模式</a>）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Facade（<a target="_blank" href="http://baike.baidu.com/view/2739662.htm" style="text-decoration:none; color:rgb(19,110,194)">外观模式</a>）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Factory Method（<a target="_blank" href="http://baike.baidu.com/view/1306799.htm" style="text-decoration:none; color:rgb(19,110,194)">工厂模式</a>）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Flyweight（<a target="_blank" href="http://baike.baidu.com/view/6143765.htm" style="text-decoration:none; color:rgb(19,110,194)">享元模式</a>）：运用共享技术有效地支持大量细粒度的对象。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Iterator（<a target="_blank" href="http://baike.baidu.com/view/9791023.htm" style="text-decoration:none; color:rgb(19,110,194)">迭代器模式</a>）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Mediator（<a target="_blank" href="http://baike.baidu.com/view/10351828.htm" style="text-decoration:none; color:rgb(19,110,194)">中介模式</a>）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Memento（<a target="_blank" href="http://baike.baidu.com/view/3591132.htm" style="text-decoration:none; color:rgb(19,110,194)">备忘录模式</a>）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Observer（<a target="_blank" href="http://baike.baidu.com/view/1854779.htm" style="text-decoration:none; color:rgb(19,110,194)">观察者模式</a>）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Prototype（<a target="_blank" href="http://baike.baidu.com/view/1781744.htm" style="text-decoration:none; color:rgb(19,110,194)">原型模式</a>）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Proxy（<a target="_blank" href="http://baike.baidu.com/view/2645890.htm" style="text-decoration:none; color:rgb(19,110,194)">代理模式</a>）：为其他对象提供一个代理以控制对这个对象的访问。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Singleton（<a target="_blank" href="http://baike.baidu.com/view/1859857.htm" style="text-decoration:none; color:rgb(19,110,194)">单例模式</a>）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class&#13;
 loaders）和序列化（serialization）时如何处理这些缺陷。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
State（<a target="_blank" href="http://baike.baidu.com/view/3589977.htm" style="text-decoration:none; color:rgb(19,110,194)">状态模式</a>）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Strategy（<a target="_blank" href="http://baike.baidu.com/view/2141079.htm" style="text-decoration:none; color:rgb(19,110,194)">策略模式</a>）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<a target="_blank" href="http://baike.baidu.com/view/1191246.htm" style="text-decoration:none; color:rgb(19,110,194)">Template Method</a>（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
Visitor（<a target="_blank" href="http://baike.baidu.com/view/3599899.htm" style="text-decoration:none; color:rgb(19,110,194)">访问者模式</a>）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
从下一节开始，详细描述以下每一种设计模式。</div>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_2" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_2"></a><a target="_blank" name="sub66964_3_2" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_2"></a><a target="_blank" name="基本模式_工厂模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_工厂模式"></a><span class="headline-content">工厂模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px; display:inline">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/8644ebf81a4c510fe341c6a26259252dd52aa584.html?fr=lemma&amp;ct=single" title="工厂模式（Factory）" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:84px"><img alt="工厂模式（Factory）" src="http://c.hiphotos.baidu.com/baike/s%3D250/sign=d39ca911ab014c081d3b2fa03a7a025b/8644ebf81a4c510fe341c6a26259252dd52aa584.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:84px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">工厂模式（Factory）</span></div>&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当一个类不知道它所必须创建的对象的类的时候。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当一个类希望由它的子类来指定它所创建的对象的时候。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_3" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_3"></a><a target="_blank" name="sub66964_3_3" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_3"></a><a target="_blank" name="基本模式_抽象工厂模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_抽象工厂模式"></a><span class="headline-content">抽象工厂模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/0b55b319ebc4b745aaa590aecdfc1e178a821550.html?fr=lemma&amp;ct=single" title="抽象工厂模式（Abstract Factory）" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:111px"><img alt="抽象工厂模式（Abstract Factory）" src="http://b.hiphotos.baidu.com/baike/s%3D250/sign=2af1ee8b9045d688a702b5a194c37dab/0b55b319ebc4b745aaa590aecdfc1e178a821550.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:111px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">抽象工厂模式（Abstract&#13;
 Factory）</span></div>&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个系统要独立于它的产品的创建、组合和表示时。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个系统要由多个产品系列中的一个来配置时。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当你要强调一系列相关的产品对象的设计以便进行联合使用时。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当你提供一个产品类库，而只想显示它们的接口而不是实现时。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_4" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_4"></a><a target="_blank" name="sub66964_3_4" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_4"></a><a target="_blank" name="基本模式_建造者模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_建造者模式"></a><span class="headline-content">建造者模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px; display:inline">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/9f2f070828381f30eaa0ad11ab014c086f06f0c8.html?fr=lemma&amp;ct=single" title="建造者模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:88px"><img alt="建造者模式" src="http://d.hiphotos.baidu.com/baike/s%3D250/sign=4123ccbbca95d143de76e32643f18296/9f2f070828381f30eaa0ad11ab014c086f06f0c8.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:88px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">建造者模式</span></div>&#13;
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当构造过程必须允许被构造的对象有不同的表示时。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_5" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_5"></a><a target="_blank" name="sub66964_3_5" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_5"></a><a target="_blank" name="基本模式_原型模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_原型模式"></a><span class="headline-content">原型模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/d8f9d72a6059252deef03dbc369b033b5ab5b9a6.html?fr=lemma&amp;ct=single" title="原型模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:116px"><img alt="原型模式" src="http://c.hiphotos.baidu.com/baike/s%3D250/sign=54dc081d087b020808c938e452d8f25f/d8f9d72a6059252deef03dbc369b033b5ab5b9a6.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:116px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">原型模式</span></div>&#13;
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">为了避免创建一个与产品类层次平行的工厂类层次时；或者</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_6" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_6"></a><a target="_blank" name="sub66964_3_6" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_6"></a><a target="_blank" name="基本模式_单例模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_单例模式"></a><span class="headline-content">单例模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/f703738da977391242e8a5d9fa198618377ae2b8.html?fr=lemma&amp;ct=single" title="单例模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:92px"><img alt="单例模式" src="http://b.hiphotos.baidu.com/baike/s%3D250/sign=5c9dc84c53da81cb4ae684c86267d0a4/f703738da977391242e8a5d9fa198618377ae2b8.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:92px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">单例模式</span></div>&#13;
保证一个类仅有一个实例，并提供一个访问它的全局访问点。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_7" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_7"></a><a target="_blank" name="sub66964_3_7" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_7"></a><a target="_blank" name="基本模式_适配器模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_适配器模式"></a><span class="headline-content">适配器模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/a5c27d1ed21b0ef4a620b8e6dfc451da80cb3eb9.html?fr=lemma&amp;ct=single" title="适配器模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:90px"><img alt="适配器模式" src="http://f.hiphotos.baidu.com/baike/s%3D250/sign=60a143c69058d109c0e3aeb7e159ccd0/a5c27d1ed21b0ef4a620b8e6dfc451da80cb3eb9.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:90px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">适配器模式</span></div>&#13;
将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你想使用一个已经存在的类，而它的接口不符合你的需求。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_8" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_8"></a><a target="_blank" name="sub66964_3_8" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_8"></a><a target="_blank" name="基本模式_桥接模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_桥接模式"></a><span class="headline-content">桥接模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
将抽象部分与它的实现部分分离&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/e824b899a9014c0869d8081d087b02087af4f4a2.html?fr=lemma&amp;ct=single" title="桥接模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:102px"><img alt="桥接模式" src="http://h.hiphotos.baidu.com/baike/s%3D250/sign=aa95c49b71f082022992963a7bfafb8a/e824b899a9014c0869d8081d087b02087af4f4a2.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:102px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">桥接模式</span></div>&#13;
，使它们都可以独立地变化。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时B r i d g e 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">（<a target="_blank" href="http://baike.baidu.com/view/824.htm" style="text-decoration:none; color:rgb(19,110,194)">C++</a>）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_9" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_9"></a><a target="_blank" name="sub66964_3_9" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_9"></a><a target="_blank" name="基本模式_组合模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_组合模式"></a><span class="headline-content">组合模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/6f061d950a7b020870101f5960d9f2d3562cc8a8.html?fr=lemma&amp;ct=single" title="组合模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:112px"><img alt="组合模式" src="http://d.hiphotos.baidu.com/baike/s%3D250/sign=514bb18749fbfbedd859317a48f1f78e/6f061d950a7b020870101f5960d9f2d3562cc8a8.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:112px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">组合模式</span></div>&#13;
将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你想表示对象的部分—整体层次结构。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_10" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_10"></a><a target="_blank" name="sub66964_3_10" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_10"></a><a target="_blank" name="基本模式_装饰模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_装饰模式"></a><span class="headline-content">装饰模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/d6ca7bcb0a46f21f921b7debf4246b600c33ae5e.html?fr=lemma&amp;ct=single" title="装饰模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:110px"><img alt="装饰模式" src="http://e.hiphotos.baidu.com/baike/s%3D250/sign=9f0e9189a38b87d65442ac1a37092860/d6ca7bcb0a46f21f921b7debf4246b600c33ae5e.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:110px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">装饰模式</span></div>&#13;
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">处理那些可以撤消的职责。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_11" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_11"></a><a target="_blank" name="sub66964_3_11" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_11"></a><a target="_blank" name="基本模式_门面模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_门面模式"></a><span class="headline-content">门面模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/902397dda144ad340f64a73fd2a20cf430ad85aa.html?fr=lemma&amp;ct=single" title="门面模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:97px"><img alt="门面模式" src="http://g.hiphotos.baidu.com/baike/s%3D250/sign=10c51c7f9252982201333ec6e7cb7b3b/902397dda144ad340f64a73fd2a20cf430ad85aa.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:97px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">门面模式</span></div>&#13;
为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当你需要构建一个层次结构的子系统时，使用门面模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_12" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_12"></a><a target="_blank" name="sub66964_3_12" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_12"></a><a target="_blank" name="基本模式_享元模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_享元模式"></a><span class="headline-content">享元模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:220px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/2fdda3cc7cd98d10620e2c89233fb80e7aec90ab.html?fr=lemma&amp;ct=single" title="享元模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:220px; height:135px"><img alt="享元模式" src="http://d.hiphotos.baidu.com/baike/s%3D220/sign=088719bb8544ebf86971633de9f8d736/2fdda3cc7cd98d10620e2c89233fb80e7aec90ab.jpg" style="border:0px; display:block; margin:0px auto; width:220px; height:135px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">享元模式</span></div>&#13;
运用共享技术有效地支持大量细粒度的对象。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个应用程序使用了大量的对象。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">完全由于使用大量的对象，造成很大的存储开销。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">对象的大多数状态都可变为外部状态。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_13" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_13"></a><a target="_blank" name="sub66964_3_13" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_13"></a><a target="_blank" name="基本模式_代理模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_代理模式"></a><span class="headline-content">代理模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/7c1ed21b0ef41bd5106ecb4c53da81cb39db3d4c.html?fr=lemma&amp;ct=single" title="代理模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:104px"><img alt="代理模式" src="http://f.hiphotos.baidu.com/baike/s%3D250/sign=eb4e84d0d309b3deefbfe36dfcbf6cd3/7c1ed21b0ef41bd5106ecb4c53da81cb39db3d4c.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:104px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">代理模式</span></div>&#13;
为其他对象提供一种代理以控制对这个对象的访问。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy模式常见情况：</div>&#13;
<ol class="custom_num  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-num-1-1 list-num-paddingleft-1" style="margin:0px; padding:0px 0px 0px 21px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。</div>&#13;
</li><li class="list-num-1-2 list-num-paddingleft-1" style="margin:0px; padding:0px 0px 0px 21px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">虚代理（Virtual Proxy）根据需要创建开销很大的对象。</div>&#13;
</li><li class="list-num-1-3 list-num-paddingleft-1" style="margin:0px; padding:0px 0px 0px 21px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。</div>&#13;
</li><li class="list-num-1-4 list-num-paddingleft-1" style="margin:0px; padding:0px 0px 0px 21px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：</div>&#13;
<ul class="custom_dot list-paddingleft-2" style="margin:0px; padding:0px 0px 0px 30px; list-style:none">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当第一次引用一个持久对象时，将它装入内存。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</div>&#13;
</li></ul>&#13;
</li></ol>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_14" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_14"></a><a target="_blank" name="sub66964_3_14" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_14"></a><a target="_blank" name="基本模式_职责链模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_职责链模式"></a><span class="headline-content">职责链模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:220px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/35a85edf8db1cb13ce411fabdf54564e92584b59.html?fr=lemma&amp;ct=single" title="职责链模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:220px; height:116px"><img alt="职责链模式" src="http://h.hiphotos.baidu.com/baike/s%3D220/sign=2a214f0ab0b7d0a27fc9039ffbee760d/35a85edf8db1cb13ce411fabdf54564e92584b59.jpg" style="border:0px; display:block; margin:0px auto; width:220px; height:116px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">职责链模式</span></div>&#13;
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的<a target="_blank" href="http://baike.baidu.com/view/5719652.htm" style="text-decoration:none; color:rgb(19,110,194)">耦合关系</a>。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">可处理一个请求的对象集合应被动态指定。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_15" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_15"></a><a target="_blank" name="sub66964_3_15" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_15"></a><a target="_blank" name="基本模式_命令模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_命令模式"></a><span class="headline-content">命令模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/77c6a7efce1b9d168becb9d9f1deb48f8c54645a.html?fr=lemma&amp;ct=single" title="命令模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:87px"><img alt="命令模式" src="http://g.hiphotos.baidu.com/baike/s%3D250/sign=4ce52c0feb50352ab561220d6342fb1a/77c6a7efce1b9d168becb9d9f1deb48f8c54645a.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:87px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">命令模式</span></div>&#13;
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_16" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_16"></a><a target="_blank" name="sub66964_3_16" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_16"></a><a target="_blank" name="基本模式_解析器模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_解析器模式"></a><span class="headline-content">解析器模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:220px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/f703738da977391242caa5d9fa198618377ae29e.html?fr=lemma&amp;ct=single" title="解析器模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:220px; height:118px"><img alt="解析器模式" src="http://b.hiphotos.baidu.com/baike/s%3D220/sign=5cbfc84c53da81cb4ae684cf6267d0a4/f703738da977391242caa5d9fa198618377ae29e.jpg" style="border:0px; display:block; margin:0px auto; width:220px; height:118px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">解析器模式</span></div>&#13;
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：</div>&#13;
<ul class="custom_dash list-paddingleft-2" style="margin:0px; padding:0px 0px 0px 30px; list-style:none">&#13;
<li class="list-dash list-dash-paddingleft" style="margin:0px; padding:0px 0px 0px 28px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。</div>&#13;
</li><li class="list-dash list-dash-paddingleft" style="margin:0px; padding:0px 0px 0px 28px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</div>&#13;
</li></ul>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_17" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_17"></a><a target="_blank" name="sub66964_3_17" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_17"></a><a target="_blank" name="基本模式_迭代器模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_迭代器模式"></a><span class="headline-content">迭代器模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/86d6277f9e2f070801b6f2daeb24b899a801f2bd.html?fr=lemma&amp;ct=single" title="" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:104px"><img alt="" src="http://b.hiphotos.baidu.com/baike/s%3D250/sign=263de2ce40a7d933bba8e3769d4ad194/86d6277f9e2f070801b6f2daeb24b899a801f2bd.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:104px" /></a></div>&#13;
提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">访问一个聚合对象的内容而无需暴露它的内部表示。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">支持对聚合对象的多种遍历。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_18" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_18"></a><a target="_blank" name="sub66964_3_18" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_18"></a><a target="_blank" name="基本模式_中介模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_中介模式"></a><span class="headline-content">中介模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/94cad1c8a786c917dbce7281cb3d70cf3ac757bc.html?fr=lemma&amp;ct=single" title="中介模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:77px"><img alt="中介模式" src="http://e.hiphotos.baidu.com/baike/s%3D250/sign=43e1856774c6a7efbd26af23cdfbafe9/94cad1c8a786c917dbce7281cb3d70cf3ac757bc.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:77px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">中介模式</span></div>&#13;
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">想定制一个分布在多个类中的行为，而又不想生成太多的子类。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_19" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_19"></a><a target="_blank" name="sub66964_3_19" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_19"></a><a target="_blank" name="基本模式_备忘录模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_备忘录模式"></a><span class="headline-content">备忘录模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/91529822720e0cf3ffc06d430846f21fbe09aa56.html?fr=lemma&amp;ct=single" title="备忘录模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:84px"><img alt="备忘录模式" src="http://a.hiphotos.baidu.com/baike/s%3D250/sign=f2be5c652c738bd4c021b534918a876c/91529822720e0cf3ffc06d430846f21fbe09aa56.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:84px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">备忘录模式</span></div>&#13;
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_20" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_20"></a><a target="_blank" name="sub66964_3_20" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_20"></a><a target="_blank" name="基本模式_观察者模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_观察者模式"></a><span class="headline-content">观察者模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/fc1f4134970a304ebb028342d3c8a786c9175c61.html?fr=lemma&amp;ct=single" title="观察者模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:98px"><img alt="观察者模式" src="http://g.hiphotos.baidu.com/baike/s%3D250/sign=054d594ad762853596e0d524a0ee76f2/fc1f4134970a304ebb028342d3c8a786c9175c61.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:98px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">观察者模式</span></div>&#13;
定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_21" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_21"></a><a target="_blank" name="sub66964_3_21" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_21"></a><a target="_blank" name="基本模式_状态模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_状态模式"></a><span class="headline-content">状态模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/d4628535e5dde711e1e3604ea5efce1b9d166150.html?fr=lemma&amp;ct=single" title="状态模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:100px"><img alt="状态模式" src="http://b.hiphotos.baidu.com/baike/s%3D250/sign=b8e6034634d3d539c53d08c60a86e927/d4628535e5dde711e1e3604ea5efce1b9d166150.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:100px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">状态模式</span></div>&#13;
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_22" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_22"></a><a target="_blank" name="sub66964_3_22" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_22"></a><a target="_blank" name="基本模式_策略模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_策略模式"></a><span class="headline-content">策略模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:250px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/faf2b2119313b07e84de73b00ed7912397dd8c22.html?fr=lemma&amp;ct=single" title="策略模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:250px; height:86px"><img alt="策略模式" src="http://g.hiphotos.baidu.com/baike/s%3D250/sign=73334373b0fb43161e1f7d7f10a54642/faf2b2119313b07e84de73b00ed7912397dd8c22.jpg" style="border:0px; display:block; margin:0px auto; width:250px; height:86px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">策略模式</span></div>&#13;
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_23" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_23"></a><a target="_blank" name="sub66964_3_23" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_23"></a><a target="_blank" name="基本模式_模版模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_模版模式"></a><span class="headline-content">模版模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:220px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/4610b912c8fcc3ce71f3ea8b9045d688d43f2052.html?fr=lemma&amp;ct=single" title="模板模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:220px; height:125px"><img alt="模板模式" src="http://c.hiphotos.baidu.com/baike/s%3D220/sign=52f08fadbe315c6047956cedbdb0cbe6/4610b912c8fcc3ce71f3ea8b9045d688d43f2052.jpg" style="border:0px; display:block; margin:0px auto; width:220px; height:125px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">模板模式</span></div>&#13;
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。</div>&#13;
</li></ul>&#13;
<h3 class="headline-2" style="margin:20px 0px 12px; padding:0px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; line-height:19px; clear:both; font-weight:500">&#13;
<a target="_blank" name="3_24" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="3_24"></a><a target="_blank" name="sub66964_3_24" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="sub66964_3_24"></a><a target="_blank" name="基本模式_访问者模式" class="anchor-2 " style="color:rgb(19,110,194); position:relative; display:block; top:-50px" id="基本模式_访问者模式"></a><span class="headline-content">访问者模式</span></h3>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>意图</strong></div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<div class="lemma-picture text-pic layout-right" style="border:1px solid rgb(224,224,224); overflow:hidden; text-indent:0px; margin:0px 0px 3px 20px; position:relative; float:right; clear:right; width:220px">&#13;
<a target="_blank" class="image-link nslog:9317" href="http://baike.baidu.com/picture/66964/66964/0/f703738da97739124314a6d9fa198618367ae25c.html?fr=lemma&amp;ct=single" title="访问者模式" style="text-decoration:none; color:rgb(19,110,194); display:block; width:220px; height:171px"><img alt="访问者模式" src="http://a.hiphotos.baidu.com/baike/s%3D220/sign=5d61cb4c53da81cb4ae684cf6267d0a4/f703738da97739124314a6d9fa198618367ae25c.jpg" style="border:0px; display:block; margin:0px auto; width:220px; height:171px" /></a><span class="description" style="display:block; color:rgb(85,85,85); font-size:12px; font-family:宋体; word-wrap:break-word; word-break:break-all; line-height:15px; padding:8px 7px; min-height:12px; border-top-width:1px; border-top-style:solid; border-top-color:rgb(224,224,224)">访问者模式</span></div>&#13;
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</div>&#13;
<div class="para" style="color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px">&#13;
<strong>适用性</strong></div>&#13;
<ul class="custom_dot  para-list list-paddingleft-1" style="margin:0px 0px 14px 2em; padding:0px; list-style:none; font-family:arial,&#x5B8B;&#x4F53;,sans-serif; font-size:14px; line-height:24px">&#13;
<li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。</div>&#13;
</li><li class="list-dot list-dot-paddingleft" style="margin:0px; padding:0px 0px 0px 14px; list-style-type:none">&#13;
<div class="para" style="color:rgb(51,51,51); margin:0px">定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</div>&#13;
</li></ul>&#13;
   &#13;
