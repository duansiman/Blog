

<p>开篇又要给自己找接口了，2号回上海，在高速上堵了 14个小时，导致没有按时更新博客，BS自己！</p>&#13;
<p><br />&#13;
</p>&#13;
<p><strong>一、定义（概念）</strong></p>&#13;
<p><span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px"><span style="white-space:pre"></span>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解</span><span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">释语言中的句子。</span><br style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px" />&#13;
<br />&#13;
</p>&#13;
<p><strong>二、适用场景</strong></p>&#13;
<p><span style="font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px">如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。</span></p>&#13;
<p><span style="font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px">这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。而且当文法简单、效率不是关键问题的时候效果最好。</span><br />&#13;
</p>&#13;
<p><span style="font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px"><br />&#13;
</span></p>&#13;
<p><span style="font-family:Verdana,Lucida Grande,Arial,Helvetica,sans-serif"><span style="line-height:18px">涉及角色：</span></span></p>&#13;
<p><span style="font-family:Verdana,Lucida Grande,Arial,Helvetica,sans-serif"><span style="line-height:18px"><br />&#13;
　　（1）抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。<br />&#13;
<br />&#13;
<br />&#13;
　　（2）终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。<br />&#13;
<br />&#13;
<br />&#13;
　　（3）非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+"就是非终结符，解析“+”的解释器就是一个非终结符表达式。<br />&#13;
<br />&#13;
<br />&#13;
　　（4）环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。<br />&#13;
</span></span></p>&#13;
<p><span style="font-family:Verdana,Lucida Grande,Arial,Helvetica,sans-serif"><span style="line-height:18px"><br />&#13;
</span></span></p>&#13;
<p><strong>三、UML</strong></p>&#13;
<p><img src="http://pic002.cnblogs.com/images/2012/73404/2012121212481328.gif" alt="" /><br />&#13;
</p>&#13;
<p><strong>四、代码</strong></p>&#13;
<p></p>&#13;
<p style="margin:10px auto; font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px">&#13;
计算：(a*b)/(a-b+2)</p>&#13;
<p style="margin:10px auto; font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px">&#13;
public class Context<br />&#13;
{<br />&#13;
    private final Map&lt;String, Integer&gt; valueMap = new HashMap&lt;String, Integer&gt;();<br />&#13;
<br />&#13;
    public void addValue(final String key, final int value)<br />&#13;
    {<br />&#13;
        valueMap.put(key, Integer.valueOf(value));<br />&#13;
    }<br />&#13;
<br />&#13;
    public int getValue(final String key)<br />&#13;
    {<br />&#13;
        return valueMap.get(key).intValue();<br />&#13;
    }<br />&#13;
}<br />&#13;
<br />&#13;
public abstract class AbstractExpression<br />&#13;
{<br />&#13;
    public abstract int interpreter(Context context);<br />&#13;
}<br />&#13;
<br />&#13;
public class AddNonterminalExpression extends AbstractExpression<br />&#13;
{<br />&#13;
    private final AbstractExpression left;<br />&#13;
    private final AbstractExpression right;<br />&#13;
<br />&#13;
    public AddNonterminalExpression(final AbstractExpression left, final AbstractExpression right)<br />&#13;
    {<br />&#13;
        this.left = left;<br />&#13;
        this.right = right;<br />&#13;
    }<br />&#13;
<br />&#13;
    @Override<br />&#13;
    public int interpreter(final Context context)<br />&#13;
    {<br />&#13;
        return this.left.interpreter(context) + this.right.interpreter(context);<br />&#13;
    }<br />&#13;
<br />&#13;
}<br />&#13;
<br />&#13;
public class DivisionNonterminalExpression extends AbstractExpression<br />&#13;
{<br />&#13;
    private final AbstractExpression left;<br />&#13;
    private final AbstractExpression right;<br />&#13;
<br />&#13;
    public DivisionNonterminalExpression(final AbstractExpression left, final AbstractExpression right)<br />&#13;
    {<br />&#13;
        this.left = left;<br />&#13;
        this.right = right;<br />&#13;
    }<br />&#13;
<br />&#13;
    @Override<br />&#13;
    public int interpreter(final Context context)<br />&#13;
    {<br />&#13;
        final int value = this.right.interpreter(context);<br />&#13;
        if (value != 0)<br />&#13;
        {<br />&#13;
            return this.left.interpreter(context) / value;<br />&#13;
        }<br />&#13;
        return -1111;<br />&#13;
    }<br />&#13;
<br />&#13;
}<br />&#13;
<br />&#13;
public class MultiplyNonterminalExpression extends AbstractExpression<br />&#13;
{<br />&#13;
    private final AbstractExpression left;<br />&#13;
    private final AbstractExpression right;<br />&#13;
<br />&#13;
    public MultiplyNonterminalExpression(final AbstractExpression left, final AbstractExpression right)<br />&#13;
    {<br />&#13;
        this.left = left;<br />&#13;
        this.right = right;<br />&#13;
    }<br />&#13;
<br />&#13;
    @Override<br />&#13;
    public int interpreter(final Context context)<br />&#13;
    {<br />&#13;
        return this.left.interpreter(context) * this.right.interpreter(context);<br />&#13;
    }<br />&#13;
<br />&#13;
}<br />&#13;
<br />&#13;
public class SubtractNonterminalExpression extends AbstractExpression<br />&#13;
{<br />&#13;
    private final AbstractExpression left;<br />&#13;
    private final AbstractExpression right;<br />&#13;
<br />&#13;
    public SubtractNonterminalExpression(final AbstractExpression left, final AbstractExpression right)<br />&#13;
    {<br />&#13;
        this.left = left;<br />&#13;
        this.right = right;<br />&#13;
    }<br />&#13;
<br />&#13;
    @Override<br />&#13;
    public int interpreter(final Context context)<br />&#13;
    {<br />&#13;
        return this.left.interpreter(context) - this.right.interpreter(context);<br />&#13;
    }<br />&#13;
}<br />&#13;
<br />&#13;
public class TerminalExpression extends AbstractExpression<br />&#13;
{<br />&#13;
    private final int i;<br />&#13;
<br />&#13;
    public TerminalExpression(final int i)<br />&#13;
    {<br />&#13;
        this.i = i;<br />&#13;
    }<br />&#13;
<br />&#13;
    @Override<br />&#13;
    public int interpreter(final Context context)<br />&#13;
    {<br />&#13;
        return this.i;<br />&#13;
    }<br />&#13;
<br />&#13;
}<br />&#13;
<br />&#13;
public class Client<br />&#13;
{<br />&#13;
    //(a*b)/(a-b+2)<br />&#13;
    public static void main(final String[] args)<br />&#13;
    {<br />&#13;
        final Context context = new Context();<br />&#13;
        context.addValue("a", 7);<br />&#13;
        context.addValue("b", 8);<br />&#13;
        context.addValue("c", 2);<br />&#13;
<br />&#13;
        final MultiplyNonterminalExpression multiplyValue = new MultiplyNonterminalExpression(new TerminalExpression(<br />&#13;
                context.getValue("a")), new TerminalExpression(context.getValue("b")));<br />&#13;
<br />&#13;
        final SubtractNonterminalExpression subtractValue = new SubtractNonterminalExpression(new TerminalExpression(<br />&#13;
                context.getValue("a")), new TerminalExpression(context.getValue("b")));<br />&#13;
<br />&#13;
        final AddNonterminalExpression addValue = new AddNonterminalExpression(subtractValue, new TerminalExpression(<br />&#13;
                context.getValue("c")));<br />&#13;
<br />&#13;
        final DivisionNonterminalExpression divisionValue = new DivisionNonterminalExpression(multiplyValue, addValue);<br />&#13;
<br />&#13;
        System.out.println(divisionValue.interpreter(context));<br />&#13;
    }<br />&#13;
}<br />&#13;
<br />&#13;
结果:</p>&#13;
<p style="margin:10px auto; font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif; line-height:18px">&#13;
56</p>&#13;
<br />&#13;
<p><strong>五、总结（优点与缺点）</strong></p>&#13;
<p><strong>优点：</strong></p>&#13;
<p>1）易于改变和扩展方法</p>&#13;
<p>2）易于实现方法</p>&#13;
<p>3）增加了新的解释表达式的方法<br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
<p><strong>缺点：</strong></p>&#13;
<p>4）复杂的方法难以维护</p>&#13;
<p><strong>注意事项</strong><br />&#13;
       解释器模式真的是一个比较少用的模式，因为对它的维护实在是太麻烦了，想象一下，一坨一坨的非终结符解释器，假如不是事先对文法的规则了如指掌，或者是文法特别简单，则很难读懂它的逻辑。解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。<br />&#13;
</p>&#13;
<p><br />&#13;
</p>&#13;
   &#13;
