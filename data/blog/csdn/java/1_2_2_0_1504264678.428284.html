

<p><span style="white-space:pre"></span><span style="font-size:18px"><span style="white-space:pre"></span>有的时候我一直在想，Spring到底是什么？Spring到底能干什么？我们为什么要用spring?我个人认为spring其实就是一个集成框架，他把一些基础的代码都给封装好了，我们只需要按照spring的一套规范去使用就好了。同时spring也是一个容器<span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">Spring提供了</span><a target="_blank" href="http://baike.baidu.com/view/1865230.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">面向切面编程</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">的丰富支持，允许通过分离应用的业务</span><a target="_blank" href="http://baike.baidu.com/view/1838.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">逻辑</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">与</span><a target="_blank" href="http://baike.baidu.com/view/25302.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">系统</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">级</span><a target="_blank" href="http://baike.baidu.com/view/133203.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">服务</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">（例如审计（auditing）和</span><a target="_blank" href="http://baike.baidu.com/view/121511.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">事务</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">（</span><a target="_blank" href="http://baike.baidu.com/view/2368136.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">transaction</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">）管理）进行</span><a target="_blank" href="http://baike.baidu.com/view/2424328.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">内聚性</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">的开发。</span><a target="_blank" href="http://baike.baidu.com/view/5314991.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">应用对象</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或</span><a target="_blank" href="http://baike.baidu.com/view/121511.htm" style="text-decoration:none; color:rgb(19,110,194); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">事务</a><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">支持。</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="white-space:pre"></span>其中最主要的就是ioc 依赖注入，控制反转。还有aop面向切面编程，这个在以后再去讨论。还有数据访问和集成，任何应用程序其核心就在于对于数据的访问和操作，数据有多种表现形式，如数据表，如xml,消息等，而每种数据又有每种不同的数据访问技术，如hibernate,mybatis等。这样操作起来就很麻烦，不利于整合。而spring为我们提供了一套基于Dao的开发抽象层。它把我们所需要的整合技术都封装到里面，还把所有的访问数据的检查时异常转换为非检查时异常，在Dao层有一套完整的异常体系。同时spring对于数据访问层的各种模板化技术进行了薄层封装。讲模板化的代码给隐藏起来，简化我们的代码，这样spring就建立起来了数据形式和访问技术无关的dao层，借助aop技术，spring提供了声明事务话功能。</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="white-space:pre"></span>Web及远程访问，spring提供了一套类似于struts的mvc的框架，叫做springmvc。他对web的访问和控制进行了很多封装，我们可以通过注解的方式来调用，他也对很多service框架进行了整合，使用springmvc会大大简化我们的开发。</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="white-space:pre"></span><span style="white-space:pre"></span>现在来做一个登陆功能来解析spring。附上一张自己理解的springmvc流程图先</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><img src="http://img.blog.csdn.net/20150430175736997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="white-space:pre"></span>下面就以一个登陆系统来理解springmvc的一些简单原理的工作流程</span></span></p>&#13;
<p><span style="font-size:18px"><span style="color:rgb(51,51,51); font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px">首先得在web.xml里面注册一个springmvc的前端控制器</span></span></p>&#13;
<p><span style="font-size:18px"><span style="font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="color:rgb(0,0,255); font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2">Servelt DispatcherServlet&#13;
</span><span style="font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2"><span style="color:#333333">如果我们不使用自定义的名字和位置的话，他默认是在web-inf下面的"servlet-name"+ "-servlet.xml"文件。</span></span><br />&#13;
</span></span></p>&#13;
<p><span style="font-size:18px"><span style="font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2"><span style="color:#333333">然后我们让这服务器启动的时候自动去加载这个类</span></span></span></span></p>&#13;
<p><span style="font-size:18px"><span style="font-family:arial,宋体,sans-serif; line-height:24px; text-indent:28px"><span style="font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2"><span style="color:#3366ff; background-color:rgb(255,255,255)"><strong>&lt;!--&#13;
 配置 DispatcherServlet --&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;servlet&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;!-- 配置 DispatcherServlet 的一个初始化参数: 配置 SpringMVC 配置文件的位置和名称 --&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;!-- <br />&#13;
<span style="white-space:pre"></span>实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的.<br />&#13;
<span style="white-space:pre"></span>默认的配置文件为: /WEB-INF/&lt;servlet-name&gt;-servlet.xml<br />&#13;
<span style="white-space:pre"></span>--&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;!--  <br />&#13;
<span style="white-space:pre"></span>&lt;init-param&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;/init-param&gt;<br />&#13;
<span style="white-space:pre"></span>--&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;/servlet&gt;<br />&#13;
<br />&#13;
<span style="white-space:pre"></span>&lt;servlet-mapping&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;url-pattern&gt;/&lt;/url-pattern&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;/servlet-mapping</strong>&gt;</span></span></span></span></p>&#13;
<p><span style="font-size:14px; line-height:26px; font-family:微软雅黑; orphans:2; text-indent:28px; widows:2"><span style="color:#333333">加载到servlet拦截器的时候，他会去检查里面的代码，看看有没有错误。</span></span></p>&#13;
<p><span style="font-size:14px; line-height:26px; font-family:微软雅黑; orphans:2; text-indent:28px; widows:2"><span style="color:#333333">接下来要写拦截器里面的配置代码</span></span></p>&#13;
<p><span style="font-size:14px; line-height:26px; font-family:微软雅黑; orphans:2; text-indent:28px; widows:2"><span style="color:#3366ff"><strong>&lt;!-- 配置自定扫描的包 --&gt;1<br />&#13;
<span style="white-space:pre"></span>&lt;context:component-scan base-package="com.cn.dao"&gt;&lt;/context:component-scan&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;context:component-scan base-package="com.cn.service"&gt;&lt;/context:component-scan&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;context:component-scan base-package="com.cn.control"&gt;&lt;/context:component-scan&gt;<br />&#13;
<span style="white-space:pre"></span><br />&#13;
<span style="white-space:pre"></span>&lt;!-- 配置视图解析器: 如何把 handler 方法返回值解析为实际的物理视图 --&gt;2<br />&#13;
<span style="white-space:pre"></span>&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;property name="prefix" value="/"&gt;&lt;/property&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;/bean&gt;<br />&#13;
<span style="white-space:pre"></span>&lt;!-- 在实际开发中通常都需配置 mvc:annotation-driven 标签 --&gt;3<br />&#13;
<span style="white-space:pre"></span>&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</strong></span><br />&#13;
</span></p>&#13;
<p>第一个段代码主要是开启springmvc的注解，让他去自动扫描包里面带有注解的类，如果扫描到了这个包里面的类，他就会去自动装载这些类，完成它的创建。</p>&#13;
<p>第二段代码主要是配置我们的视图解析器，prefix会去解析请求的视图，而suffix会解析返回的结果视图一般是进行拼装返回结果的。</p>&#13;
<p>第三段代码，<span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px">&lt;mvc:annotation-driven /&gt; 是一种简写形式，完全可以手动配置替代这种简写形式，简写形式可以让初学都快速应用默认配置方案。&lt;mvc:annotation-driven /&gt; 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter&#13;
 两个bean,是spring MVC为@Controllers分发请求所必须的。</span><br style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px" />&#13;
<span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px">并提供了：数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持，@Valid支持，读写XML的支持（JAXB），读写JSON的支持（Jackson）。</span></p>&#13;
<p><span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px">现在我们来写一个视图层，让他发送一个请求；</span></p>&#13;
<p><span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px"><img src="http://img.blog.csdn.net/20150505112045832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px">点击提交按钮会经过如下几步</span></p>&#13;
<p><span style="font-family:Tahoma,'Microsoft Yahei'; font-size:14px; line-height:26px"></span></p>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="color:rgb(0,0,255)"><span style="font-size:14px">1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</span></span></div>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="font-size:14px">      <span style="color:rgb(0,0,255)">2. </span></span><span style="font-size:14px"><span style="color:rgb(0,0,255)">DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</span></span></div>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="font-size:14px">    <span style="color:rgb(0,0,255)">  3. </span></span><span style="font-size:14px"><span style="color:rgb(0,0,255)">DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter</span>。（<span style="color:rgb(255,0,0)"><strong>附注</strong>：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法</span>）</span></div>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="font-size:14px; color:rgb(0,0,255)"> 4.  提取Request中的模型数据，填充Handler入参，一般情况下使用最多的是根据@RequestMapping("value=/login")开始匹配并执行Handler（Controller)</span><span style="font-size:14px">。 </span></div>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="font-size:14px"><span style="color:rgb(0,0,255); font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2">5.这个handler会依次的去调用service和dao方法。最后返回一个我们所需要的结果集字符串，可以是一个string类型的，也可以是一个modelandview类型的，也可以是一段json代码等等。</span></span></div>&#13;
<div style="line-height:26px; font-family:&#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size:18px; orphans:2; widows:2">&#13;
<span style="font-size:14px"><span style="color:rgb(0,0,255); font-family:微软雅黑; font-size:14px; line-height:26px; orphans:2; widows:2">6.这个结果集会去根据我们配置的视图解析器来返回一个我们加工好的视图。spring没有限制我们返回的视图类型，他可以是JSP也可以是html。</span></span></div>&#13;
<p></p>&#13;
   &#13;
