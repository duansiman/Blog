

<p><span style="white-space:pre"></span><span style="font-size:18px"><span style="white-space:pre"></span>简述一下IOC的设计概念以及设计思想以及注入方式，然后再认识一下java反射技术。</span></p>&#13;
<p><span style="font-size:18px">IOC大家都是知道是spring的核心，他的中文名字叫做控制反转，即当一个类里面包含另一个类的时候，我们通常把这种类称为包含类，或者一个类和另外一个类组合成了一个类，这种叫做组合类。当我们需要使用这些类的时候不得不去创建或者去引用这几个类。再打个比方，面向对象的设计理念就是万物皆对象，即当我们需要去银行取钱的时候，就需要先去创建一个银行的类，再创建人这个类，并且要把他们实例化。以上几种情景都会提高类与类的耦合度，不太符合软件的设计理念。所以spring用到了设计模式，代码解耦，代码优化等技术来实现了IOC这一重要理念和技术。</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>当我们使用了IOC这个技术之后，对象之间的创建和关联，以及销毁都交给spring去管理，所以我们也称spring为一个容器。也有人把这个技术叫做依赖注入，下面用一个小例子来阐述一下。</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>我们就以银行取款项目来阐述一下。</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"><img src="http://img.blog.csdn.net/20150506101259579?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></span></span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>如上图所看到的，我们模拟去银行取钱的场景。假设A公司的老板现在要去取10万块钱来奖励员工。但是他手里有三张银行卡，分别是邮政银行，工商银行和农业银行的，他现在不知道要有哪张好，他决定看哪家近，就用哪家。那么这个时候我们得去创建一个银行工厂类，里面专门用来，生产银行这个类，这样我们不需要关心他具体去用哪个银行类。现在A老板觉得工商银行最近于是他走到了工商银行，我们都知道每个银行里面的取款机都分为两种，一种是可以存取的，一种是只能取得。那我们得再去创建一个取款机工厂了，让他来生产取款机。现在A老板用了存取款机已经成功取到钱了。这就是一个工厂模式的场景。但是这样一来，他们之间的耦合度还是会有，现在是</span></p>&#13;
<p><span style="font-size:18px">A老板-银行工厂-工商银行-取款机工厂-存取款机；他们几个是精密联系的，如果说这个工厂类坏了，生产不出来工商银行了，那怎么办。那么他后面的都执行不了。这个情况也是有可能的，比如内存溢出。这个时候我们就能体现出IOC的好处了。</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506104007737?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>现在我们可以看到所有的类都指向IOC这个容器，当我们需要哪个类的时候，它就给我拿出来哪个类进行使用，当我们使用这些类的时候，他也会帮我们创建好他们之间的关系，而使用完成之后他又会帮我们销毁这些东西。所以说我们把创建这些对象的权利都交给了IOC，也叫依赖注入，就是说我们得到这些类的方式都依靠IOC这个容器。IOC的注入方式主要的还是运用到了JAVA反射技术。</span></p>&#13;
<p><span style="font-size:18px">下面来看一下他注入的方式和原理：</span></p>&#13;
<p><span style="font-size:18px">在开发中我们运用的最多的就是使用xml以bean的方式来注入，它有三种注入方式，下面来对比一下</span></p>&#13;
<p><span style="font-size:18px">1.Set注入</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>set注入就是在使用这个类的时候添加Set方法，spring的配置文件会根据你配置的name来找到你要注入的哪个类，根据ref来找到你的类的引用名字，从而实现注入。</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506134950480?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506134813920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>这样就可以实例化我们的Man类，并且能够使他和我们的testService类产生关系。他是根据set方法来的，我们的set方法可以有返回值也没有没有返回值，Man既可以大写也可以小写，它是根据我们xml里面配置的ref的值和set进行拼接从而找到这个方法进行注入。public String setman(Man man);我写成这样也是没问题的。不过不推荐。</span></p>&#13;
<p><span style="font-size:18px">2.构造器注入</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>构造器注入就是我们为这个类添加一个构造方法。在构造方法里面把我们需要依赖的类给传入进来，由IOC为我们创建这个类和构造他们之间的关系；</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506143712232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506143938429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px">3.接口注入</span></p>&#13;
<p><span style="font-size:18px">接口注入顾名思义就是根据接口来注入改实例类。</span></p>&#13;
<p><span style="font-size:18px"><img src="http://img.blog.csdn.net/20150506151305972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhb2RlaG9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</span></p>&#13;
<p><span style="font-size:18px"><span style="white-space:pre"></span>我们先创建一个接口，然后让我们的man类来实现这个接口，再创建一个工程类，这个类返回接口的实例也就是man这个类。</span><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:18px"><span style="line-height:25.2000007629395px">最后去实例化工厂类，让他去执行里面的方法，从而得到我们想要的类。</span></span></p>&#13;
<p><span style="font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:18px"></span></p>&#13;
<div style="line-height:25.2000007629395px; font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px">&#13;
通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在&lt;bean&gt;标签后面添加一个属性：</div>&#13;
<div style="font-family:Helvetica,Tahoma,Arial,sans-serif">&#13;
<div class="dp-highlighter" id="" style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; width:679px; overflow:auto; margin-left:9px; padding:1px; word-break:break-all; word-wrap:break-word">&#13;
<div class="bar">&#13;
<div class="tools" style="line-height:25.2000007629395px; font-size:12px; padding:3px; margin:0px; font-weight:bold; background-color:transparent">&#13;
<span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)">&lt;bean name=</span><span class="string" style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; color:blue; background-color:rgb(250,250,250)">"..."</span><span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)"> </span><span class="keyword" style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; color:rgb(127,0,85); font-weight:bold; background-color:rgb(250,250,250)">class</span><span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)">=</span><span class="string" style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; color:blue; background-color:rgb(250,250,250)">"..."</span><span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)"> scope=</span><span class="string" style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; color:blue; background-color:rgb(250,250,250)">"prototype"</span><span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)">&gt; </span></div>&#13;
<div class="tools" style="line-height:25.2000007629395px; font-size:12px; padding:3px; margin:0px; font-weight:bold; background-color:transparent">&#13;
<span style="font-family:Monaco,'DejaVu Sans Mono','Bitstream Vera Sans Mono',Consolas,'Courier New',monospace; line-height:18px; background-color:rgb(250,250,250)">另外要注意的是我们通过set方式来注入的时候，他会去执行这个类里面所有的set方法，而使用构造器去注入的时候则会去调用类本身的构造器。</span></div>&#13;
<div class="tools" style="line-height:25.2000007629395px; font-size:12px; padding:3px; margin:0px; font-weight:bold; background-color:transparent">&#13;
<br />&#13;
</div>&#13;
<div class="tools" style="padding:3px; margin:0px"><span style="line-height:18px; background-color:rgb(250,250,250)">最后说一说java反射的原理。</span></div>&#13;
<div class="tools" style="padding:3px; margin:0px"><span style="line-height:18px; background-color:rgb(250,250,250)"><span style="color:rgb(51,51,51); font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:24px; background-color:rgb(245,245,245)">在反射中，首先要读取applicationContext.xml配置文件中的信息，通过forName（）（其他方法也可以的）加载类（根据从配置文件中获取的完整的类路径来加载），获取class对象，利用Class类中的getDeclaredFields() 获取到类属性，根据属性名称类拼接setter方法，获取属性的类型（），通过newInstance（）方法实例化类,获取set类方法的对象， 来执行Method类中的invoke（）方法来对类中属性进行setter方法赋值。</span><br />&#13;
</span></div>&#13;
<div class="tools" style="line-height:25.2000007629395px; padding:3px; margin:0px; font-weight:bold; background-color:transparent">&#13;
<br />&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p></p>&#13;
   &#13;
