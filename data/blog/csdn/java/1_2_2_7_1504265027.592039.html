

<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<strong>享元<span style="font-family:'ms shell dlg'; font-size:14px; line-height:28px"><strong>（</strong></span><span style="font-family:'ms shell dlg'; font-size:14px; line-height:28px"><strong>Flyweight</strong></span><span style="font-family:'ms shell dlg'; font-size:14px; line-height:28px"><strong>）</strong></span>模式：<br />&#13;
</strong></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
Flyweight在拳击比赛中指最轻量级，即“蝇量级”或“雨量级”，这里选择使用“享元模式”的意译，是因为这样更能反映模式的用意。享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。</p>&#13;
<hr style="font-family:'ms shell dlg'; font-size:14px; line-height:28px" />&#13;
<h1 style="margin:0px; height:auto; padding-right:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:16px; border-bottom-style:none; line-height:1.5">&#13;
Java中的String类型</h1>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　在JAVA语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。String a="abc"，其中"abc"就是一个字符串常量。</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span><span style="line-height:1.5!important"> Test {

    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">static</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> main(String[] args) {
        
        String a </span>= "abc"<span style="line-height:1.5!important">;
        String b </span>= "abc"<span style="line-height:1.5!important">;
        System.out.println(a</span>==<span style="line-height:1.5!important">b);
        
    }
}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　上面的例子中结果为：<span style="color:rgb(0,0,255)">true</span> ，这就说明a和b两个引用都指向了常量池中的同一个字符串常量"abc"。这样的设计避免了在创建N多相同对象时所产生的不必要的大量的资源消耗。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
 </p>&#13;
<h1 style="margin:0px; height:auto; padding-right:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:16px; border-bottom-style:none; line-height:1.5">&#13;
享元模式的结构</h1>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分<strong>内蕴状态(Internal State)</strong>和<strong>外蕴状态(External State)。</strong></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<strong>　　</strong>一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　享元模式可以分成<strong>单纯享元模式</strong>和<strong>复合享元模式</strong>两种形式。</p>&#13;
<h1 style="margin:0px; height:auto; padding-right:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:16px; border-bottom-style:none; line-height:1.5">&#13;
单纯享元模式　　</h1>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　在单纯的享元模式中，所有的享元对象都是可以共享的。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<img src="http://blog.csdn.net/singit/article/details/54693184" alt="" style="border:0px; max-width:900px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　单纯享元模式所涉及到的角色如下：</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　<strong>抽象享元(Flyweight)角色 ：</strong>给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　<strong>具体享元(Concrete<strong>Flyweight</strong>)角色：</strong>实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　<strong><strong>●　　<strong>享元工厂(FlyweightFactory)角色</strong></strong></strong> ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p>&#13;
<h3 style="font-size:16px; border-bottom-width:1px; border-bottom-style:dotted; border-bottom-color:rgb(214,214,214); line-height:1.5; margin:10px 0px; font-family:'ms shell dlg'">&#13;
源代码</h3>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　抽象享元角色类</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">interface</span><span style="line-height:1.5!important"> Flyweight {
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">一个示意性方法，参数state是外蕴状态</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> operation(String state);
}</span></pre>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span> ConcreteFlyweight <span style="color:rgb(0,0,255); line-height:1.5!important">implements</span><span style="line-height:1.5!important"> Flyweight {
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">private</span> Character intrinsicState = <span style="color:rgb(0,0,255); line-height:1.5!important">null</span><span style="line-height:1.5!important">;
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 构造函数，内蕴状态作为参数传入
     * </span><span style="color:rgb(128,128,128); line-height:1.5!important">@param</span><span style="color:rgb(0,128,0); line-height:1.5!important"> state
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span><span style="line-height:1.5!important"> ConcreteFlyweight(Character state){
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">this</span>.intrinsicState =<span style="line-height:1.5!important"> state;
    }
    
    
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span><span style="line-height:1.5!important">
    @Override
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> operation(String state) {
        </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important"> TODO Auto-generated method stub</span>
        System.out.println("Intrinsic State = " + <span style="color:rgb(0,0,255); line-height:1.5!important">this</span><span style="line-height:1.5!important">.intrinsicState);
        System.out.println(</span>"Extrinsic State = " +<span style="line-height:1.5!important"> state);
    }

}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　享元工厂角色类，必须指出的是，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span><span style="line-height:1.5!important"> FlyweightFactory {
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">private</span> Map&lt;Character,Flyweight&gt; files = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span> HashMap&lt;Character,Flyweight&gt;<span style="line-height:1.5!important">();
    
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span><span style="line-height:1.5!important"> Flyweight factory(Character state){
        </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">先从缓存中查找对象</span>
        Flyweight fly =<span style="line-height:1.5!important"> files.get(state);
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">if</span>(fly == <span style="color:rgb(0,0,255); line-height:1.5!important">null</span><span style="line-height:1.5!important">){
            </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">如果对象不存在则创建一个新的Flyweight对象</span>
            fly = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span><span style="line-height:1.5!important"> ConcreteFlyweight(state);
            </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">把这个新的Flyweight对象添加到缓存中</span>
<span style="line-height:1.5!important">            files.put(state, fly);
        }
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">return</span><span style="line-height:1.5!important"> fly;
    }
}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　客户端类</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span><span style="line-height:1.5!important"> Client {

    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">static</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> main(String[] args) {
        </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important"> TODO Auto-generated method stub</span>
        FlyweightFactory factory = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span><span style="line-height:1.5!important"> FlyweightFactory();
        Flyweight fly </span>= factory.factory(<span style="color:rgb(0,0,255); line-height:1.5!important">new</span> Character('a'<span style="line-height:1.5!important">));
        fly.operation(</span>"First Call"<span style="line-height:1.5!important">);
        
        fly </span>= factory.factory(<span style="color:rgb(0,0,255); line-height:1.5!important">new</span> Character('b'<span style="line-height:1.5!important">));
        fly.operation(</span>"Second Call"<span style="line-height:1.5!important">);
        
        fly </span>= factory.factory(<span style="color:rgb(0,0,255); line-height:1.5!important">new</span> Character('a'<span style="line-height:1.5!important">));
        fly.operation(</span>"Third Call"<span style="line-height:1.5!important">);
    }

}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　虽然客户端申请了三个享元对象，但是实际创建的享元对象只有两个，这就是共享的含义。运行结果如下：</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<img src="http://blog.csdn.net/singit/article/details/54693184" alt="" style="border:0px; max-width:900px" /></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
 </p>&#13;
<h1 style="margin:0px; height:auto; padding-right:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:16px; border-bottom-style:none; line-height:1.5">&#13;
复合享元模式</h1>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　<img src="http://blog.csdn.net/singit/article/details/54693184" alt="" style="border:0px; max-width:900px; display:block; margin-left:auto; margin-right:auto" /></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　复合享元角色所涉及到的角色如下：</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　<strong>抽象享元(Flyweight)角色 ：</strong>给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　<strong>具体享元(Concrete<strong>Flyweight</strong>)角色：</strong>实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<strong><strong>　　●　  复合<strong>享元(<strong>ConcreteCompositeFlyweight</strong>)角色</strong></strong></strong> ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　<strong><strong>●　  <strong>享元工厂(FlyweightFactory)角色</strong></strong></strong> ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。</p>&#13;
<h3 style="font-size:16px; border-bottom-width:1px; border-bottom-style:dotted; border-bottom-color:rgb(214,214,214); line-height:1.5; margin:10px 0px; font-family:'ms shell dlg'">&#13;
源代码</h3>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　抽象享元角色类</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">interface</span><span style="line-height:1.5!important"> Flyweight {
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">一个示意性方法，参数state是外蕴状态</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> operation(String state);
}</span></pre>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　具体享元角色类</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span> ConcreteFlyweight <span style="color:rgb(0,0,255); line-height:1.5!important">implements</span><span style="line-height:1.5!important"> Flyweight {
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">private</span> Character intrinsicState = <span style="color:rgb(0,0,255); line-height:1.5!important">null</span><span style="line-height:1.5!important">;
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 构造函数，内蕴状态作为参数传入
     * </span><span style="color:rgb(128,128,128); line-height:1.5!important">@param</span><span style="color:rgb(0,128,0); line-height:1.5!important"> state
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span><span style="line-height:1.5!important"> ConcreteFlyweight(Character state){
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">this</span>.intrinsicState =<span style="line-height:1.5!important"> state;
    }
    
    
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span><span style="line-height:1.5!important">
    @Override
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> operation(String state) {
        </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important"> TODO Auto-generated method stub</span>
        System.out.println("Intrinsic State = " + <span style="color:rgb(0,0,255); line-height:1.5!important">this</span><span style="line-height:1.5!important">.intrinsicState);
        System.out.println(</span>"Extrinsic State = " +<span style="line-height:1.5!important"> state);
    }

}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　复合享元对象是由单纯享元对象通过复合而成的，因此它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span> ConcreteCompositeFlyweight <span style="color:rgb(0,0,255); line-height:1.5!important">implements</span><span style="line-height:1.5!important"> Flyweight {
    
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">private</span> Map&lt;Character,Flyweight&gt; files = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span> HashMap&lt;Character,Flyweight&gt;<span style="line-height:1.5!important">();
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 增加一个新的单纯享元对象到聚集中
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> add(Character key , Flyweight fly){
        files.put(key,fly);
    }
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 外蕴状态作为参数传入到方法中
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span><span style="line-height:1.5!important">
    @Override
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> operation(String state) {
        Flyweight fly </span>= <span style="color:rgb(0,0,255); line-height:1.5!important">null</span><span style="line-height:1.5!important">;
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">for</span><span style="line-height:1.5!important">(Object o : files.keySet()){
            fly </span>=<span style="line-height:1.5!important"> files.get(o);
            fly.operation(state);
        }
        
    }

}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　享元工厂角色提供两种不同的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span><span style="line-height:1.5!important"> FlyweightFactory {
    </span><span style="color:rgb(0,0,255); line-height:1.5!important">private</span> Map&lt;Character,Flyweight&gt; files = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span> HashMap&lt;Character,Flyweight&gt;<span style="line-height:1.5!important">();
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 复合享元工厂方法
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span> Flyweight factory(List&lt;Character&gt;<span style="line-height:1.5!important"> compositeState){
        ConcreteCompositeFlyweight compositeFly </span>= <span style="color:rgb(0,0,255); line-height:1.5!important">new</span><span style="line-height:1.5!important"> ConcreteCompositeFlyweight();
        
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">for</span><span style="line-height:1.5!important">(Character state : compositeState){
            compositeFly.add(state,</span><span style="color:rgb(0,0,255); line-height:1.5!important">this</span><span style="line-height:1.5!important">.factory(state));
        }
        
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">return</span><span style="line-height:1.5!important"> compositeFly;
    }
    </span><span style="color:rgb(0,128,0); line-height:1.5!important">/**</span><span style="color:rgb(0,128,0); line-height:1.5!important">
     * 单纯享元工厂方法
     </span><span style="color:rgb(0,128,0); line-height:1.5!important">*/</span>
    <span style="color:rgb(0,0,255); line-height:1.5!important">public</span><span style="line-height:1.5!important"> Flyweight factory(Character state){
        </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">先从缓存中查找对象</span>
        Flyweight fly =<span style="line-height:1.5!important"> files.get(state);
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">if</span>(fly == <span style="color:rgb(0,0,255); line-height:1.5!important">null</span><span style="line-height:1.5!important">){
            </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">如果对象不存在则创建一个新的Flyweight对象</span>
            fly = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span><span style="line-height:1.5!important"> ConcreteFlyweight(state);
            </span><span style="color:rgb(0,128,0); line-height:1.5!important">//</span><span style="color:rgb(0,128,0); line-height:1.5!important">把这个新的Flyweight对象添加到缓存中</span>
<span style="line-height:1.5!important">            files.put(state, fly);
        }
        </span><span style="color:rgb(0,0,255); line-height:1.5!important">return</span><span style="line-height:1.5!important"> fly;
    }
}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　客户端角色</p>&#13;
<div class="cnblogs_code" style="word-wrap:break-word; border:1px solid rgb(204,204,204); padding:5px; overflow:auto; margin:5px 0px; line-height:28px; font-family:'Courier New'!important; background-color:rgb(245,245,245)">&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
<pre style="margin-top:0px; margin-bottom:0px; white-space:pre-wrap; word-wrap:break-word; font-family:'Courier New'!important"><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">class</span><span style="line-height:1.5!important"> Client {

    </span><span style="color:rgb(0,0,255); line-height:1.5!important">public</span> <span style="color:rgb(0,0,255); line-height:1.5!important">static</span> <span style="color:rgb(0,0,255); line-height:1.5!important">void</span><span style="line-height:1.5!important"> main(String[] args) {
        List</span>&lt;Character&gt; compositeState = <span style="color:rgb(0,0,255); line-height:1.5!important">new</span> ArrayList&lt;Character&gt;<span style="line-height:1.5!important">();
        compositeState.add(</span>'a'<span style="line-height:1.5!important">);
        compositeState.add(</span>'b'<span style="line-height:1.5!important">);
        compositeState.add(</span>'c'<span style="line-height:1.5!important">);
        compositeState.add(</span>'a'<span style="line-height:1.5!important">);
        compositeState.add(</span>'b'<span style="line-height:1.5!important">);
        
        FlyweightFactory flyFactory </span>= <span style="color:rgb(0,0,255); line-height:1.5!important">new</span><span style="line-height:1.5!important"> FlyweightFactory();
        Flyweight compositeFly1 </span>=<span style="line-height:1.5!important"> flyFactory.factory(compositeState);
        Flyweight compositeFly2 </span>=<span style="line-height:1.5!important"> flyFactory.factory(compositeState);
        compositeFly1.operation(</span>"Composite Call"<span style="line-height:1.5!important">);
        
        System.out.println(</span>"---------------------------------"<span style="line-height:1.5!important">);        
        System.out.println(</span>"复合享元模式是否可以共享对象：" + (compositeFly1 ==<span style="line-height:1.5!important"> compositeFly2));
        
        Character state </span>= 'a'<span style="line-height:1.5!important">;
        Flyweight fly1 </span>=<span style="line-height:1.5!important"> flyFactory.factory(state);
        Flyweight fly2 </span>=<span style="line-height:1.5!important"> flyFactory.factory(state);
        System.out.println(</span>"单纯享元模式是否可以共享对象：" + (fly1 ==<span style="line-height:1.5!important"> fly2));
    }
}</span></pre>&#13;
<div class="cnblogs_code_toolbar" style="word-wrap:break-word; margin-top:5px"><span class="cnblogs_code_copy" style="padding-right:5px; line-height:1.5!important"><a target="_blank" title="复制代码" style="color:rgb(46,156,233); border:none!important"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px; border:none!important" /></a></span></div>&#13;
</div>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
 </p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
运行结果如下：</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
<img src="http://blog.csdn.net/singit/article/details/54693184" alt="" style="border:0px; max-width:900px" /></p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　从运行结果可以看出，一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的。即外运状态都等于Composite Call。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　从运行结果可以看出，一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的。即内蕴状态分别为b、c、a。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　从运行结果可以看出，复合享元对象是不能共享的。即使用相同的对象compositeState通过工厂分别两次创建出的对象不是同一个对象。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　从运行结果可以看出，单纯享元对象是可以共享的。即使用相同的对象state通过工厂分别两次创建出的对象是同一个对象。</p>&#13;
<h1 style="margin:0px; height:auto; padding-right:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:16px; border-bottom-style:none; line-height:1.5">&#13;
享元模式的优缺点</h1>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; font-size:14px; line-height:28px">&#13;
　　●　　享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; line-height:28px">&#13;
<span style="color:rgb(54,46,43); font-family:Arial; line-height:26px"><strong><span style="font-size:14px">总结：</span></strong></span><br style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px" />&#13;
<span style="font-size:14px; color:rgb(54,46,43); font-family:Arial; line-height:26px">　　<strong>1.</strong>Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在</span><a target="_blank" href="http://lib.csdn.net/base/javase" class="replace_word" title="Java SE知识库" style="font-size:14px; color:rgb(223,52,52); text-decoration:none; font-family:Arial; line-height:26px; font-weight:bold">Java</a><span style="font-size:14px; color:rgb(54,46,43); font-family:Arial; line-height:26px">语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。String&#13;
 a="abc"，其中"abc"就是一个字符串常量。</span><br />&#13;
</p>&#13;
<p style="word-wrap:break-word; margin:10px auto; font-family:'ms shell dlg'; line-height:28px">&#13;
<span style="font-size:14px; color:rgb(54,46,43); font-family:Arial; line-height:26px"><span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px"><span style="white-space:pre"></span><strong>2.</strong>可以共享的对象，也就是说返回的同一类型的对象其实是同一实例，当客户端要求生成一个对象时，工厂会检测是否存在此对象的实例，如果存在那么直接返回此对象实例，如果不存在就创建一个并保存起来，这点有些单例模式的意思。通常工厂类会有一个集合类型的成员变量来用以保存对象，如hashtable,vector等。在java中，</span><a target="_blank" href="http://lib.csdn.net/base/mysql" class="replace_word" title="MySQL知识库" style="color:rgb(223,52,52); text-decoration:none; font-family:Arial; font-size:14px; line-height:26px; font-weight:bold">数据库</a><span style="color:rgb(54,46,43); font-family:Arial; font-size:14px; line-height:26px">连接池，线程池等即是用享元模式的应用。</span><br />&#13;
</span></p>&#13;
   &#13;
