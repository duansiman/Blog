

<h3>TCP/IP网络</h3>&#13;
<h4>IP</h4>&#13;
<p>         TCP/IP是目前通用性最高的网络系统，本来各个硬件体系大都会定义自己的通信协议，并且以太网上也是曾经存在很多通信协议（例如IPX），但是随着产业的发展，所有的网络系统都在逐渐接收TCP/IP协议族。Linux内核对这部分的支持也已经很完整了。</p>&#13;
<h5>多播</h5>&#13;
<h5>路由</h5>&#13;
<h6>多播路由</h6>&#13;
<h6>策略路由</h6>&#13;
<p>         不但考虑目的地址，还考虑源地址和TOS。</p>&#13;
<h6>路径选择</h6>&#13;
<p>         一般一个数据包对应一个路径，但可以指定满足特定格式的数据包有多个代价相同的路径。</p>&#13;
<h5>IP地址获得</h5>&#13;
<h6>内核启动自动配置</h6>&#13;
<p>         内核启动的时候可以提供参数指定IP地址，也可以在启动时通过bootp或dhcp动态获得IP地址信息。这对于无盘操作系统是十分重要的。</p>&#13;
<h6>bootp</h6>&#13;
<h6>DHCP</h6>&#13;
<p>流程图</p>&#13;
<p><img src="http://img.blog.csdn.net/20151008202636488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;
</p>&#13;
<p align="center"></p>&#13;
<p align="left">其中，DHCP服务器为客户端分配IP精辟（客户端收到DHCPACK），需要确定地址可用，方法为使用ARP协议。</p>&#13;
<p>DHCP消息</p>&#13;
<p>DHCPDISCOVER：当主机希望被分配IP地址时，向局域网广播此消息，并希望得到回应。</p>&#13;
<p>DHCPOFFER：当DHCP服务器收到DHCPDISCOVER消息时，为该申请者分配一个IP，并用此消息返回给申请者。</p>&#13;
<p>DHCPREQUEST：如果有多个DHCP服务器，主机会收到多个DHCPOFFER，这时主机就需要广播此消息，携带其采用哪个DHCP的分配，同时拒绝其他服务器的分配。还有功能是用来续租（单播）。</p>&#13;
<p>DHCPACK：当DHCP服务器收到DHCPREQUEST消息时，表明主机接受了本服务器为其分配的IP地址，返回本消息以回应并做具体配置。</p>&#13;
<p>DHCPNCK：如果DHCP服务器发现收到的DHCPREQUEST消息中的要求其无法达到（例如，某主机想要使用本服务器已经分配出去的IP），返回本消息告知其要求无法满足。</p>&#13;
<p>DHCPDECLINE：当主机接收到DHCPACK后，已经与DHCP服务器完成了地址分配，但是并没有实际在网络中检查分配的IP有没有被使用（例如多台DHCP服务器同时分配IP可能造成分配冲突），这时主机需要做最后的检查：通过ARP协议询问网络被分配的IP是否已经被使用，如果得到肯定的回复，则返回本消息给DHCP服务器。</p>&#13;
<p>DHCPRELEASE：在DHCP分配IP时有个IP租用期限，到期DHCP会收回该IP，如果客户想要继续使用，需要续租（一般为自动），如果需要手动放弃续租，发送此消息。</p>&#13;
<p>DHCPINFORM：在已经分配了IP地址的情况下（例如手动分配），主机通过发送此消息让服务器返回其他参数的配置。服务器收到此消息后返回DHCPACK通知其有关参数的配置。</p>&#13;
<p>DHCP在如下情况下会使用广播包：</p>&#13;
<p>l  在网络发现时由客户端发送的DHCPDISCOVER时和服务端回复的DHCPREQUEST时用广播</p>&#13;
<p>l  另外，在服务端收到DHCPREQUEST是客户端重启发来的，并且和服务器是一个子网，服务器应该广播回复DHCPNAK。</p>&#13;
<p>l  在DHCPINFORM时，不知道DHCP服务器的地址时用广播</p>&#13;
<p>客户机在如下情况下会发送request报文：</p>&#13;
<p>l  在选择阶段。此时根据服务器发来的DHCPOFFER选择自己所要接受的IP分配，并用DHCPREQUEST通知准备接受的哪个DHCP服务器所分配的IP地址。此时，必须要用选择的服务器IP地址填充'server identifier', 'ciaddr' 必须是0, 'requested IPaddress'  必须要填通过DHCPOFFER收到的yiaddr的值</p>&#13;
<p>l  INIT-REBOOT阶段。'server identifier' 不能填, 'requested IP address' 填该客户机之前被分配的IP地址， 'ciaddr' 必须是0。这条消息的目的是客户端在重启后确定其之前分配的IP地址是否有效，无效的话服务端会恢复DHCPNAK</p>&#13;
<p>l  RENEWING状态：'server identifier' 不能填， 'requested IP address'不能填，,'ciaddr' 填充客户端的IP。此时，网络已经配置好，单播此消息为了续租</p>&#13;
<p>l  REBINDING状态：'server identifier', 'requested IP address'不能填，,'ciaddr' 要填充客户机的IP地址。客户机广播此消息以续租。此时用在有多个DHCP服务器的环境下，单个DHCP只对他分配的IP地址具有管理权限</p>&#13;
<p> </p>&#13;
<p> </p>&#13;
<p>静态地址</p>&#13;
<p>静态地址在RFC中被称为外部配置。其没有经过网络发现步骤，直接配置了IP地址。客户端使用DHCPINFORM来完成静态地址条目的配置。服务器恢复DHCPACK完成其他参数的配置。静态条目使得DHCP过程与通常不一样。</p>&#13;
<p> </p>&#13;
<h6>zeroconf</h6>&#13;
<p> </p>&#13;
<h5>IP管道tunneling与GRE</h5>&#13;
<p>         管道是指自己的数据包完全架构在另一个协议的头部之上。IP管道利用IP协议的路由和寻址能力，在IP层以上封装自己的完整协议包。例如IP层之上可能是MAC层，然后再是IP层，也有可能是为了加密将上层的数据协议加密的密文，也可以是ATM层。</p>&#13;
<p>         还有一种管道是在UDP基础之上的，例如IPIP,GRE, SIT。GRE（generic routing encapsulation）是通用路由封装协议，可以在网络层（IP或IPX）之上封装数据包，是VPN的第三层隧道协议。GRE利用管道，是管道之上的一种通信协议。使用GRE进行通信的双方必须按照GRE协议的要求封装包和解封装包。确切的说，GRE是IP管道之上的一种应用，但不限于IP管道。</p>&#13;
<p>         在使用GRE通信的时候，通信的两端必须首先建立tunnel，然后设置一样的关键字（可以不设，RFC1701中规定，若GRE报文头中的KEY字段置位，则收发双方将进行通道识别的关键字的验证，只有tunnel两端设置的关键字一致时才能通过验证）。配置好路由后就可以通信。</p>&#13;
<p>         </p>&#13;
<h5>攻击防止</h5>&#13;
<p>         syncflood</p>&#13;
<h5>LRO</h5>&#13;
<h5>安全标志（security marking）</h5>&#13;
<h5>硬件时间戳</h5>&#13;
<h5>IPv6</h5>&#13;
<h4>XFRM和IPSec</h4>&#13;
<p>         在网络通信中，通信双方的认证和通信内容的加密是很重要的需求。这个可以在上层解决，也可以在相对较下的网络层次解决。IPSec就是在IP层之上，传输层之下的解决方案。</p>&#13;
<p>         其主要解决解决的内容是通信双方的认证、通信内容的加密、加密秘钥的交换、通信数据的压缩这4个问题。</p>&#13;
<p>         压缩上，其采用的协议名是payloadCompression Protocol (IPComp)。其本质上就是通信的双方将IP层以上的数据进行压缩和解压缩。认证和加密都是通过压缩算法的应用实现的（密码学基础），关键是秘钥的交换。这部分是IPSec协议中唯一不在内核中实现的部分，叫IKE（Internet Key Exchange）。</p>&#13;
<p>         IPSec由于要加密通信，其实就相当于在IP层维护链接的概念，相当于IP层之上的数据链路层。链接需要针对每条链接进行记录，以便后续的数据包经过合适的处理。内核中存储这些与链接相关的信息靠两个表：Security Policy Database (SPD)和Security AssociationDatabase (SAD)。如果你使用命令行在用户端使用IPSec，那么操作的主要对象就是这两个表。如果你使用XFRM编程接口，操作的也是这两个表。这两个表是用户影响IPSec发挥作用的几乎唯一机制。</p>&#13;
<h5>使用XFRM操作IPSec</h5>&#13;
<p>         XFRM是内核中管理SPD、SAD两个表的模块。他们会接收和发送netlink（NETLINK_XFRM消息，并且按照要求更新两个表。用户端可以使用netlink接口给XFRM模块发送信息。已经写好的比较通用的用户端进程可以操作XFRM的是ip xfrm命令。</p>&#13;
<h5>IPSec</h5>&#13;
<h6>AH</h6>&#13;
<h6>ESP</h6>&#13;
<h6>IP负载压缩（RFC3173）</h6>&#13;
<h6>模式</h6>&#13;
<p>         transportmode、tunnel mode、beet mode</p>&#13;
<p><br />&#13;
</p>&#13;
<p> </p>&#13;
<h4>Netlabel</h4>&#13;
<p>CIPSO and RIPSO</p>&#13;
<p> </p>&#13;
<h4>Netfilter</h4>&#13;
   &#13;
