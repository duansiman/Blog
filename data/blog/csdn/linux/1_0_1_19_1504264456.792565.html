

<p>        在保护模式下有很多界限问题，下面集中来看下：</p>&#13;
<p>        若段界限是0xFFFFF，粒度是4KB，那么实际界限值是多少？若粒度G=0，那么段界限就是实际的界限值；但粒度为4KB，那么界限值就是：（描述符段界限 + 1）× 4KB - 1；为什么会这样？因为段界限是段长度减去1，若粒度G=0，那么段界限就是实际的界限值；若为4KB，则段长度是：（描述符界限 + 1）× 4；然后再减去1；所有：(0xFFFFF + 1) × 0x1000 -1 = 0xFFFFFFFF；</p>&#13;
<p>        “代码段是向上（高地址方向）扩展的，因此，实际使用的段界限就是当前段内最后一个允许访问的偏移地址。当处理器在该段内取指令执行时，偏移地址由 EIP 提供。指令很有可能是跨越边界的，一部分在边界之内，一部分在边界之外，或者一条单字节指令正好位于边界上。因此，要执行的那条指令，其长度减 1 后，与 EIP 寄存器的值相加，结果必须小于等于实际使用的段界限，否则引发处理器异常。即：0≤（EIP＋指令长度－1）≤实际使用的段界限” 这个界限问题关键是为什么要减去1（至少当时我理解不了的就是这个问题，直接EIP+指令长度不就可以了吗），其实是因为EIP指向的是下个将被读取的指令地址（而不是当前执行的指令地址），所以说EIP已经指向了下个指令的首字节位置，考虑界限时当然要减去1了；</p>&#13;
<p>        “堆栈段是向下扩展的，每当往堆栈中压入数据时，ESP 的内容要减去操作数的长度。所以，和向高地址方向扩展的段相比，非常重要的一点就是，实际使用的段界限就是段内不允许访问的最低端偏移地址。至于最高端的地址，则没有限制，最大可以是 0xFFFFFFFF。也就是说，在进行堆栈操作时，必须符合以下规则：实际使用的段界限＋1≤（ESP 的内容－操作数的长度）≤0xFFFFFFFF”这个界限问题是为什么要大于实际使用的段界限+1，其实是因为实际使用的段界限就是段内不允许访问的最低端偏移地址；</p>&#13;
<p>        转载请注明作者和原文出处，原文地址：<a target="_blank" href="http://blog.csdn.net/yuzhihui_no1/article/details/42394763">http://blog.csdn.net/yuzhihui_no1/article/details/42394763</a></p>&#13;
   &#13;
