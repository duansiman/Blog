
        <div class="markdown_views"><h1 id="信号量">信号量</h1>

<hr />



<h2 id="什么是信号量">什么是信号量</h2>

<hr />

<p class="cye-lm-tag">信号量的使用主要是用来保护共享资源，使得资源在一个时刻只有一个进程（线程）所拥有。</p>

<blockquote>
  <p class="cye-lm-tag">信号量的值为正的时候，说明它空闲。所测试的线程可以锁定而使用它。若为0，说明它被占用，测试的线程要进入睡眠队列中，等待被唤醒。</p>
</blockquote>

<p class="cye-lm-tag">为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的<strong>临界区域</strong>。</p>

<p class="cye-lm-tag">临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p>

<p class="cye-lm-tag">信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。</p>

<p class="cye-lm-tag">最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p>



<h2 id="信号量的工作原理">信号量的工作原理</h2>

<hr />

<p class="cye-lm-tag">由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p>

<ul>
<li><p class="cye-lm-tag">P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p></li>
<li><p class="cye-lm-tag">V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p></li>
</ul>

<blockquote>
  <p class="cye-lm-tag">举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p>
</blockquote>



<h2 id="信号量的分类">信号量的分类</h2>

<hr />

<p class="cye-lm-tag">在学习信号量之前，我们必须先知道——Linux提供两种信号量：</p>

<ul>
<li><p class="cye-lm-tag"><strong>内核信号量</strong>，由内核控制路径使用</p></li>
<li><p class="cye-lm-tag"><strong>用户态进程使用的信号量</strong>，这种信号量又分为POSIX信号量和SYSTEM V信号量。</p></li>
</ul>

<p class="cye-lm-tag">POSIX信号量又分为<strong>有名信号量</strong>和<strong>无名信号量</strong> <br />
<strong>有名信号量</strong>，其值保存在文件中, 所以它可以用于线程也可以用于进程间的同步。<strong>无名信号量</strong>，其值保存在内存中。</p>



<h2 id="posix-信号量与system-v信号量的比较">POSIX 信号量与SYSTEM V信号量的比较</h2>

<hr />

<ol>
<li><p class="cye-lm-tag">对POSIX来说，信号量是个非负整数。常用于线程间同步。 <br />
而SYSTEM V信号量则是一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为SYSTEM V IPC服务的，信号量只不过是它的一部分。常用于进程间同步。</p></li>
<li><p class="cye-lm-tag">POSIX信号量的引用头文件是<code>&lt;semaphore.h&gt;</code>，而SYSTEM V信号量的引用头文件是<code>&lt;sys/sem.h&gt;</code></p></li>
<li><p class="cye-lm-tag">从使用的角度，System V信号量是复杂的，而Posix信号量是简单。比如，POSIX信号量的创建和初始化或PV操作就很非常方便。</p></li>
</ol>



<h1 id="内核信号量">内核信号量</h1>

<hr />

<p class="cye-lm-tag">Linux内核的信号量在概念和原理上与用户态的System V的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，它是一种睡眠锁。</p>

<p class="cye-lm-tag">如果有一个任务想要获得已经被占用的信号量时，信号量会将其放入一个等待队列（它不是站在外面痴痴地等待而是将自己的名字写在任务队列中）然后让其睡眠。</p>

<p class="cye-lm-tag">当持有信号量的进程将信号释放后，处于等待队列中的一个任务将被唤醒（因为队列中可能不止一个任务），并让其获得信号量。</p>

<p class="cye-lm-tag">这一点与自旋锁不同，处理器可以去执行其它代码。</p>

<blockquote>
  <p class="cye-lm-tag">关于 他们的不同之处，请参见 </p>
  
  <p class="cye-lm-tag"><a href="http://blog.csdn.net/whycold/article/details/7554309">自旋锁，Mutex和信号量的使用</a></p>
  
  <p class="cye-lm-tag"><a href="http://blog.csdn.net/xu_guo/article/details/6072823">linux 自旋锁和信号量</a></p>
</blockquote>

<p class="cye-lm-tag">它与自旋锁的差异：由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以<strong>信号量适用于锁会被长时间持有的情况</strong>；</p>

<p class="cye-lm-tag">相反，锁被短时间持有时，使用信号量就不太适宜了，因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁占用的全部时间表还要长；</p>

<p class="cye-lm-tag">由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获得信号量锁，因为在中断上下文中是不能进行调试的；持有信号量的进行也可以去睡眠，当然也可以不睡眠，因为当其他进程争用信号量时不会因此而死锁；不能同时占用信号量和自旋锁，因为自旋锁不可以睡眠而信号量锁可以睡眠。相对而来说信号量比较简单，它不会禁止内核抢占，持有信号量的代码可以被抢占。</p>

<p class="cye-lm-tag">信号量还有一个特征，就是它允许多个持有者，而自旋锁在任何时候只能允许一个持有者。</p>

<p class="cye-lm-tag">当然我们经常遇到也是只有一个持有者，这种信号量叫二值信号量或者叫互斥信号量。允许有多个持有者的信号量叫计数信号量，在初始化时要说明最多允许有多少个持有者（Count值） <br />
信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源。 <br />
当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。</p>

<blockquote>
  <p class="cye-lm-tag">关于内核信号量的其他信息</p>
  
  <p class="cye-lm-tag">请参见 </p>
  
  <p class="cye-lm-tag"><a href="http://blog.sina.com.cn/s/blog_6d7fa49b01014q8y.html">大话Linux内核中锁机制之信号量、读写信号量</a></p>
</blockquote>



<h2 id="内核信号量的构成">内核信号量的构成</h2>

<hr />

<p class="cye-lm-tag">内核信号量类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号量锁保护的忙资源时，相应的进程就被挂起。只有在资源被释放时，进程才再次变为可运行。 <br />
只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核信号量。 <br />
内核信号量是<code>struct semaphore</code>类型的对象，在内核源码中位于include\linux\semaphore.h文件</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">struct</span> semaphore
{
　　 atomic_t count;
　　 <span class="hljs-keyword cye-lm-tag">int</span> sleepers;
　　 wait_queue_head_t wait;
}</code></pre>

<table>
<thead>
<tr>
  <th>成员</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>count</td>
  <td align="center">相当于信号量的值，大于0，资源空闲；等于0，资源忙，但没有进程等待这个保护的资源；小于0，资源不可用，并至少有一个进程等待资源</td>
</tr>
<tr>
  <td>wait</td>
  <td align="center">存放等待队列链表的地址，当前等待资源的所有睡眠进程都会放在这个链表中</td>
</tr>
<tr>
  <td>sleepers</td>
  <td align="center">存放一个标志，表示是否有一些进程在信号量上睡眠</td>
</tr>
</tbody></table>




<h2 id="内核信号量中的等待队列">内核信号量中的等待队列</h2>

<hr />

<p class="cye-lm-tag">上面已经提到了内核信号量使用了等待队列wait_queue来实现阻塞操作。</p>

<p class="cye-lm-tag">当某任务由于没有某种条件没有得到满足时，它就被挂到等待队列中睡眠。当条件得到满足时，该任务就被移出等待队列，此时并不意味着该任务就被马上执行，因为它又被移进工作队列中等待CPU资源，在适当的时机被调度。</p>

<p class="cye-lm-tag">内核信号量是在内部使用等待队列的，也就是说该等待队列对用户是隐藏的，无须用户干涉。由用户真正使用的等待队列我们将在另外的篇章进行详解。</p>



<h2 id="内核信号量的相关函数">内核信号量的相关函数</h2>

<hr />

<p class="cye-lm-tag"><img src="http://img.blog.csdn.net/20160328204754138" alt="这里写图片描述" title="" /></p>



<h3 id="初始化">初始化</h3>

<hr />



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#define __SEMAPHORE_INITIALIZER(name, n)                                \</span>
{                                                                       \
        .lock           = __SPIN_LOCK_UNLOCKED((name).lock),            \
        .count          = n,                                            \
        .wait_list      = LIST_HEAD_INIT((name).wait_list),             \
}
</code></pre>

<p class="cye-lm-tag">该宏声明一个信号量name是直接将结构体中count值设置成n，此时信号量可用于实现进程间的互斥量。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#define DECLARE_MUTEX(name)     \</span>
        <span class="hljs-keyword cye-lm-tag">struct</span> semaphore name = __SEMAPHORE_INITIALIZER(name, <span class="hljs-number cye-lm-tag">1</span>)</code></pre>

<p class="cye-lm-tag">该宏声明一个互斥锁name，但把它的初始值设置为1</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">void</span> sema_init (<span class="hljs-keyword cye-lm-tag">struct</span> semaphore *sem, <span class="hljs-keyword cye-lm-tag">int</span> val);</code></pre>

<p class="cye-lm-tag">该函用于数初始化设置信号量的初值，它设置信号量sem的值为val。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#define init_MUTEX(sem)         sema_init(sem, 1)</span></code></pre>

<p class="cye-lm-tag">该函数用于初始化一个互斥锁，即它把信号量sem的值设置为1。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#define init_MUTEX_LOCKED(sem)  sema_init(sem, 0)</span>
</code></pre>

<p class="cye-lm-tag">该函数也用于初始化一个互斥锁，但它把信号量sem的值设置为0，即一开始就处在已锁状态。</p>

<blockquote>
  <p class="cye-lm-tag">注意：对于信号量的初始化函数Linux最新版本存在变化，如init_MUTEX和init_MUTEX_LOCKED等初始化函数目前新的内核中已经没有或者更换了了名字等</p>
  
  <p class="cye-lm-tag">因此建议以后在编程中遇到需要使用信号量的时候尽量采用sema_init(struct semaphore *sem, int val)函数，因为这个函数就目前为止从未发生变化。</p>
</blockquote>

<h3 id="获取信号量申请内核信号量所保护的资源">获取信号量–申请内核信号量所保护的资源</h3>

<hr />



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">void</span> down(<span class="hljs-keyword cye-lm-tag">struct</span> semaphore * sem);</code></pre>

<p class="cye-lm-tag">该函数用于获得信号量sem，它<strong>会导致睡眠，因此不能在中断上下文（包括IRQ上下文和softirq上下文）使用该函数</strong>。该函数将把sem的值减1，如果信号量sem的值非负，就直接返回，否则调用者将被挂起，直到别的任务释放该信号量才能继续运行。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">int</span> down_interruptible(<span class="hljs-keyword cye-lm-tag">struct</span> semaphore * sem);</code></pre>

<p class="cye-lm-tag">该函数功能与down类似，不同之处为，<strong>down不会被信号（signal）打断，但down_interruptible能被信号（比如Ctrl+C）打断，因此该函数有返回值来区分是正常返回还是被信号中断，如果返回0，表示获得信号量正常返回，如果被信号打断，返回-EINTR</strong></p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">int</span> down_trylock(<span class="hljs-keyword cye-lm-tag">struct</span> semaphore * sem);</code></pre>

<p class="cye-lm-tag">该函数试着获得信号量sem，如果能够立刻获得，它就获得该信号量并返回0，否则，表示不能获得信号量sem，返回值为非0值。因此，它<strong>不会导致调用者睡眠，可以在中断上下文使用</strong>。</p>



<h3 id="释放内核信号量所保护的资源">释放内核信号量所保护的资源</h3>

<hr />



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">void</span> up(<span class="hljs-keyword cye-lm-tag">struct</span> semaphore * sem);</code></pre>

<p class="cye-lm-tag">该函数释放信号量sem，即把sem的值加1，如果sem的值为非正数，表明有任务等待该信号量，因此唤醒这些等待者。</p>



<h2 id="内核信号量的使用例程">内核信号量的使用例程</h2>

<hr />

<p class="cye-lm-tag">在驱动程序中，当多个线程同时访问相同的资源时（驱动中的全局变量时一种典型的 <br />
共享资源），可能会引发“竞态“，因此我们必须对共享资源进行并发控制。Linux内核中 <br />
解决并发控制的最常用方法是自旋锁与信号量（绝大多数时候作为互斥锁使用）。</p>



<pre class="prettyprint"><code class=" hljs cs">ssize_t globalvar_write(<span class="hljs-keyword cye-lm-tag">struct</span> file *filp, <span class="hljs-keyword cye-lm-tag">const</span> <span class="hljs-keyword cye-lm-tag">char</span> *buf, size_t len, loff_t *off)
{
　<span class="hljs-comment cye-lm-tag">//获得信号量</span>
　<span class="hljs-keyword cye-lm-tag">if</span> (down_interruptible(&amp;sem))
　{
　　<span class="hljs-keyword cye-lm-tag">return</span> - ERESTARTSYS;
　}
　<span class="hljs-comment cye-lm-tag">//将用户空间的数据复制到内核空间的global_var</span>
　<span class="hljs-keyword cye-lm-tag">if</span> (copy_from_user(&amp;global_var, buf, <span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">int</span>)))
　{
　　up(&amp;sem);
　　<span class="hljs-keyword cye-lm-tag">return</span> - EFAULT;
　}
　<span class="hljs-comment cye-lm-tag">//释放信号量</span>
　up(&amp;sem);
　<span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">int</span>);
}</code></pre>



<h2 id="读-写信号量">读-写信号量</h2>

<hr />

<p class="cye-lm-tag">跟自旋锁一样，信号量也有区分读-写信号量之分</p>

<p class="cye-lm-tag">如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；</p>

<p class="cye-lm-tag">否则，读者必须被挂起直到写者释放该信号量。如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者将被挂起，直到没有任何访问者。因此，写者是排他性的，独占性的。</p>

<p class="cye-lm-tag">读写信号量有两种实现，一种是通用的，不依赖于硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现。 <br />
读写信号量的相关API有：</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function cye-lm-tag">DECLARE_RWSEM(name)</span></code></pre>

<p class="cye-lm-tag">该宏声明一个读写信号量name并对其进行初始化。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> init_rwsem(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">该函数对读写信号量sem进行初始化。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> down_read(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">读者调用该函数来得到读写信号量sem。该函数会导致调用者睡眠，因此只能在进程上下文使用。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">int</span> down_read_trylock(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">该函数类似于down_read，只是它不会导致调用者睡眠。它尽力得到读写信号量sem，如果能够立即得到，它就得到该读写信号量，并且返回1，否则表示不能立刻得到该信号量，返回0。因此，它也可以在中断上下文使用。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> down_write(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">写者使用该函数来得到读写信号量sem，它也会导致调用者睡眠，因此只能在进程上下文使用。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">int</span> down_write_trylock(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">该函数类似于down_write，只是它不会导致调用者睡眠。该函数尽力得到读写信号量，如果能够立刻获得，就获得该读写信号量并且返回1，否则表示无法立刻获得，返回0。它可以在中断上下文使用。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> up_read(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">读者使用该函数释放读写信号量sem。它与down_read或down_read_trylock配对使用。如果down_read_trylock返回0，不需要调用up_read来释放读写信号量，因为根本就没有获得信号量。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> up_write(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">写者调用该函数释放信号量sem。它与down_write或down_write_trylock配对使用。如果down_write_trylock返回0，不需要调用up_write，因为返回0表示没有获得该读写信号量。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">void</span> downgrade_write(<span class="hljs-keyword cye-lm-tag">struct</span> rw_semaphore *sem);</code></pre>

<p class="cye-lm-tag">该函数用于把写者降级为读者，这有时是必要的。因为写者是排他性的，因此在写者保持读写信号量期间，任何读者或写者都将无法访问该读写信号量保护的共享资源，对于那些当前条件下不需要写访问的写者，降级为读者将，使得等待访问的读者能够立刻访问，从而增加了并发性，提高了效率。 <br />
读写信号量适于在读多写少的情况下使用，在linux内核中对进程的内存映像描述结构的访问就使用了读写信号量进行保护。 <br />
究竟什么时候使用自旋锁什么时候使用信号量，下面给出建议的方案 <br />
当对低开销、短期、中断上下文加锁，优先考虑自旋锁；当对长期、持有锁需要休眠的任务，优先考虑信号量。</p>



<h1 id="posix信号量详解">POSIX信号量详解</h1>

<hr />



<h2 id="无名信号量">无名信号量</h2>

<hr />

<p class="cye-lm-tag"><strong>无名信号量</strong>的创建就像声明一般的变量一样简单，例如：sem_t sem_id。然后再初始化该无名信号量，之后就可以放心使用了。</p>

<p class="cye-lm-tag">无名信号量常用于多线程间的同步，同时也用于相关进程间的同步。也就是说，无名信号量必须是多个进程（线程）的共享变量，无名信号量要保护的变量也必须是多个进程（线程）的共享变量，这两个条件是缺一不可的。</p>



<h3 id="常见的无名信号量相关函数">常见的无名信号量相关函数</h3>

<hr />



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">int</span> sem_init(sem_t *sem, <span class="hljs-keyword cye-lm-tag">int</span> pshared, <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">int</span> value);</code></pre>

<ul>
<li><p class="cye-lm-tag">pshared==0 用于同一多线程的同步；</p></li>
<li><p class="cye-lm-tag">若pshared&gt;0 用于多个相关进程间的同步（即由fork产生的）</p></li>
</ul>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">int</span> sem_getvalue(sem_t *sem, <span class="hljs-keyword cye-lm-tag">int</span> *sval);</code></pre>

<p class="cye-lm-tag">取回信号量sem的当前值，把该值保存到sval中。 <br />
若有1个或更多的线程或进程调用sem_wait阻塞在该信号量上，该函数返回两种值：</p>

<ul>
<li><p class="cye-lm-tag">返回0</p></li>
<li><p class="cye-lm-tag">返回阻塞在该信号量上的进程或线程数目</p></li>
</ul>

<blockquote>
  <p class="cye-lm-tag">linux采用返回的第一种策略。</p>
</blockquote>

<p class="cye-lm-tag">sem_wait(或sem_trywait)相当于P操作，即申请资源。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">int</span> sem_wait(sem_t *sem); <span class="hljs-comment cye-lm-tag">// 这是一个阻塞的函数</span></code></pre>

<p class="cye-lm-tag">测试所指定信号量的值,它的操作是原子的。</p>

<ul>
<li><p class="cye-lm-tag">若sem&gt;0，那么它减1并立即返回。</p></li>
<li><p class="cye-lm-tag">若sem==0，则睡眠直到sem&gt;0，此时立即减1，然后返回。</p></li>
</ul>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">int</span> sem_trywait(sem_t *sem); <span class="hljs-comment cye-lm-tag">// 非阻塞的函数</span></code></pre>

<p class="cye-lm-tag">其他的行为和sem_wait一样，除了： <br />
若sem==0，不是睡眠，而是返回一个错误EAGAIN。</p>

<p class="cye-lm-tag">sem_post相当于V操作，释放资源。</p>



<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword cye-lm-tag">int</span> sem_post(sem_t <span class="hljs-variable cye-lm-tag">*sem</span>);</code></pre>

<p class="cye-lm-tag">把指定的信号量sem的值加1;</p>

<p class="cye-lm-tag">呼醒正在等待该信号量的任意线程。 <br />
注意：在这些函数中，只有sem_post是信号安全的函数，它是可重入函数</p>



<h3 id="无名信号量在多线程间的同步">无名信号量在多线程间的同步</h3>

<hr />

<p class="cye-lm-tag">无名信号量的常见用法是将要保护的变量放在sem_wait和sem_post中间所形成的 <br />
临界区内，这样该变量就会被保护起来，例如：</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">int</span> number; <span class="hljs-comment cye-lm-tag">// 被保护的全局变量</span>
sem_t sem_id;

<span class="hljs-keyword cye-lm-tag">void</span>* thread_one_fun(<span class="hljs-keyword cye-lm-tag">void</span> *arg)
{
    sem_wait(&amp;sem_id);
    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_one have the semaphore\n"</span>);
    number++;

    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_one : number = %d\n"</span>, number);

    sem_post(&amp;sem_id);

    <span class="hljs-keyword cye-lm-tag">return</span> NULL;
}

<span class="hljs-keyword cye-lm-tag">void</span>* thread_two_fun(<span class="hljs-keyword cye-lm-tag">void</span> *arg)
{
    sem_wait(&amp;sem_id);
    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_two have the semaphore \n"</span>);

    number--;
    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_two : number = %d\n"</span>, number);

    sem_post(&amp;sem_id);

    <span class="hljs-keyword cye-lm-tag">return</span> NULL;
}
<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc, <span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    number = <span class="hljs-number cye-lm-tag">1</span>;
    pthread_t id1, id2;

    sem_init(&amp;sem_id, <span class="hljs-number cye-lm-tag">0</span>, <span class="hljs-number cye-lm-tag">1</span>);

    pthread_create(&amp;id1, NULL, thread_one_fun, NULL);
    pthread_create(&amp;id2, NULL, thread_two_fun, NULL);

    pthread_join(id1, NULL);
    pthread_join(id2, NULL);

    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"main...\n"</span>);

    <span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-number cye-lm-tag">0</span>;
}</code></pre>

<p class="cye-lm-tag">上面的例程，到底哪个线程先申请到信号量资源，这是随机的。</p>

<p class="cye-lm-tag">进程1先执行，进城2后执行 <br />
<img src="http://img.blog.csdn.net/20160328231527226" alt="这里写图片描述" title="" /></p>

<p class="cye-lm-tag">进程2先执行，进城1后执行 <br />
<img src="http://img.blog.csdn.net/20160328231616211" alt="这里写图片描述" title="" /></p>

<p class="cye-lm-tag">如果想要某个特定的顺序的话，可以用2个信号量来实现。例如下面的例程是线程1先执行完，然后线程2才继续执行，直至结束。</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">int</span> number;                 <span class="hljs-comment cye-lm-tag">// 被保护的全局变量</span>
sem_t sem_id1, sem_id2;



<span class="hljs-comment cye-lm-tag">/*
 *  线程1,
 *  对sem_id1加锁(P操作)以后
 *  将number增加1
 *  同时对sem_id2进行释放，V操作
 *
 *  */</span>
<span class="hljs-keyword cye-lm-tag">void</span>* thread_one_fun(<span class="hljs-keyword cye-lm-tag">void</span> *arg)
{
    sem_wait(&amp;sem_id1);
    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_one have the semaphore\n"</span>);

    number++;

    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"number = %d\n"</span>,number);
    sem_post(&amp;sem_id2);

    <span class="hljs-keyword cye-lm-tag">return</span> NULL;
}

<span class="hljs-comment cye-lm-tag">/*
 *  线程2,
 *  对sem_id2加锁(P操作)以后
 *  将number减少1
 *  同时对sem_id1进行释放，V操作
 *
 *  */</span>
<span class="hljs-keyword cye-lm-tag">void</span>* thread_two_fun(<span class="hljs-keyword cye-lm-tag">void</span> *arg)
{
    sem_wait(&amp;sem_id2);
    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"thread_two have the semaphore \n"</span>);

    number--;

    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"number = %d\n"</span>,number);
    sem_post(&amp;sem_id1);

    <span class="hljs-keyword cye-lm-tag">return</span> NULL;
}

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc,<span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    number = <span class="hljs-number cye-lm-tag">1</span>;
    pthread_t id1, id2;

    <span class="hljs-comment cye-lm-tag">/*
     *  由于程序初始时, sem_id1可进入, sem_id2不可进入
     *  两个线程的动作如下:
     *  thread one P(id1)  number++ V(id2)
     *  thread two P(id2)  number-- V(id1)
     *  而id1可进入, id2不可进入
     *  因此thread one先执行
     *  如果将id1与id2的顺序交换, 则执行顺序相反
     * */</span>
    sem_init(&amp;sem_id1, <span class="hljs-number cye-lm-tag">0</span>, <span class="hljs-number cye-lm-tag">1</span>);   <span class="hljs-comment cye-lm-tag">// 空闲的</span>
    sem_init(&amp;sem_id2, <span class="hljs-number cye-lm-tag">0</span>, <span class="hljs-number cye-lm-tag">0</span>);   <span class="hljs-comment cye-lm-tag">// 忙的</span>

    pthread_create(&amp;id1, NULL, thread_one_fun, NULL);
    pthread_create(&amp;id2, NULL, thread_two_fun, NULL);

    pthread_join(id1, NULL);
    pthread_join(id2, NULL);

    <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"main...\n"</span>);


    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>



<h3 id="无名信号量在相关进程间的同步">无名信号量在相关进程间的同步</h3>

<hr />

<p class="cye-lm-tag">说是相关进程，是因为本程序中共有2个进程，其中一个是另外一个的子进程（由fork产生）的。</p>

<p class="cye-lm-tag">本来对于fork来说，子进程只继承了父进程的代码副本，mutex理应在父子进程中是相互独立的两个变量，但由于在初始化mutex的时候，由pshared = 1指定了mutex处于共享内存区域，所以此时mutex变成了父子进程共享的一个变量。此时，mutex就可以用来同步相关进程了。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>


<span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/mman.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc, <span class="hljs-keyword cye-lm-tag">char</span> **argv)
{
    <span class="hljs-keyword cye-lm-tag">int</span>     fd, i;
    <span class="hljs-keyword cye-lm-tag">int</span>     nloop = <span class="hljs-number cye-lm-tag">10</span>, zero = <span class="hljs-number cye-lm-tag">0</span>;
    <span class="hljs-keyword cye-lm-tag">int</span>     *ptr;
    sem_t   mutex;

    <span class="hljs-comment cye-lm-tag">//  open a file and map it into memory</span>
    fd = open(<span class="hljs-string cye-lm-tag">"log.txt"</span>, O_RDWR | O_CREAT, S_IRWXU);

    write(fd,&amp;zero,<span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">int</span>));

    ptr = mmap(NULL, <span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number cye-lm-tag">0</span>);

    close(fd);

    <span class="hljs-comment cye-lm-tag">/* create, initialize semaphore */</span>
    <span class="hljs-keyword cye-lm-tag">if</span>(sem_init(&amp;mutex, <span class="hljs-number cye-lm-tag">1</span>, <span class="hljs-number cye-lm-tag">1</span>) &lt; <span class="hljs-number cye-lm-tag">0</span>) <span class="hljs-comment cye-lm-tag">//</span>
    {
        perror(<span class="hljs-string cye-lm-tag">"semaphore initilization"</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }

    <span class="hljs-keyword cye-lm-tag">if</span> (fork() == <span class="hljs-number cye-lm-tag">0</span>)
    {   <span class="hljs-comment cye-lm-tag">/* child process*/</span>
        <span class="hljs-keyword cye-lm-tag">for</span> (i = <span class="hljs-number cye-lm-tag">0</span>; i &lt; nloop; i++)
        {
            sem_wait(&amp;mutex);

            <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"child: %d\n"</span>, (*ptr)++);
            <span class="hljs-comment cye-lm-tag">//sleep(1);</span>
            sem_post(&amp;mutex);
        }
        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }


    <span class="hljs-comment cye-lm-tag">/* back to parent process */</span>
    <span class="hljs-keyword cye-lm-tag">for</span> (i = <span class="hljs-number cye-lm-tag">0</span>; i &lt; nloop; i++)
    {
        sem_wait(&amp;mutex);

        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"parent: %d\n"</span>, (*ptr)++);
        <span class="hljs-comment cye-lm-tag">//sleep(1);</span>
        sem_post(&amp;mutex);
    }
    <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
}
</code></pre>

<p class="cye-lm-tag"><img src="http://img.blog.csdn.net/20160328232910130" alt="这里写图片描述" title="" /></p>



<h2 id="有名信号量">有名信号量</h2>

<hr />

<p class="cye-lm-tag">有名信号量的特点是把信号量的值保存在文件中。</p>

<p class="cye-lm-tag">这决定了它的用途非常广：既可以用于线程，也可以用于相关进程间，甚至是不相关进程。</p>



<h3 id="有名信号量能在进程间共享的原因">有名信号量能在进程间共享的原因</h3>

<hr />

<p class="cye-lm-tag">由于有名信号量的值是保存在文件中的，所以对于相关进程来说，子进程是继承了父进程的文件描述符，那么子进程所继承的文件描述符所指向的文件是和父进程一样的，当然文件里面保存的有名信号量值就共享了。</p>



<h3 id="有名信号量相关函数说明">有名信号量相关函数说明</h3>

<hr />

<p class="cye-lm-tag">有名信号量在使用的时候，和无名信号量共享sem_wait和sem_post函数。 <br />
区别是有名信号量使用sem_open代替sem_init，另外在结束的时候要像关闭文件一样去关闭这个有名信号量。</p>

<ul>
<li>打开一个已存在的有名信号量，或创建并初始化一个有名信号量。一个单一的调用就完 <br />
成了信号量的创建、初始化和权限的设置。</li>
</ul>



<pre class="prettyprint"><code class=" hljs cs">sem_t *sem_open(<span class="hljs-keyword cye-lm-tag">const</span> <span class="hljs-keyword cye-lm-tag">char</span> *name, <span class="hljs-keyword cye-lm-tag">int</span> oflag, mode_t mode , <span class="hljs-keyword cye-lm-tag">int</span> <span class="hljs-keyword cye-lm-tag">value</span>);</code></pre>

<table>
<thead>
<tr>
  <th>参数</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>name</td>
  <td align="center">文件的路径名；</td>
</tr>
<tr>
  <td>Oflag</td>
  <td align="center">有O_CREAT或O_CREAT</td>
</tr>
<tr>
  <td>mode_t</td>
  <td align="center">控制新的信号量的访问权限；</td>
</tr>
<tr>
  <td>Value</td>
  <td align="center">指定信号量的初始化值。</td>
</tr>
</tbody></table>


<blockquote>
  <p class="cye-lm-tag">注意：</p>
  
  <p class="cye-lm-tag">这里的name不能写成/tmp/aaa.sem这样的格式，因为在linux下，sem都是创建在/dev/shm目录下。你可以将name写成“/mysem”或“mysem”，创建出来的文件都是“/dev/shm/sem.mysem”，千万不要写路径。也千万不要写“/tmp/mysem”之类的。</p>
  
  <p class="cye-lm-tag">当oflag = O_CREAT时，若name指定的信号量不存在时，则会创建一个，而且后面的mode和value参数必须有效。若name指定的信号量已存在，则直接打开该信号量，</p>
  
  <p class="cye-lm-tag">同时忽略mode和value参数。</p>
  
  <p class="cye-lm-tag">当oflag = O_CREAT|O_EXCL时，若name指定的信号量已存在，该函数会直接返回error。</p>
</blockquote>

<ul>
<li>一旦你使用了一信号量，销毁它们就变得很重要。 <br />
在做这个之前，要确定所有对这个有名信号量的引用都已经通过sem_close（）函数关闭了，然后只需在退出或是退出处理函数中调用sem_unlink()去删除系统中的信号量， <br />
注意如果有任何的处理器或是线程引用这个信号量，sem_unlink()函数不会起到任何的作用。</li>
</ul>

<p class="cye-lm-tag">也就是说，必须是最后一个使用该信号量的进程来执行sem_unlick才有效。因为每个信号灯有一个引用计数器记录当前的打开次数，sem_unlink必须等待这个数为0时才能把name所指的信号灯从文件系统中删除。也就是要等待最后一个sem_close发生。</p>



<h3 id="有名信号量在无相关进程间的同步">有名信号量在无相关进程间的同步</h3>

<hr />

<p class="cye-lm-tag">前面已经说过，有名信号量是位于共享内存区的，那么它要保护的资源也必须是位于共享内存区，只有这样才能被无相关的进程所共享。 <br />
在下面这个例子中，服务进程和客户进程都使用<code>shmget</code>和<code>shmat</code>来获取得一块共享内存资源。然后利用有名信号量来对这块共享内存资源进行互斥保护。</p>

<p class="cye-lm-tag">服务器程序</p>

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment cye-lm-tag">//server.c</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>

<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/shm.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;fcntl.h&gt;</span>

<span class="hljs-preprocessor cye-lm-tag">#define SHMSZ 27</span>

<span class="hljs-keyword cye-lm-tag">char</span> SEM_NAME[]= <span class="hljs-string cye-lm-tag">"vik"</span>;


<span class="hljs-keyword cye-lm-tag">int</span> main()
{
    <span class="hljs-keyword cye-lm-tag">char</span>    ch;
    <span class="hljs-keyword cye-lm-tag">int</span>     shmid;
    key_t   key;
    <span class="hljs-keyword cye-lm-tag">char</span>    *shm,*s;
    sem_t   *mutex;

    <span class="hljs-comment cye-lm-tag">//name the shared memory segment</span>
    key = <span class="hljs-number cye-lm-tag">1000</span>;

    <span class="hljs-comment cye-lm-tag">//create &amp; initialize semaphore</span>
    mutex = sem_open(SEM_NAME, O_CREAT, <span class="hljs-number cye-lm-tag">0644</span>, <span class="hljs-number cye-lm-tag">1</span>);
    <span class="hljs-keyword cye-lm-tag">if</span>(mutex == SEM_FAILED)
    {
        perror(<span class="hljs-string cye-lm-tag">"unable to create semaphore"</span>);
        sem_unlink(SEM_NAME);

        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-comment cye-lm-tag">//create the shared memory segment with this key</span>
    shmid = shmget(key, SHMSZ, IPC_CREAT | <span class="hljs-number cye-lm-tag">0666</span>);
    <span class="hljs-keyword cye-lm-tag">if</span>(shmid &lt; <span class="hljs-number cye-lm-tag">0</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"failure in shmget"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-comment cye-lm-tag">//attach this segment to virtual memory</span>
    shm = shmat(shmid, NULL, <span class="hljs-number cye-lm-tag">0</span>);
    <span class="hljs-comment cye-lm-tag">//start writing into memory</span>
    s = shm;
    <span class="hljs-keyword cye-lm-tag">for</span>(ch = <span class="hljs-string cye-lm-tag">'A'</span>; ch &lt;= <span class="hljs-string cye-lm-tag">'Z'</span>; ch++)
    {
        sem_wait(mutex);

        *s++ = ch;

        sem_post(mutex);
    }

    <span class="hljs-comment cye-lm-tag">//the below loop could be replaced by binary semaphore</span>
    <span class="hljs-keyword cye-lm-tag">while</span>(*shm != <span class="hljs-string cye-lm-tag">'*'</span>)
    {
        sleep(<span class="hljs-number cye-lm-tag">1</span>);
    }

    sem_close(mutex);

    sem_unlink(SEM_NAME);

    shmctl(shmid, IPC_RMID, <span class="hljs-number cye-lm-tag">0</span>);

    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;

}
</code></pre>

<p class="cye-lm-tag">客户端程序</p>

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment cye-lm-tag">// client.c</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>


<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/shm.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/stat.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;fcntl.h&gt;</span>

<span class="hljs-preprocessor cye-lm-tag">#define SHMSZ 27</span>

<span class="hljs-keyword cye-lm-tag">char</span> SEM_NAME[]= <span class="hljs-string cye-lm-tag">"vik"</span>;

<span class="hljs-keyword cye-lm-tag">int</span> main()
{
    <span class="hljs-keyword cye-lm-tag">int</span>     shmid;
    key_t   key;
    <span class="hljs-keyword cye-lm-tag">char</span>    *shm, *s;
    sem_t   *mutex;

    <span class="hljs-comment cye-lm-tag">//  name the shared memory segment</span>
    key = <span class="hljs-number cye-lm-tag">1000</span>;

    <span class="hljs-comment cye-lm-tag">//  create &amp; initialize existing semaphore</span>
    mutex = sem_open(SEM_NAME, <span class="hljs-number cye-lm-tag">0</span>, <span class="hljs-number cye-lm-tag">0644</span>, <span class="hljs-number cye-lm-tag">0</span>);
    <span class="hljs-keyword cye-lm-tag">if</span>(mutex == SEM_FAILED)
    {
        perror(<span class="hljs-string cye-lm-tag">"reader:unable to execute semaphore"</span>);
        sem_close(mutex);

        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-comment cye-lm-tag">//  create the shared memory segment with this key</span>
    shmid = shmget(key, SHMSZ, <span class="hljs-number cye-lm-tag">0666</span>);
    <span class="hljs-keyword cye-lm-tag">if</span>(shmid &lt; <span class="hljs-number cye-lm-tag">0</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"reader:failure in shmget"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-comment cye-lm-tag">//  attach this segment to virtual memory</span>
    shm = shmat(shmid, NULL, <span class="hljs-number cye-lm-tag">0</span>);

    <span class="hljs-comment cye-lm-tag">//  start reading</span>
    s = shm;
    <span class="hljs-keyword cye-lm-tag">for</span>(s = shm; *s != <span class="hljs-string cye-lm-tag">'\0'</span>; s++)
    {
        sem_wait(mutex);

        <span class="hljs-built_in cye-lm-tag">putchar</span>(*s);

        sem_post(mutex);
    }

    <span class="hljs-comment cye-lm-tag">//  once done signal exiting of reader:This can be replaced by another semaphore</span>
    *shm = <span class="hljs-string cye-lm-tag">'*'</span>;
    sem_close(mutex);
    shmctl(shmid, IPC_RMID, <span class="hljs-number cye-lm-tag">0</span>);

    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>

<h1 id="system-v信号量">SYSTEM V信号量</h1>

<hr />

<p class="cye-lm-tag">这是信号量值的集合，而不是单个信号量。相关的信号量操作函数由<code>&lt;sys/ipc.h&gt;</code>引用。</p>

<p class="cye-lm-tag">ystem V 信号量在内核中维护，其中包括二值信号量 、计数信号量、计数信号量集。</p>

<ul>
<li><p class="cye-lm-tag">二值信号量 ： 其值只有0、1 两种选择，0表示资源被锁，1表示资源可用；</p></li>
<li><p class="cye-lm-tag">计数信号量：其值在0 和某个限定值之间，不限定资源数只在0 1 之间；</p></li>
<li><p class="cye-lm-tag">计数信号量集 ：多个信号量的集合组成信号量集</p></li>
</ul>

<h2 id="信号量结构体">信号量结构体</h2>

<hr />

<p class="cye-lm-tag">内核为每个信号量集维护一个信号量结构体，可在</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">struct</span> semid_ds
{
    <span class="hljs-keyword cye-lm-tag">struct</span> ipc_perm sem_perm; <span class="hljs-comment cye-lm-tag">/* 信号量集的操作许可权限 */</span>
    <span class="hljs-keyword cye-lm-tag">struct</span> sem *sem_base; <span class="hljs-comment cye-lm-tag">/* 某个信号量sem结构数组的指针，当前信号量集中的每个信号量对应其中一个数组元素 */</span>
    <span class="hljs-keyword cye-lm-tag">ushort</span> sem_nsems; <span class="hljs-comment cye-lm-tag">/* sem_base 数组的个数 */</span>
    time_t sem_otime; <span class="hljs-comment cye-lm-tag">/* 最后一次成功修改信号量数组的时间 */</span>
    time_t sem_ctime; <span class="hljs-comment cye-lm-tag">/* 成功创建时间 */</span>
};</code></pre>

<p class="cye-lm-tag">其中ipc_perm 结构是内核给每个进程间通信对象维护的一个信息结构，其成员包含所有者用户id，所有者组id、创建者及其组id，以及访问模式等；semid_ds结构体中的sem结构是内核用于维护某个给定信号量的一组值的内部结构，其结构定义：</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">struct</span> sem {
<span class="hljs-keyword cye-lm-tag">ushort</span> semval; <span class="hljs-comment cye-lm-tag">/* 信号量的当前值 */</span>
<span class="hljs-keyword cye-lm-tag">short</span> sempid; <span class="hljs-comment cye-lm-tag">/* 最后一次返回该信号量的进程ID 号 */</span>
<span class="hljs-keyword cye-lm-tag">ushort</span> semncnt; <span class="hljs-comment cye-lm-tag">/* 等待semval大于当前值的进程个数 */</span>
<span class="hljs-keyword cye-lm-tag">ushort</span> semzcnt; <span class="hljs-comment cye-lm-tag">/* 等待semval变成0的进程个数 */</span>
};</code></pre>

<h2 id="常见的system-v信号量函数">常见的SYSTEM V信号量函数</h2>

<hr />



<h3 id="关键字和描述符">关键字和描述符</h3>

<hr />

<p class="cye-lm-tag">SYSTEM V信号量是SYSTEM V IPC（即SYSTEM V进程间通信）的组成部分，其他的有SYSTEM V消息队列，SYSTEM V共享内存。而关键字和IPC描述符无疑是它们的共同点，也使用它们，就不得不先对它们进行熟悉。这里只对SYSTEM V信号量进行讨论。</p>

<p class="cye-lm-tag">IPC描述符相当于引用ID号，要想使用SYSTEM V信号量（或MSG、SHM），就必须用IPC描述符来调用信号量。而IPC描述符是内核动态提供的（通过semget来获取），用户无法让服务器和客户事先认可共同使用哪个描述符，所以有时候就需要到关键字KEY来定位描述符。</p>

<p class="cye-lm-tag">某个KEY只会固定对应一个描述符（这项转换工作由内核完成），这样假如服务器和</p>

<p class="cye-lm-tag">客户事先认可共同使用某个KEY，那么大家就都能定位到同一个描述符，也就能定位到同一个信号量，这样就达到了SYSTEM V信号量在进程间共享的目的。</p>



<h3 id="创建和打开信号量">创建和打开信号量</h3>

<hr />

<p class="cye-lm-tag">创建一个信号量或访问一个已经存在的信号量集。</p>

<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword cye-lm-tag">int</span> <span class="hljs-keyword cye-lm-tag">semget</span>(key_t key, <span class="hljs-keyword cye-lm-tag">int</span> nsems, <span class="hljs-keyword cye-lm-tag">int</span> oflag)</code></pre>

<p class="cye-lm-tag">该函数执行成功返回信号量标示符，失败返回-1</p>

<table>
<thead>
<tr>
  <th>参数</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>key</td>
  <td align="center">通过调用ftok函数得到的键值</td>
</tr>
<tr>
  <td>nsems</td>
  <td align="center">代表创建信号量的个数，如果只是访问而不创建则可以指定该参数为0，我们一旦创建了该信号量，就不能更改其信号量个数，只要你不删除该信号量，你就是重新调用该函数创建该键值的信号量，该函数只是返回以前创建的值，不会重新创建；</td>
</tr>
<tr>
  <td>semflg</td>
  <td align="center">指定该信号量的读写权限，当创建信号量时不许加IPC_CREAT ，若指定IPC_CREAT</td>
</tr>
</tbody></table>


<p class="cye-lm-tag">semget函数执行成功后，就产生了一个由内核维持的类型为semid_ds结构体的信号量集，返回semid就是指向该信号量集的引索。</p>

<ul>
<li><p class="cye-lm-tag">nsems&gt;0 : 创建一个信的信号量集，指定集合中信号量的数量，一旦创建就不能更改。</p></li>
<li><p class="cye-lm-tag">nsems==0 : 访问一个已存在的集合</p></li>
<li><p class="cye-lm-tag">返回的是一个称为信号量标识符的整数，semop和semctl函数将使用它。</p></li>
<li><p class="cye-lm-tag">创建成功后信号量结构被设置：</p></li>
</ul>

<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor cye-lm-tag">.sem</span>_perm 的uid和gid成员被设置成的调用进程的有效用户ID和有效组ID
<span class="hljs-preprocessor cye-lm-tag">.oflag</span> 参数中的读写权限位存入sem_perm<span class="hljs-preprocessor cye-lm-tag">.mode</span>
<span class="hljs-preprocessor cye-lm-tag">.sem</span>_otime 被置为<span class="hljs-number cye-lm-tag">0</span>,sem_ctime被设置为当前时间
<span class="hljs-preprocessor cye-lm-tag">.sem</span>_nsems 被置为nsems参数的值</code></pre>

<p class="cye-lm-tag">该集合中的每个信号量不初始化，这些结构是在semctl，用参数SET_VAL，SETALL初始化的。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>

<span class="hljs-preprocessor cye-lm-tag">#define SEM_R    0400   <span class="hljs-comment cye-lm-tag">//用户（属主）读</span></span>
<span class="hljs-preprocessor cye-lm-tag">#define SEM_A    0200   <span class="hljs-comment cye-lm-tag">//用户（属主）写</span></span>

<span class="hljs-preprocessor cye-lm-tag">#define SVSEM_MODE (SEM_R | SEM_A | SEM_R&gt;&gt;3 | SEM_R&gt;&gt;6)</span>

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc,<span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    <span class="hljs-keyword cye-lm-tag">int</span>   c, oflag, semid, nsems;

    oflag = SVSEM_MODE | IPC_CREAT;   <span class="hljs-comment cye-lm-tag">//设置创建模式</span>

    <span class="hljs-comment cye-lm-tag">//根据命令行参数e判断是否制定了IPC_EXCL模式</span>
    <span class="hljs-keyword cye-lm-tag">while</span>((c = getopt(argc,argv,<span class="hljs-string cye-lm-tag">"e"</span>)) != -<span class="hljs-number cye-lm-tag">1</span>)
    {
        <span class="hljs-keyword cye-lm-tag">switch</span>(c)
        {
            <span class="hljs-keyword cye-lm-tag">case</span> <span class="hljs-string cye-lm-tag">'e'</span>:
                oflag |= IPC_EXCL;
                <span class="hljs-keyword cye-lm-tag">break</span>;
        }
    }

    <span class="hljs-comment cye-lm-tag">//判断命令行参数是否合法</span>
    <span class="hljs-keyword cye-lm-tag">if</span> (optind != argc -<span class="hljs-number cye-lm-tag">2</span>)
    {
        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"usage: semcreate [-e] &lt;pathname&gt; &lt;nsems&gt;"</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-comment cye-lm-tag">//获取信号量集合中的信号量个数</span>
    nsems = atoi(argv[optind+<span class="hljs-number cye-lm-tag">1</span>]);

    <span class="hljs-comment cye-lm-tag">//创建信号量，通过ftok函数创建一个key，返回信号量 标识符</span>
    semid = semget(ftok(argv[optind],<span class="hljs-number cye-lm-tag">0</span>),nsems,oflag);


    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>

<h3 id="关键字的获取">关键字的获取</h3>

<hr />

<p class="cye-lm-tag">有多种方法使客户机和服务器在同一IPC结构上会合： <br />
*   服务器可以指定关键字IPC_PRIVATE创建一个新IPC结构，将返回的标识符存放在某处（例如一个文件）以便客户机取用。关键字 IPC_PRIVATE保证服务器创建一个新IPC结构。这种技术的缺点是：服务器要将整型标识符写到文件中，然后客户机在此后又要读文件取得此标识符。</p>

<p class="cye-lm-tag">IPC_PRIVATE关键字也可用于父、子关系进程。父进程指定 IPC_PRIVATE创建一个新IPC结构，所返回的标识符在fork后可由子进程使用。子进程可将此标识符作为exec函数的一个参数传给一个新程序。</p>

<ul>
<li><p class="cye-lm-tag">在一个公用头文件中定义一个客户机和服务器都认可的关键字。然后服务器指定此关键字创建一个新的IPC结构。这种方法的问题是该关键字可能已与一个 IPC结构相结合，在此情况下，get函数（msgget、semget或shmget）出错返回。服务器必须处理这一错误，删除已存在的IPC结构，然后试着再创建它。当然，这个关键字不能被别的程序所占用。</p></li>
<li><p class="cye-lm-tag">客户机和服务器认同一个路径名和课题I D（课题I D是0 ~ 2 5 5之间的字符值） ，然后调用函数ftok将这两个值变换为一个关键字。这样就避免了使用一个已被占用的关键字的问题。 <br />
使用ftok并非高枕无忧。有这样一种例外：服务器使用ftok获取得一个关键字后，该文件就被删除了，然后重建。此时客户端以此重建后的文件来ftok所获取的关键字就和服务器的关键字不一样了。所以一般商用的软件都不怎么用ftok。 <br />
一般来说，客户机和服务器至少共享一个头文件，所以一个比较简单的方法是避免使用ftok，而只是在该头文件中存放一个大家都知道的关键字。</p></li>
</ul>



<h3 id="设置信号量的值pv操作">设置信号量的值（PV操作）</h3>

<hr />



<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword cye-lm-tag">int</span> <span class="hljs-keyword cye-lm-tag">semop</span>(<span class="hljs-keyword cye-lm-tag">int</span> semid, struct sembuf <span class="hljs-variable cye-lm-tag">*opsptr</span>, size_t nops);</code></pre>

<table>
<thead>
<tr>
  <th>参数</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>semid</td>
  <td align="center">是semget返回的semid信号量标示符</td>
</tr>
<tr>
  <td>opsptr</td>
  <td align="center">指向信号量操作结构数组</td>
</tr>
<tr>
  <td>nops</td>
  <td align="center">opsptr所指向的数组中的sembuf结构体的个数</td>
</tr>
</tbody></table>


<p class="cye-lm-tag">该函数执行成功返回0，失败返回-1；</p>

<p class="cye-lm-tag">第二个参数sops为一个结构体数组指针，结构体定义在sys/sem.h中，结构体如下</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">struct</span> sembuf {
   <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span> sem_num; <span class="hljs-comment cye-lm-tag">/* semaphore index in array */</span>
   <span class="hljs-keyword cye-lm-tag">short</span> sem_op; <span class="hljs-comment cye-lm-tag">/* semaphore operation */</span>
   <span class="hljs-keyword cye-lm-tag">short</span> sem_flg; <span class="hljs-comment cye-lm-tag">/* operation flags */</span>
};</code></pre>

<p class="cye-lm-tag">sem_num 操作信号的下标，其值可以为0 到nops <br />
sem_flg为该信号操作的标志：其值可以为0、IPC_NOWAIT 、 SEM_UNDO</p>

<table>
<thead>
<tr>
  <th>sem_flg标识</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>0</td>
  <td align="center">在对信号量的操作不能执行的情况下，该操作阻塞到可以执行为止；</td>
</tr>
<tr>
  <td>IPC_NOWAIT</td>
  <td align="center">在对信号量的操作不能执行的情况下，该操作立即返回；</td>
</tr>
<tr>
  <td>SEM_UNDO</td>
  <td align="center">当操作的进程推出后，该进程对sem进行的操作将被取消；</td>
</tr>
</tbody></table>


<table>
<thead>
<tr>
  <th>sem_op取值</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td><span class="MathJax_Preview cye-lm-tag"></span><span class="MathJax cye-lm-tag" id="MathJax-Element-17-Frame" role="textbox" aria-readonly="true"><nobr><span class="math cye-lm-tag" id="MathJax-Span-65" style="width: 1.701em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.575em; height: 0px; font-size: 106%;" class="cye-lm-tag"><span style="position: absolute; clip: rect(1.89em 1000em 3.022em -0.5em); top: -2.764em; left: 0.003em;" class="cye-lm-tag"><span class="mrow cye-lm-tag" id="MathJax-Span-66"><span class="mo cye-lm-tag" id="MathJax-Span-67" style="font-family: MathJax_Main;">&gt;</span><span class="mn cye-lm-tag" id="MathJax-Span-68" style="font-family: MathJax_Main; padding-left: 0.255em;">0</span></span><span style="display: inline-block; width: 0px; height: 2.77em;" class="cye-lm-tag"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.87em; vertical-align: -0.13em;" class="cye-lm-tag"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-17">&gt; 0</script></td>
  <td align="center">则信号量加上它的值，等价于进程释放信号量控制的资源</td>
</tr>
<tr>
  <td><span class="MathJax_Preview cye-lm-tag"></span><span class="MathJax cye-lm-tag" id="MathJax-Element-18-Frame" role="textbox" aria-readonly="true"><nobr><span class="math cye-lm-tag" id="MathJax-Span-69" style="width: 1.701em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.575em; height: 0px; font-size: 106%;" class="cye-lm-tag"><span style="position: absolute; clip: rect(1.89em 1000em 2.959em -0.5em); top: -2.764em; left: 0.003em;" class="cye-lm-tag"><span class="mrow cye-lm-tag" id="MathJax-Span-70"><span class="mo cye-lm-tag" id="MathJax-Span-71" style="font-family: MathJax_Main;">=</span><span class="mn cye-lm-tag" id="MathJax-Span-72" style="font-family: MathJax_Main; padding-left: 0.255em;">0</span></span><span style="display: inline-block; width: 0px; height: 2.77em;" class="cye-lm-tag"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.87em; vertical-align: -0.063em;" class="cye-lm-tag"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-18">= 0</script></td>
  <td align="center">若没有设置IPC_NOWAIT， 那么调用进程将进入睡眠状态，直到信号量的值为0，否则进程直接返回</td>
</tr>
<tr>
  <td><span class="MathJax_Preview cye-lm-tag"></span><span class="MathJax cye-lm-tag" id="MathJax-Element-19-Frame" role="textbox" aria-readonly="true"><nobr><span class="math cye-lm-tag" id="MathJax-Span-73" style="width: 1.701em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.575em; height: 0px; font-size: 106%;" class="cye-lm-tag"><span style="position: absolute; clip: rect(1.89em 1000em 3.022em -0.5em); top: -2.764em; left: 0.003em;" class="cye-lm-tag"><span class="mrow cye-lm-tag" id="MathJax-Span-74"><span class="mo cye-lm-tag" id="MathJax-Span-75" style="font-family: MathJax_Main;">&lt;</span><span class="mn cye-lm-tag" id="MathJax-Span-76" style="font-family: MathJax_Main; padding-left: 0.255em;">0</span></span><span style="display: inline-block; width: 0px; height: 2.77em;" class="cye-lm-tag"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 0.87em; vertical-align: -0.13em;" class="cye-lm-tag"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-19">&lt; 0</script></td>
  <td align="center">则信号量加上它的值，等价于进程申请信号量控制的资源，若进程设置IPC_NOWAIT则进程再没有可用资源情况下，进程阻塞，否则直接返回。</td>
</tr>
</tbody></table>


<blockquote>
  <p class="cye-lm-tag">例如，当前semval为2，而sem_op = -3，那么怎么办？</p>
  
  <p class="cye-lm-tag">注意：semval是指semid_ds中的信号量集中的某个信号量的值</p>
</blockquote>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc,<span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    <span class="hljs-keyword cye-lm-tag">int</span>     c,i,flag,semid,nops;
    <span class="hljs-keyword cye-lm-tag">struct</span>  sembuf *ptr;
    flag = <span class="hljs-number cye-lm-tag">0</span>;
        <span class="hljs-comment cye-lm-tag">//根据命令行参数设置操作模式</span>
    <span class="hljs-keyword cye-lm-tag">while</span>( ( c = getopt(argc,argv,<span class="hljs-string cye-lm-tag">"nu"</span>)) != -<span class="hljs-number cye-lm-tag">1</span>)
    {
        <span class="hljs-keyword cye-lm-tag">switch</span>(c)
        {
            <span class="hljs-keyword cye-lm-tag">case</span> <span class="hljs-string cye-lm-tag">'n'</span>:
                flag |= IPC_NOWAIT;   <span class="hljs-comment cye-lm-tag">//非阻塞</span>
                <span class="hljs-keyword cye-lm-tag">break</span>;
            <span class="hljs-keyword cye-lm-tag">case</span> <span class="hljs-string cye-lm-tag">'u'</span>:
                flag |= SEM_UNDO;   <span class="hljs-comment cye-lm-tag">//不可恢复</span>
                <span class="hljs-keyword cye-lm-tag">break</span>;
        }
    }
    <span class="hljs-keyword cye-lm-tag">if</span>(argc - optind &lt; <span class="hljs-number cye-lm-tag">2</span>)
    {
        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"usage: semops [-n] [-u] &lt;pathname&gt; operation..."</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }
    <span class="hljs-comment cye-lm-tag">//打开一个已经存在的信号量集合</span>
    <span class="hljs-keyword cye-lm-tag">if</span>((semid = semget(ftok(argv[optind],<span class="hljs-number cye-lm-tag">0</span>),<span class="hljs-number cye-lm-tag">0</span>,<span class="hljs-number cye-lm-tag">0</span>)) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"semget() error"</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }
    optind++;  <span class="hljs-comment cye-lm-tag">//指向当前第一个信号量的位置</span>
    nops = argc - optind;   <span class="hljs-comment cye-lm-tag">//信号量个数</span>
    ptr = <span class="hljs-built_in cye-lm-tag">calloc</span>(nops,<span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">struct</span> sembuf));
    <span class="hljs-keyword cye-lm-tag">for</span>(i=<span class="hljs-number cye-lm-tag">0</span>;i&lt;nops;++i)
    {
        ptr[i].sem_num = i;  <span class="hljs-comment cye-lm-tag">//信号量变换</span>
        ptr[i].sem_op = atoi(argv[optind+i]);   <span class="hljs-comment cye-lm-tag">//设置信号量的值</span>
        ptr[i].sem_flg = flag;   <span class="hljs-comment cye-lm-tag">//设置操作模式</span>
    }
    <span class="hljs-comment cye-lm-tag">//对信号量执行操作</span>
    <span class="hljs-keyword cye-lm-tag">if</span>(semop(semid,ptr,nops) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"semop() error"</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(-<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>



<h3 id="对信号集实行控制操作semval的赋值等">对信号集实行控制操作（semval的赋值等）</h3>

<hr />



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword cye-lm-tag">int</span> semctl(<span class="hljs-keyword cye-lm-tag">int</span> semid, <span class="hljs-keyword cye-lm-tag">int</span> semum, <span class="hljs-keyword cye-lm-tag">int</span> cmd, ..<span class="hljs-comment cye-lm-tag">/* union semun arg */</span>);</code></pre>

<table>
<thead>
<tr>
  <th>参数</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>semid</td>
  <td align="center">是信号量集合；</td>
</tr>
<tr>
  <td>semnum</td>
  <td align="center">是信号在集合中的序号；</td>
</tr>
<tr>
  <td>semum</td>
  <td align="center">是一个必须由用户自定义的结构体，在这里我们务必弄清楚该结构体的组成：</td>
</tr>
</tbody></table>




<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword cye-lm-tag">union</span> semun
{
<span class="hljs-keyword cye-lm-tag">int</span> val; <span class="hljs-comment cye-lm-tag">// cmd == SETVAL</span>
<span class="hljs-keyword cye-lm-tag">struct</span> semid_ds *buf <span class="hljs-comment cye-lm-tag">// cmd == IPC_SET或者 cmd == IPC_STAT</span>
ushort *<span class="hljs-built_in cye-lm-tag">array</span>; <span class="hljs-comment cye-lm-tag">// cmd == SETALL，或 cmd = GETALL</span>
};</code></pre>

<table>
<thead>
<tr>
  <th>值</th>
  <th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
  <td>IPC_STAT</td>
  <td align="center">读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。</td>
</tr>
<tr>
  <td>IPC_SET</td>
  <td align="center">设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。</td>
</tr>
<tr>
  <td>IPC_RMID</td>
  <td align="center">将信号量集从系统中删除</td>
</tr>
<tr>
  <td>GETALL</td>
  <td align="center">用于读取信号量集中的所有信号量的值，存于semnu的array中</td>
</tr>
<tr>
  <td>SETALL</td>
  <td align="center">设置所指定的信号量集的每个成员semval的值</td>
</tr>
<tr>
  <td>GETPID</td>
  <td align="center">返回最后一个执行semop操作的进程的PID。</td>
</tr>
<tr>
  <td>LSETVAL</td>
  <td align="center">把的val数据成员设置为当前资源数</td>
</tr>
<tr>
  <td>GETVAL</td>
  <td align="center">把semval中的当前值作为函数的返回，即现有的资源数，返回值为非负数。</td>
</tr>
</tbody></table>


<p class="cye-lm-tag">val只有cmd ==SETVAL时才有用，此时指定的semval = arg.val。</p>

<blockquote>
  <p class="cye-lm-tag">注意：当cmd == GETVAL时，semctl函数返回的值就是我们想要的semval。千万不要以为指定的semval被返回到arg.val中。</p>
</blockquote>

<p class="cye-lm-tag">array指向一个数组，</p>

<p class="cye-lm-tag">当cmd==SETALL时，就根据arg.array来将信号量集的所有值都赋值；</p>

<p class="cye-lm-tag">当cmd ==GETALL时，就将信号量集的所有值返回到arg.array指定的数组中。</p>

<p class="cye-lm-tag">buf 指针只在cmd==IPC_STAT 或IPC_SET 时有用，作用是semid 所指向的信号量集</p>

<blockquote>
  <p class="cye-lm-tag">（semid_ds机构体）。一般情况下不常用，这里不做谈论。</p>
  
  <p class="cye-lm-tag">另外，cmd == IPC_RMID还是比较有用的。</p>
</blockquote>

<h2 id="示例程序">示例程序</h2>

<hr />



<h3 id="调用semctl函数设置信号量的值程序">调用semctl函数设置信号量的值程序</h3>

<hr />



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>

<span class="hljs-comment cye-lm-tag">//定义信号量操作共用体结构</span>
<span class="hljs-keyword cye-lm-tag">union</span> semun
{
    <span class="hljs-keyword cye-lm-tag">int</span>                val;
    <span class="hljs-keyword cye-lm-tag">struct</span> semid_ds    *buf;
    <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span>     *<span class="hljs-built_in cye-lm-tag">array</span>;
};

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc,<span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    <span class="hljs-keyword cye-lm-tag">int</span> semid,nsems,i;
    <span class="hljs-keyword cye-lm-tag">struct</span> semid_ds seminfo;
    <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span> *ptr;
    <span class="hljs-keyword cye-lm-tag">union</span> semun arg;

    <span class="hljs-keyword cye-lm-tag">if</span>(argc &lt; <span class="hljs-number cye-lm-tag">2</span>)
    {
            <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"usage: semsetvalues &lt;pathname&gt;[values ...]"</span>);
            <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }

    <span class="hljs-comment cye-lm-tag">//打开已经存在的信号量集合</span>
    semid = semget(ftok(argv[<span class="hljs-number cye-lm-tag">1</span>],<span class="hljs-number cye-lm-tag">0</span>),<span class="hljs-number cye-lm-tag">0</span>,<span class="hljs-number cye-lm-tag">0</span>);
    arg.buf = &amp;seminfo;

    <span class="hljs-comment cye-lm-tag">//获取信号量集的相关信息</span>
    semctl(semid,<span class="hljs-number cye-lm-tag">0</span>,IPC_STAT,arg);
    nsems = arg.buf-&gt;sem_nsems;  <span class="hljs-comment cye-lm-tag">//信号量的个数</span>
    <span class="hljs-keyword cye-lm-tag">if</span>(argc != nsems + <span class="hljs-number cye-lm-tag">2</span> )
    {
        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"%s semaphores in set,%d values specified"</span>,nsems,argc-<span class="hljs-number cye-lm-tag">2</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }

    <span class="hljs-comment cye-lm-tag">//分配信号量</span>
    ptr = <span class="hljs-built_in cye-lm-tag">calloc</span>(nsems,<span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span>));
    arg.<span class="hljs-built_in cye-lm-tag">array</span> = ptr;

    <span class="hljs-comment cye-lm-tag">//初始化信号量的值</span>
    <span class="hljs-keyword cye-lm-tag">for</span>(i=<span class="hljs-number cye-lm-tag">0</span>;i&lt;nsems;i++)
    {
        ptr[i] = atoi(argv[i+<span class="hljs-number cye-lm-tag">2</span>]);
    }


    <span class="hljs-comment cye-lm-tag">//通过arg设置信号量集合</span>
    semctl(semid,<span class="hljs-number cye-lm-tag">0</span>,SETALL,arg);

    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>

<h3 id="调用semctl获取信号量的值">调用semctl获取信号量的值</h3>

<hr />

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">union</span> semun
{
    <span class="hljs-keyword cye-lm-tag">int</span>             val;
    <span class="hljs-keyword cye-lm-tag">struct</span> semid_ds *buf;
    <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span>     *<span class="hljs-built_in cye-lm-tag">array</span>;
};

<span class="hljs-keyword cye-lm-tag">int</span> main(<span class="hljs-keyword cye-lm-tag">int</span> argc,<span class="hljs-keyword cye-lm-tag">char</span> *argv[])
{
    <span class="hljs-keyword cye-lm-tag">int</span>     semid,nsems,i;
    <span class="hljs-keyword cye-lm-tag">struct</span> semid_ds seminfo;
    <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span> *ptr;
    <span class="hljs-keyword cye-lm-tag">union</span> semun arg;

    <span class="hljs-keyword cye-lm-tag">if</span>(argc != <span class="hljs-number cye-lm-tag">2</span>)
    {
        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"usage: semgetvalues&lt;pathname&gt;"</span>);
        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
    }

    <span class="hljs-comment cye-lm-tag">//打开已经存在的信号量</span>
    semid = semget(ftok(argv[<span class="hljs-number cye-lm-tag">1</span>], <span class="hljs-number cye-lm-tag">0</span>), <span class="hljs-number cye-lm-tag">0</span>, <span class="hljs-number cye-lm-tag">0</span>);
    arg.buf = &amp;seminfo;

    <span class="hljs-comment cye-lm-tag">//获取信号量集的属性，返回semid_ds结构</span>
    semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, IPC_STAT, arg);
    nsems = arg.buf-&gt;sem_nsems;     <span class="hljs-comment cye-lm-tag">//信号量的数目</span>

    ptr = <span class="hljs-built_in cye-lm-tag">calloc</span>(nsems,<span class="hljs-keyword cye-lm-tag">sizeof</span>(<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span>));
    arg.<span class="hljs-built_in cye-lm-tag">array</span> = ptr;

    <span class="hljs-comment cye-lm-tag">//获取信号量的值</span>
    semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, GETALL, arg);
    <span class="hljs-keyword cye-lm-tag">for</span>(i = <span class="hljs-number cye-lm-tag">0</span>; i &lt; nsems; i++)
    {
        <span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"semval[%d] = %d\n"</span>, i, ptr[i]);
    }

    <span class="hljs-keyword cye-lm-tag">return</span> EXIT_SUCCESS;
}
</code></pre>

<h3 id="通过semctl实现pv操作的函数库">通过semctl实现PV操作的函数库</h3>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor cye-lm-tag">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword cye-lm-tag">union</span> semun
{
    <span class="hljs-keyword cye-lm-tag">int</span>                 val;
    <span class="hljs-keyword cye-lm-tag">struct</span> semid_ds     *buf;
    <span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span>      *<span class="hljs-built_in cye-lm-tag">array</span>;
};

<span class="hljs-comment cye-lm-tag">// 将信号量sem_id设置为init_value</span>
<span class="hljs-keyword cye-lm-tag">int</span> init_sem(<span class="hljs-keyword cye-lm-tag">int</span> sem_id, <span class="hljs-keyword cye-lm-tag">int</span> init_value)
{
    <span class="hljs-keyword cye-lm-tag">union</span> semun     sem_union;
    sem_union.val = init_value;

    <span class="hljs-keyword cye-lm-tag">if</span> (semctl(sem_id, <span class="hljs-number cye-lm-tag">0</span>, SETVAL, sem_union) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"Sem init"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-number cye-lm-tag">0</span>;
}

<span class="hljs-comment cye-lm-tag">// 删除sem_id信号量</span>
<span class="hljs-keyword cye-lm-tag">int</span> del_sem(<span class="hljs-keyword cye-lm-tag">int</span> sem_id)
{
    <span class="hljs-keyword cye-lm-tag">union</span> semun sem_union;
    <span class="hljs-keyword cye-lm-tag">if</span> (semctl(sem_id, <span class="hljs-number cye-lm-tag">0</span>, IPC_RMID, sem_union) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"Sem delete"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">1</span>);
    }
    <span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-number cye-lm-tag">0</span>;
}


<span class="hljs-comment cye-lm-tag">// 对sem_id执行p操作</span>
<span class="hljs-keyword cye-lm-tag">int</span> sem_p(<span class="hljs-keyword cye-lm-tag">int</span> sem_id)
{
    <span class="hljs-keyword cye-lm-tag">struct</span> sembuf   sem_buf;
    sem_buf.sem_num = <span class="hljs-number cye-lm-tag">0</span>;<span class="hljs-comment cye-lm-tag">//信号量编号</span>
    sem_buf.sem_op  = -<span class="hljs-number cye-lm-tag">1</span>;<span class="hljs-comment cye-lm-tag">//P操作</span>
    sem_buf.sem_flg = SEM_UNDO;<span class="hljs-comment cye-lm-tag">//系统退出前未释放信号量，系统自动释放</span>

    <span class="hljs-keyword cye-lm-tag">if</span> (semop(sem_id, &amp;sem_buf, <span class="hljs-number cye-lm-tag">1</span>) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"Sem P operation"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-number cye-lm-tag">0</span>;
}


<span class="hljs-comment cye-lm-tag">// 对sem_id执行V操作</span>
<span class="hljs-keyword cye-lm-tag">int</span> sem_v(<span class="hljs-keyword cye-lm-tag">int</span> sem_id)
{
    <span class="hljs-keyword cye-lm-tag">struct</span> sembuf   sem_buf;
    sem_buf.sem_num = <span class="hljs-number cye-lm-tag">0</span>;
    sem_buf.sem_op  = <span class="hljs-number cye-lm-tag">1</span>;<span class="hljs-comment cye-lm-tag">//V操作</span>
    sem_buf.sem_flg = SEM_UNDO;

    <span class="hljs-keyword cye-lm-tag">if</span> (semop(sem_id, &amp;sem_buf, <span class="hljs-number cye-lm-tag">1</span>) == -<span class="hljs-number cye-lm-tag">1</span>)
    {
        perror(<span class="hljs-string cye-lm-tag">"Sem V operation"</span>);

        <span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">1</span>);
    }

    <span class="hljs-keyword cye-lm-tag">return</span> <span class="hljs-number cye-lm-tag">0</span>;
}
</code></pre>

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/ipc.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;sys/sem.h&gt;</span>
<span class="hljs-preprocessor cye-lm-tag">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword cye-lm-tag">static</span> <span class="hljs-keyword cye-lm-tag">int</span> nsems;
<span class="hljs-keyword cye-lm-tag">static</span> <span class="hljs-keyword cye-lm-tag">int</span> semflg;
<span class="hljs-keyword cye-lm-tag">static</span> <span class="hljs-keyword cye-lm-tag">int</span> semid;
<span class="hljs-keyword cye-lm-tag">int</span> errno=<span class="hljs-number cye-lm-tag">0</span>;
<span class="hljs-keyword cye-lm-tag">union</span> semun {
<span class="hljs-keyword cye-lm-tag">int</span> val;
<span class="hljs-keyword cye-lm-tag">struct</span> semid_ds *buf;
<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span> *<span class="hljs-built_in cye-lm-tag">array</span>;
}arg;
<span class="hljs-keyword cye-lm-tag">int</span> main()
{
<span class="hljs-keyword cye-lm-tag">struct</span> sembuf sops[<span class="hljs-number cye-lm-tag">2</span>]; <span class="hljs-comment cye-lm-tag">//要用到两个信号量，所以要定义两个操作数组</span>
<span class="hljs-keyword cye-lm-tag">int</span> rslt;
<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">short</span> argarray[<span class="hljs-number cye-lm-tag">80</span>];
arg.<span class="hljs-built_in cye-lm-tag">array</span> = argarray;
semid = semget(IPC_PRIVATE, <span class="hljs-number cye-lm-tag">2</span>, <span class="hljs-number cye-lm-tag">0666</span>);
<span class="hljs-keyword cye-lm-tag">if</span>(semid &lt; <span class="hljs-number cye-lm-tag">0</span> )
{
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"semget failed. errno: %d\n"</span>, errno);
<span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
}
<span class="hljs-comment cye-lm-tag">//获取0th信号量的原始值</span>
rslt = semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, GETVAL);
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"val = %d\n"</span>,rslt);
<span class="hljs-comment cye-lm-tag">//初始化0th信号量，然后再读取，检查初始化有没有成功</span>
arg.val = <span class="hljs-number cye-lm-tag">1</span>; <span class="hljs-comment cye-lm-tag">// 同一时间只允许一个占有者</span>
semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, SETVAL, arg);
rslt = semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, GETVAL);
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"val = %d\n"</span>,rslt);
sops[<span class="hljs-number cye-lm-tag">0</span>].sem_num = <span class="hljs-number cye-lm-tag">0</span>;
sops[<span class="hljs-number cye-lm-tag">0</span>].sem_op = -<span class="hljs-number cye-lm-tag">1</span>;
sops[<span class="hljs-number cye-lm-tag">0</span>].sem_flg = <span class="hljs-number cye-lm-tag">0</span>;
sops[<span class="hljs-number cye-lm-tag">1</span>].sem_num = <span class="hljs-number cye-lm-tag">1</span>;
sops[<span class="hljs-number cye-lm-tag">1</span>].sem_op = <span class="hljs-number cye-lm-tag">1</span>;
sops[<span class="hljs-number cye-lm-tag">1</span>].sem_flg = <span class="hljs-number cye-lm-tag">0</span>;
rslt=semop(semid, sops, <span class="hljs-number cye-lm-tag">1</span>); <span class="hljs-comment cye-lm-tag">//申请0th信号量，尝试锁定</span>
<span class="hljs-keyword cye-lm-tag">if</span> (rslt &lt; <span class="hljs-number cye-lm-tag">0</span> )
{
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"semop failed. errno: %d\n"</span>, errno);
<span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
}
<span class="hljs-comment cye-lm-tag">//可以在这里对资源进行锁定</span>
sops[<span class="hljs-number cye-lm-tag">0</span>].sem_op = <span class="hljs-number cye-lm-tag">1</span>;
semop(semid, sops, <span class="hljs-number cye-lm-tag">1</span>); <span class="hljs-comment cye-lm-tag">//释放0th信号量</span>
rslt = semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, GETVAL);
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"val = %d\n"</span>,rslt);
rslt=semctl(semid, <span class="hljs-number cye-lm-tag">0</span>, GETALL, arg);
<span class="hljs-keyword cye-lm-tag">if</span> (rslt &lt; <span class="hljs-number cye-lm-tag">0</span>)
{
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"semctl failed. errno: %d\n"</span>, errno);
<span class="hljs-built_in cye-lm-tag">exit</span>(<span class="hljs-number cye-lm-tag">0</span>);
}
<span class="hljs-built_in cye-lm-tag">printf</span>(<span class="hljs-string cye-lm-tag">"val1:%d val2: %d\n"</span>,(<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">int</span>)argarray[<span class="hljs-number cye-lm-tag">0</span>],(<span class="hljs-keyword cye-lm-tag">unsigned</span> <span class="hljs-keyword cye-lm-tag">int</span>)argarray[<span class="hljs-number cye-lm-tag">1</span>]);
<span class="hljs-keyword cye-lm-tag">if</span>(semctl(semid, <span class="hljs-number cye-lm-tag">1</span>, IPC_RMID) == -<span class="hljs-number cye-lm-tag">1</span>)
{
    perror(“semctl failure <span class="hljs-keyword cye-lm-tag">while</span> clearing reason”);
}
<span class="hljs-keyword cye-lm-tag">return</span>(<span class="hljs-number cye-lm-tag">0</span>);
}</code></pre>

<h1 id="信号量的牛刀小试生产者与消费者问题">信号量的牛刀小试——生产者与消费者问题</h1>

<hr />

<p class="cye-lm-tag">1．问题描述： <br />
有一个长度为N的缓冲池为生产者和消费者所共有，只要缓冲池未满，生产者便可将 <br />
消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。生产者往缓冲池 <br />
放信息的时候，消费者不可操作缓冲池，反之亦然。</p>

<p class="cye-lm-tag">2．使用多线程和信号量解决该经典问题的互斥</p>

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>


<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>

<span class="hljs-preprocessor">#define BUFF_SIZE 10</span>

<span class="hljs-keyword">char</span> buffer[BUFF_SIZE];
<span class="hljs-keyword">char</span> count;                         <span class="hljs-comment">//  缓冲池里的信息数目</span>
sem_t sem_mutex;                    <span class="hljs-comment">//  生产者和消费者的互斥锁</span>
sem_t p_sem_mutex;                  <span class="hljs-comment">//  空的时候，对消费者不可进</span>
sem_t c_sem_mutex;                  <span class="hljs-comment">//  满的时候，对生产者不可进</span>

<span class="hljs-keyword">void</span> * Producer()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        sem_wait(&amp;p_sem_mutex);     <span class="hljs-comment">//  当缓冲池未满时</span>
        sem_wait(&amp;sem_mutex);       <span class="hljs-comment">//  等待缓冲池空闲</span>

        count++;

        sem_post(&amp;sem_mutex);

        <span class="hljs-keyword">if</span>(count &lt; BUFF_SIZE)       <span class="hljs-comment">//  缓冲池未满</span>
        {
            sem_post(&amp;p_sem_mutex);
        }

        <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)               <span class="hljs-comment">//  缓冲池不为空</span>
        {
            sem_post(&amp;c_sem_mutex);
        }
    }
}

<span class="hljs-keyword">void</span> * Consumer()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        sem_wait(&amp;c_sem_mutex); <span class="hljs-comment">//  缓冲池未空时</span>
        sem_wait(&amp;sem_mutex);   <span class="hljs-comment">//  等待缓冲池空闲</span>

        count--;
        sem_post(&amp;sem_mutex);

        <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)
        {
            sem_post(&amp;c_sem_mutex);
        }
    }

    <span class="hljs-keyword">return</span> NULL;
}



<span class="hljs-keyword">int</span> main()
{
    pthread_t ptid,ctid;

    <span class="hljs-comment">//  initialize the semaphores</span>
    <span class="hljs-comment">//sem_init(&amp;empty_sem_mutex, 0, 1);</span>
    <span class="hljs-comment">//sem_init(&amp;full_sem_mutex, 0, `0);</span>

    <span class="hljs-comment">//creating producer and consumer threads</span>
    <span class="hljs-keyword">if</span>(pthread_create(&amp;ptid, NULL,Producer, NULL))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n ERROR creating thread 1"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(pthread_create(&amp;ctid, NULL,Consumer, NULL))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n ERROR creating thread 2"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(pthread_join(ptid, NULL)) <span class="hljs-comment">/* wait for the producer to finish */</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n ERROR joining thread"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(pthread_join(ctid, NULL)) <span class="hljs-comment">/* wait for consumer to finish */</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n ERROR joining thread"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">//sem_destroy(&amp;empty_sem_mutex);</span>
    <span class="hljs-comment">//sem_destroy(&amp;full_sem_mutex);</span>
    <span class="hljs-comment">//exit the main thread</span>
    pthread_exit(NULL);

    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}
</code></pre></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
