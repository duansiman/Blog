
<h1><span style="font-size:24px;"><strong>      <span style="font-family:Comic Sans MS;">9.typedef</span></strong></span></h1><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    内核开发者们强烈反对使用 typedef 语句。他们的理由是：</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    1&gt; typedef 掩盖了数据的真实类型</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    2&gt; 由于数据类型隐藏起来了，所以很容易因此而犯错误，比如以传值的方式向栈中推入结构</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    4&gt; 使用 typedef 往往是因为想要偷懒，例如，可能会定义一个这样的形式：</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">  typedef unsigned char uchar</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    无论如何，尽量少用 typedef。</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    当然，typedef 也有它施展身手的时候：当需要隐藏变量与体系结构相关的实现细节的时候，当某种类型将来有可能发生变化，而现有程序必须要考虑到向前兼容问题的时候，都需要 typedef 。</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"><br /></span></strong></span></p><h1><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    10.多用现成的东西</span></strong></span></h1><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    请勿闭门造车。内核本身就提供了字符串操作函数，压缩函数和一个链表接口，所以，直接使用它们就行了，而不要自己再去创造，毕竟，你要知道，你自己定义的接口会比现成的东西差好多。</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"><br /></span></strong></span></p><h1><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    11.在源码中减少使用 ifdef</span></strong></span></h1><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    我们不赞成在源码中使用 ifdef 预处理指令。你绝不应该在自己的函数中使用如下的实现方法：</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"><span style="white-space:pre"></span></span></strong></span></p><pre name="code" class="cpp">#ifdef CONFIG_FOO
	foo();
#endif</pre> <span style="white-space: pre;">   <span style="font-family:Comic Sans MS;font-size:24px;"><strong>相反，应该采取的方法时在 CONFIG_FOO 没定义的时候让 foo 函数为空。</strong></span></span><p></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"></span></strong></span></p><pre name="code" class="cpp">#ifdef CONFIG_FOO
static int foo(void)
{
	/**/
}
#else
static inline int foo(void) {}
#endif  /*CONFIG_FOO*/</pre>    <span style="font-family:Comic Sans MS;font-size:24px;"><strong>这样，你在任何情况下都能调用 foo() 了。</strong></span><p></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"><br /></span></strong></span></p><h1><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    12.结构初始化</span></strong></span></h1><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;">    结构初始化的时候必须在它的成员前加上结构标识符。这种初始化能避免错误使用其他结构而引发一个初始化错误。它支持使用忽略值。内核代码必须使用新的 C99 标识符格式，就像是下面这样：</span></strong></span></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"></span></strong></span></p><pre name="code" class="cpp">struct foo my_foo = {
	.a = INTIAL_A,
	.b = INTIAL_B,
};</pre>   <span style="font-family:Comic Sans MS;font-size:24px;"><strong> 其中 a 和 b 都是结构体 foo 的成员，而 INTIAL_A 和 INTIAL_B 是它们对应的初始值。如果一个字段没有给定初始值，那么它就会设置为 ANSI C 规定的默认值（指针被设为 NULL，整形被设为 0，浮点数被设置为 0.0）。举例来说，如果 foo 结构体还有一个 int 型的 c 成员，那么上面的初始化语句执行之后 c 会被设置为 0.</strong></span><p></p><p><span style="font-size:24px;"><strong><span style="font-family:Comic Sans MS;"><br />  </span></strong></span></p>   &#13;
