
<p><span style="font-size:24px;"><strong>      <span style="font-family:KaiTi_GB2312;">在内核里分配内存可不像在其他地方分配内存那么容易。造成这种局面的因素很多。从根本上讲，是因为内核本身不能像用户空间那样奢侈的使用内存。内核与用户空间不同，它不具备这种能力，它不支持简单便捷的内存分配方式。比如，内核一般不能睡眠。此外，处理内存分配错误对于内核来说也绝非是一件简单的事。正式由于这些限制，再加上内存分配机制不能太复杂，所以在内核中获取内存要比在用户空间复杂的多。</span></strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>      首先，我们讨论下内核中的分页机制。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>      内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常是字，但是，内存管理单元通常以页为单位进行处理。从虚拟内存的角度看，页就是最小的基本单位。所以，在内核看来，物理内存就像下面这样：</strong></span></p><p style="text-align: center;"><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong><img src="http://img.blog.csdn.net/20130822144045546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>     注意：基本上内核的分页都是固定大小的页。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong><br /></strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>     内核用 struct page 结构表示系统中的每个物理页，这个结构就好像下面这样：</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    <span style="color:#993399;">  </span><span style="color:#000099;">struct page</span></strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>      {</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>      <span style="white-space:pre">	</span>unsigned long flags;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        atomic_t      _count;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        atomic_t      _mapcount;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        unsigned long private;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        struct address_space  *mapping;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        pgoff_t       index;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        struct list_head lru;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>        void          *virtual;</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;color:#000099;"><strong>      }</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong><span style="color:#000099;">      </span>下面，我们来解释下其中的重要字段。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    flags：这个字段用于存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。 flag 的每一位单独表示一种状态，所以，它至少可以同时表示出32种不同的状态。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    _count：这个字段存放页的使用计数，也就是这个页被引用了多少次。很奇怪，技术值变为 -1 时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它，注意，这个字段使用的是 -1 代表未使用，而不是 0 。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    virtual：这个字段是页的虚拟地址。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    mapping：这个域指向和这个页关联的 address_space 对象。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong>    private：这个根据名字就可以看得出，它指向私有数据。</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:24px;"><strong><br /></strong></span></p>   &#13;
