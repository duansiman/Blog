
<h2>服务与进程</h2><p><span style="white-space:pre">	</span>进程是满足用户需求的一系列任务，有的为了提供一个交互的界面，有的为了提供一个后台的演算，有的为了提供一个网络服务，有的为了利用磁盘资源做存储。归根到底，进程就是需求的承载体。PC本身就是通用化的设备，自然所有的PC系统都要满足各种各样的需求，因此提供一个直观的进程模型就是各种服务实现的基础。</p><p><span style="white-space:pre">	</span>在种类上，对用户来说可能千奇百怪，有的服务于医疗，有的服务于电影娱乐，有的服务于游戏。这些程序在用户看来是按行业区分的，但是在操作系统看来，所有这些进程都是对操作系统所管理的硬件资源的请求。有的需要显示器，有的需要磁盘，有的需要CPU，有的需要网络。所以，在用户看来是一个个不同种类的服务，但是在操作系统看来，是侧重于不同种类资源请求的进程。</p><h2>资源与进程</h2><p><span style="white-space:pre">	</span>大体分为：磁盘IO密集型、网络IO密集型、内存密集型、CPU密集型和显卡密集型。这五种也基本是PC所能提供的5个主要的资源。PC资源就和世界一样，资源永远是有限的，关键就是找到合理分配资源的方式。世界是不公平的，PC也不可能做到公平。但是世界由多个国家组成，资源的分配是一个博弈的过程，而PC可以只有一个主控系统，所以可以更加合理充分的利用资源。</p><p><span style="white-space:pre">	</span>PC有个特点，无论是哪种服务，都需要有CPU参与，而对其他资源的依赖很多都是非独占的，例如可以好几个进程一起使用内存，一起使用网络和显卡等。但是除非你有多个CPU，你永远无法同时让一个CPU为多个进程服务。即使你有了多个，也不会比进程多。所以CPU的时分复用就很重要，其他资源由于其并行性，其资源管理器都提供的是申请服务模型的服务，而只有CPU的资源管理器才是主动发起调度的那个。所以，必须要理解的，我们常说的进程调度都是调度CPU，也正是因为只有CPU才最需要调度。但是随着各个服务的复杂化，对于IO或者显卡的请求也都呈现无法充分并行的情况，而对于CPU也越来越具有并行能力。所以未来的调度程序也不一定只会以CPU的时间片作为调度单元。真正的真理是：永远以瓶颈资源作为调度的核心。可能有那么一天，CPU不是问题（现在有24核的服务器，一般人根本不会有CPU瓶颈），但是最大的瓶颈在网络，在于各个进程都同时对有限的网络带宽提出需求。这个时候，CPU可能就会被作为服务的提供方，网络带宽的调度程序变成了进程调度的核心话题了。</p><h3>公平问题</h3><div><span style="white-space:pre">	</span>绝对的公平是不存在的。社会上人与人之间能获得的社会资源和自然资源也是不一样的。进程也是如此，所以所有的进程调度算法都会有优先级的划分。我们都知道现在的大部分进程调度算法都是划分CPU的时间片，但是以前的unix划分绝对的时间片的方法已经被linux淘汰掉了，linux改用的是基于比例的划分模型，而不是基于绝对时间片。这有个很有意思的区别，就是如果是绝对时间不同优先级的进程获得10ms和5ms虽然都查了一个时间片（假设一个是5ms），但90和85ms的也只是查了一个时间片。但是这在应用程序的表现上就有极大的区别，因为前者是两倍的差距，后者是微不足道。前者由于时间片本身就短，还得担负更多进程切换的开销，反而又短了。所以绝对时间是机器友好但不是用户友好的，可惜使用这个算法的是用户。</div><div><span style="white-space:pre">	</span>linux的做法是CFS，完全公平，用完全的公平来实现不公平。简单的说，就是根据目前有多少个进程，用总CPU资源一除就知道每个进程要占多久的时间片。如果要定义有高优先级的进程，就可以让它占有多份时间（多不一定是整数）。比起绝对时间的最大区别就是根据进程数目的比例时间。例如优先级是5和0的两个进程与优先级是10和15的两个进程在一个CPU上获得的时间片是一样的（如果只有这两个进程），因为使用差值和比例计算的（具体算法略过）。再学过cgroup就会发现，这种被叫做完全公平调度的算法是整个系统不公平调度的基础。</div><div><span style="white-space:pre">	</span></div><div><span style="white-space:pre">	</span></div>   &#13;
