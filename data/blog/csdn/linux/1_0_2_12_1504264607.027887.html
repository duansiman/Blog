
        <div class="markdown_views"><h2 id="linux内核工程导论网络tcp">Linux内核工程导论–网络：TCP</h2>



<h3 id="tcp存在原因">TCP存在原因</h3>

<p>       TCP希望达成数据按序的，无损失的传输。 <br />
       只要有TCP这个协议的需求，就有其带来的问题。其问题是，既然要保证按序到达和完全到达，如何保证？不但要保证，还要保证速度，又如何设计机制？最终TCP的设计者设计的机制是ARQ，就是发送好几个包，对方确认。确认的是流，而不是数据包，这倒也符合TCP设计的初衷。很多协议中使用的数据包确认机制，就是一个数据包等待一个确认的方法只适合低速的网络，如此高的通信代价，在现代网络中是不合时宜的。 <br />
       为实现ARQ的目的，就需要设计一种机制使其能够任何应答确认数据流的某个位置，而不是某个包。这个机制就是sequence编号。TCP本质上是半双工的，也就是说数据通信在发送时就不能接收，接收到了才开始发送，或者是发送了后进入接收状态等待接收。既然通信的双方都可以发送数据包，所以两方各有一个sequence。这个sequence的意义是标示当前发送的数据包的序号。同时每个TCP回复，还有对对方sequence的确认，告诉对方我目前收到的是哪个位置的数据。 <br />
       双方通过把自己的接收情况和发送情况尽可能早的告诉对方，好让对方可以适时的调整发送频率。 <br />
        这样又产生了一个问题：正常情况下机制会很好的工作。一旦一方发现对方收到的最新的sequence号是自己很早就发送出去的呢？一旦一方发现自己好久没有收到来自对方的包呢？第一个问题的原因可能是自己发送到对方的网络阻塞，第二个问题的可能原因是对方没发或者是对方发来的网络也是拥塞的，数据包被路由器大量的丢掉了。</p>

<h3 id="tcp连接状态">TCP连接状态</h3>



<h4 id="连接的建立与关闭">连接的建立与关闭</h4>

<p>       TCP是面向连接的，这个面向连接不是为了面向连接而面向的，毕竟说自己是面向连接就需要额外的成本去维护连接。连接是数据可靠传输的副作用。要实现数据的可靠传输，通信的两端就需要建立信道，才可以在信道上进行数据控制并且区别于其他信道（这里的信道是逻辑上的通信链路）。 <br />
       既然连接是无可奈何的产物。那么就涉及到如何建立连接、关闭连接和存储连接信息（典型的是连接的列表和状态）。 <br />
连接建立 <br />
       这就是著名的3次握手。为何要3次？连接要让双方都确保建立。TCP认为确保的方式两方都既能成功发送又能成功接收。client发起TCP连接（SYNC），等待返回sync,ACK。如果接收到，对于client来说，其发送的数据包成功，并且也能成功接收。对于server来说，由于通常数据都是首先由client发送，当其收到第一个sync时，它已经知道自己可以成功的接收了，它还要验证能否成功发送，并且让client知道自己可以接收，此时其回复sync，ack。对于server来说，此时还不可以确定自己能够成功的发送数据包。因此，client会回复ack，当server收到后，就确认了自己既能发送又能接收了。链路是通的，就可以建立。这就组成了3次握手。 <br />
       其实，本质上，3次握手是确保对于双方来说收发链路都是通的，而大部分情况下理论上两次握手足够。因为client完全可以确定自己收发都可以，server可以确定自己接收可以。而数据又是从client首先发送，所以server完全可以等到收到client的数据再确认连接的成功建立。这样也就省去了第3个数据包。 <br />
       还可以通过其他的连接来标记一条链路可用，从而就可以直接对链路添加信任，就不需要经过握手。但是也得考虑IP可达并不代表端口可达。但是毕竟是有优化空间的。我们该知道的是，TCP是为广域网设计的，其基础是对通信链路的不信任。随着网络质量的提高，这种算法确有改进的空间。但是由于其优秀的设计，让其生命力非常顽强。TCP的设计是选择出来的，是在实际的环境中形成的最优解，除非实际的环境发生了巨大的变化，否则TCP的地位不会被动摇。 <br />
连接释放 <br />
       建立需要3个，断开却需要4个数据包的交互。因为建立时发起者永远是client，而断开时可能是任何一方断开。对于TCP来说无法预先知道是哪一方要发起关闭，而也不知道此时另一方需要多久才能响应这个关闭。建立时如果太久，你可以建立不成功。但是关闭时，必须要通知到对方要关闭TCP连接，删除对应的socket，而发起方很可能是正在被关闭的进程，在发起了FIN后，其进程实体将会被关闭，再不会触发一次关闭操作。接收方也很可能没有正常的回收资源。作为一种负责任的算法，在设计上必须要保证双方都能够回收各自的资源，而又不能依赖于不可靠的网络和用户操作。 <br />
       双方都为该TCP连接分配了类似的资源（socket），所以在设计上，TCP的关闭是单向的。意思是，无论你是否关闭，我要关了。这很正常，你一个远端的机器，不可以阻止我回收属于我的资源。另一端也是同样。但是起码的FIN要确保发到了对方的操作系统才算负责任（你回不回收是你的事，但是我通知到了）。因此设计成任何一方发起FIN，对方都要回复ack。 <br />
       当接收方收到FIN，并且回复ack后，其就可以决定自己是否要回收自己的资源了。因为对面已经关闭了，这个socket的存在只是占用资源，已经没有通信价值了。如果决定了要回收，其就会发送FIN，等待对面的ack。</p>



<h4 id="连接信息">连接信息</h4>

<p>       我们知道socket就代表一个通信中的逻辑实体。TCP虽然只是socket的一种实作，但是socket也是代表TCP连接端点的资源，而且网络中TCP socket的数目又远远多于其他。所以TCP连接的状态直接编码到socket状态就是最优的选择。 <br />
         而由于通信是双向的，你不可以通过一个数据包告诉对方将自己的状态设为1就指望对方也能跟着设为1，你必须要确认，因为根源在于网络是不可靠的。连接的建立、关闭和拥塞控制都是以这个为基础设计的。没有这个前提，所有的机制都是没有任何价值的。 <br />
         正是通信状态的不可靠，导致了双方都要为socket定义状态。 <br />
         <img src="http://d.hiphotos.baidu.com/zhidao/pic/item/4e4a20a4462309f7eb8859f0720e0cf3d6cad669.jpg" alt="这里写图片描述" title="" /></p>

<pre><code>                        画图：socket状态变迁图
</code></pre>

<p>       这些状态之间的迁移都是因为事件，事件有用户主动发起的，有收到数据包自动触发的。例如3次握手，对于client来说发送了sync，自己的socket就处于SYNC_SENT状态，收到了server的sync,ack回复，会立即扔出去一个ack包，然后进入ESTABLISHED状态。 <br />
       最复杂的应该是关闭。因为涉及到双方4次交互，就有4个状态。发起方发送了FIN之后进入FIN_WAIT_1，收到ack后进入FIN_WAIT_2。此时发起方的资源已经标记回收，但是之所还存在就是在等待对方也回收（TCP是有责任心的协议）。收到FIN的一方迅速扔出一个ACK然后将自己进入CLOSE_WAIT状态。应用程序检测到socket进入了CLOSE_WAIT状态后，需要手动调用close，该socket就可以发送FIN并进入LAST_ACK状态，收到ack后socket销毁。 <br />
       状态图中考虑了一些特殊情况。当发起方发送FIN却同时收到了FIN，发送方发送了FIN却收到了SYNC，连同其正常情况下等待的sync，ack，共3种可能的情况。无论其怎么处理，处理完后socket都要等待TIME_WAIT时间才销毁（CLOSED）。 <br />
       在实际的使用中，你可能会发现处于TIME_WAIT状态的socket特别多，也可能发现处于SYN_RCVD状态的socket特别多。这些都可能是攻击，也可能是正常的现象。如果是攻击，这种攻击的作用对象是协议本身，而不是代码的实现。这种漏洞就是协议本身的漏洞，也就是说无论你怎么实现这个协议，这个漏洞永远存在，你避不开，你能检测和预防。例如TIME_WAIT要求主动发起关闭的socket要等待一段时间再销毁，目的是让网络中属于该socket的数据都传送干净，防止出现重复。而如果频繁发起短连接，迅速打开迅速关闭，则必然导致处于TIME_WAIY状态的socket迅速增多。这是无法避免的，即使要阻止，通常就违反协议，也就注定了不是内核来做这件事，只能由用户来选择是否违反协议，内核最多提供机制。</p></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
