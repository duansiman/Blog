
<div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong>Unix/Linux的接口设计有一句通用的格言“提供机制而不是策略”。区别对待机制（mechanism）和策略（policy）是Unix设计中的一大亮点。<span style="color: rgb(204, 51, 51); word-wrap: break-word;">大部分的编程问题都可以被切割成两个部分：“需要提供什么功能”（机制）和“怎样实现这些功能”（策略）。如果由程序中的独立部分分别负责机制和策略的实现，那么开发软件就更容易，也更容易适应不同的需求。</span></strong></span></span></div><div style="word-wrap: break-word; color: rgb(102, 102, 102); font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="word-wrap: break-word;"></span> </strong></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong>开源-展现在我们面前的是数以千计的代码，在那一行行的代码背后，到底蕴藏着怎样的设计思想，高手们曾怎样苦思冥想。在一堆堆的代码面前，有时候，我们很容易迷失曾经进来的入口，而掉入符号，变量以及函数堆积成的沼泽地。</strong></span></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="word-wrap: break-word;"></span> </strong></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong>操作系统的本质是什么？管理者？亦或服务者？但，归根结底，它是一个执行者：执行用户程序-所谓为用户服务；执行中断-所谓为外设服务；执行系统调用-所谓解放程序员（姑且说它为广大的程序员服务，因为程序员不再与繁杂的硬件打交道了）；执行内核线程-为操作系统自身服务。</strong></span><span style="color: rgb(102, 102, 102); font-size: 14px; word-wrap: break-word;"><span style="font-size:24px;color:#ff0000;word-wrap: break-word;"><strong>而这所有执行的核心，无非是在恰当的时机，让哪个对象（程序，线程，中断服务程序，中断的下半部，系统调用）占有CPU。</strong></span></span><span style="font-size:18px;"><strong>换句话说，Unix/Linux抽象出对这些对象的执行机制:</strong></span></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong><span style="color: rgb(0, 0, 255); word-wrap: break-word;">程序的执行机制-进程<br style="word-wrap: break-word;" />内核函数的执行机制-线程<br style="word-wrap: break-word;" />中断服务程序的执行机制-中断信号触发<br style="word-wrap: break-word;" />中断下半部的执行机制-softirq，tasklet，工作队列<br style="word-wrap: break-word;" />系统调用的执行-软中断（int $0x80触发）</span><br style="word-wrap: break-word;" /><span style="color:#666666;">  </span><br style="word-wrap: break-word;" />从机制和策略的角度看问题，也许，你对曾经困惑的问题有赫然开朗之感。</strong></span></span></div><div style="word-wrap: break-word; color: rgb(102, 102, 102); font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="word-wrap: break-word;"></span> </strong></span></div><div style="word-wrap: break-word; color: rgb(102, 102, 102); font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255); word-wrap: break-word;"><span style="font-size:18px;"><strong>如果说机制是一种框架，那么，策略就是填充框架的一个个具体实体。机制提供的是一种开放而宽松的环境，而策略就是在这个环境下赖以生存的生命个体。比如，我们编写的一个程序，fork()以后，就成为一个个进程的生命个体。而操作系统所提供给我们创建、执行以及结束进程的各种原语-fork(),exex()和exit（）等是统管各种进程的机制。我们所创建进程的死活并不会影响机制本身。</strong></span></span></div><div style="word-wrap: break-word; color: rgb(102, 102, 102); font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="word-wrap: break-word;"></span> </strong></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong>如此看来，也许我们对原理之困惑有所醒悟。我们任何人在任何时候都可以调用fork()创建N多进程。这样一个简单的fork（）壳，想追根溯源者，剥开这个壳，可以看到其五脏六腑。<span style="color: rgb(255, 0, 0); word-wrap: break-word;">fork()如果出现任何一个小bug，直接影响到我们任何人和任何进程。</span></strong></span></span></div><div style="word-wrap: break-word; color: rgb(102, 102, 102); font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="word-wrap: break-word;"></span> </strong></span></div><div style="word-wrap: break-word; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="font-size:18px;"><strong>如此看来，也许我们对开发者所承担的角色有所感悟。系统分析员和设计人员，任重而探究的路漫漫兮。说到此，设计模式等系列书，对有志于从编码走向设计的开发者或许有所启发。</strong></span></span></div>   &#13;
