
<p><span style="font-size:24px;"><strong>      用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统的安全性和稳定性将不复存在。</strong></span></p><p><span style="font-size:24px;"><strong>      所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。</strong></span></p><p><span style="font-size:24px;"><strong>      通知内核的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。在X86系统上预定义的软中断是中断号128，通过 int $%0x80 指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序，而该程序正是系统调用处理程序。这个异常处理程序名字起得很贴切，叫 system_call() .它与硬件体系结构密切相关。</strong></span></p><p><span style="font-size:24px;"><strong>      不管系统调用处理程序被如何调用，用户空间引起异常或陷入内核就是一个重要的概念。</strong></span></p><p><span style="font-size:24px;"><strong>      下面我们以 read()系统调用说明陷入内核的过程，如图所示：</strong></span></p><p style="text-align: center;"><span style="font-size:24px;"><strong><img src="http://img.blog.csdn.net/20130807185252828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></strong></span></p><p><span style="font-size:24px;"><strong>      我们可以看到，在用户空间使用 read函数，接着在C库中进行封装，接下来就触发异常，陷入内核，首先调用的是 system_call 函数，在该函数中进行非常重要的任务，如参数检查合法性，权限合法性检查等，最后，通过了检查之后，正式调用 sys_read() ，这就是 read 在内核中的实现。</strong></span></p><p><span style="font-size:24px;"><strong>      由于Linux内核中系统调用的过程都是相似的，所以，执行过程类似于 read 系统函数的调用。</strong></span></p>   &#13;
