
<p> </p><h2>内核概览</h2><p>linux内核并不是唯一的内核，也并不是唯一的一种内核。实际上linux内核属于Monolithic kernel的一个实现，这种内核还包括Unix系列（BSD、SunOS等），dos和windows 9x系列，还有OpenVMS，XTS-400，z/TPF等一些不常见的系统内核。</p><p><img src="http://img.blog.csdn.net/20160317132023409?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p></p><p>         内核的种类包括：exokernels,nanokernels ，microkernels, hybrid kernels，Monolithic kernels，anykernel六种。windows NT（9x之后的所有）都属于hybridkernels，因为他系统功能的一部分在内核中，一部分在用户空间中。</p><p>         那本内核本该提供什么样的系统功能呢？最核心的只有一个：资源管理。资源管理大致分为三种：CPU资管调度，内存管理，IO设备管理。</p><h2>内核形成过程</h2><p>         试想我们在一个裸板上从头写一个操作系统要经过什么步骤。第一步，我们肯定要把汇编的启动代码封装一下，然后写一些启动的C代码，内存需要汇编来初始化，才能向其中加载内容。</p><p>加载之后，我们可以在内存中执行代码了，但是此时内存中是无章法的一大片连续块而已。我们要使用c语言就必须为内存划分块（全局区，代码区等），我们可以让gcc去完成这个工作，通常要手动布局一下。当涉及到堆，涉及到很大的内存的时候，就需要考虑内存分配算法和页的划分了，有了页的划分就得有缺页中断的实现了。这部分就实现了内存管理。</p><p>然后我们需要初始化和使用外部的设备，由于外部的设备都是寄存器控制的，寄存器通常是功能复用的，通过写入功能号来执行功能，通过查看一些寄存器的位来确定状态（李如意pci这种总线硬件更复杂）。所以就需要封装。这样一封装就形成了硬件抽象层，如果同样是鼠标，有不同的商家的寄存器排列不同，那么我们就得针对每一种鼠标实现一个驱动，然后驱动的上层接口与硬件抽象层相符。于是驱动和硬件抽象层的概念产生了。</p><p>实现如果到此为止，只实现了基本的硬件管理和硬件抽象层，nanokernel就产生了。</p><p>我们知道一个操作系统可以多进程，进程间还要通信，各个进程之间还要调度。内核里实现看了进程概念这一步，就是microkernel。</p><p>再实现一些文件系统、网络协议栈等就是Monolithickernel了，如果再用户端也实现了一些系统级功能，就是hybrid kernels了。</p><h2>exokernels和anykernel</h2><p>         exokernels是最微小的内核，其功能仅限于限制对资源访问进行复用和保护。对硬件做最基本的抽象，允许应用无限权限的访问硬件。也就是说exokernel只是为应用提供一种最小化的硬件抽象。怎么使用是使用者说了算，亚久压根不知道进程这种概念了。</p><p>         netBSD实现了第一个anykernel(rumpkernel)。anykernel本身即是内核又是程序。作为程序他向基于他的其他程序提供内核的功能。作为内核，因为他本身就包含内核的功能。也就是说anykernel是在任何操作系统上可移植的。例如linux上可以使用rump kernel的tcp/ip协议栈，下层直接用dpdk，上层的应用调用rump kernel就可以完成socket协议栈操作。这本质是一种虚拟化方式，与其他的虚拟化不同的是，其他的虚拟化虚拟的是硬件，希望运行不同的软件，而anykernel的思路虚拟的是软件，可以运行在不同的操作系统上。rump kernel的实现包含了文件系统、协议栈和设备管理。配合XEN使用的话，就可以做到</p>   &#13;
