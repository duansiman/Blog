
<p><span style="font-size:24px;"><strong>     上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在kernel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。它完成了两相基本工作：</strong></span></p><p><span style="font-size:24px;"><strong>      1.调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新的进程中去，其实就是切换到另一个进程的地址空间中，请看下图示例：</strong></span></p><p style="text-align: center;"><span style="font-size:24px;"><strong><img src="http://img.blog.csdn.net/20130819100202078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></strong></span></p><p><span style="font-size:24px;"><strong>      2.调用声明在&lt;asm/system.h&gt;中的switch_to()，该函数负责从上一个处理器状态切换到新进程的处理器状态。这包括保存，恢复栈信息和寄存器信息，还有其他和体系结构有关的状态信息，都必须以每个进程为对象进行管理和保存。请看如下示例：</strong></span></p><p style="text-align: center;"><span style="font-size:24px;"><strong><img src="http://img.blog.csdn.net/20130819100406453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></strong></span></p><p><span style="font-size:24px;"><strong>      </strong></span></p><p><span style="font-size:24px;"><strong>      下面我们看下进程抢占的时机。</strong></span></p><p><span style="font-size:24px;"><strong>1.<span style="color:#ff0000;">用户抢占</span></strong></span></p><p><span style="font-size:24px;"><strong>      从系统调用返回用户空间时</strong></span></p><p><span style="font-size:24px;"><strong>      从中断处理程序返回用户空间时</strong></span></p><p><span style="font-size:24px;"><strong>2.<span style="color:#ff0000;">内核抢占</span></strong></span></p><p><span style="font-size:24px;"><strong>      中断处理程序正在执行，且返回内核空间之前</strong></span></p><p><span style="font-size:24px;"><strong>      内核代码再一次具有可抢占性的时候</strong></span></p><p><span style="font-size:24px;"><strong>      如果内核中的任务显示的调用schedule()</strong></span></p><p><span style="font-size:24px;"><strong>      如果内核中的任务阻塞（这同样会导致调用schedule()）</strong></span></p>   &#13;
