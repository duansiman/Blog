
<p><span style="font-size:24px;"><strong>      还记得一个进程创建的时候是什么给它分配的“进程描述符”吗？没错，是slab分配器，那么，这个slab分配器是个什么东西呢？</strong></span></p><p><span style="font-size:24px;"><strong>      分配和释放数据结构是所有内核中最普遍的操作之一。为了便于结构的频繁分配和回收，编程人员常常会用到空闲链表。空闲链表中包含可供使用的，已经分配好的数据结构块。当代码需要一个新的数据结构实例时，就可以从空闲链表中抓取一个，而不需要再去执行一些分配内存的代码，这样不仅高效而且使用简单。以后，当不需要这个数据结构时，我们不能简单的释放这块内存，而是需要把它放回空闲链表中，毕竟，下次使用的时候我们还要使用呢。</strong></span></p><p><span style="font-size:24px;"><strong>      在内核中，空闲链表面对的一个主要问题就是不能全局控制。当可用内存变得紧缺时，内核无法通知每个空闲链表，让其收缩缓存的大小以便释放出一些内存来。实际上，内核根本不知道存在任何空闲链表。为了解决这个问题，Linux内核引入了slab层的概念。slab分配器扮演了通用数据结构缓存层的角色。</strong></span></p><p><span style="font-size:24px;"><strong>      slab层把不同的对象划分为高速缓存，其中每个高速缓存组中存放的都是不同类型的数据结构对象。例如，一个高速缓存用于存放进程描述符，另一个高速缓存用于存放i节点。</strong></span></p><p><span style="font-size:24px;"><strong>      之后，这些高速缓存又被划分为slab。slab由一个或多个物理上连续的页组成。一般情况下，slab也就仅仅一页。每个高速缓存可以由多个slab组成，下图显示的就是高速缓存，slab，数据结构对象三者的关系：、</strong></span></p><p style="text-align: center;"><span style="font-size:24px;"><strong><img src="http://img.blog.csdn.net/20130812161647734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></strong></span></p><p><span style="font-size:24px;"><strong>      每个slab都包含一些数据成员，这里的成员指的是缓存的数据结构。每个slab处于三种状态之一：满，部分满或空。</strong></span></p><p><span style="font-size:24px;"><strong>      当内核的某一部分需要一个对象时，就要由slab分配了，首先考虑的是部分满的slab，如果不存在部分满的slab则去空的slab分配，如果也不存在空的slab，则内核需要申请页重新分配高速缓存。</strong></span></p><p><span style="font-size:24px;"><strong>      slab层的管理是在每个高速缓存的基础上的，通过给整个内核一个简单的接口来完成的。通过接口就可以创建和撤销高速缓存，并在高速缓存内分配和释放对象。高速缓存及其slab的复杂管理完全通过slab层的内部机制来处理。当你创建了一个高速缓存之后，slab层所起的作用就像一个专用的分配器，可以为具体的对象类型进行分配。</strong></span></p>   &#13;
