

<h1>Linux内核通用技术</h1>&#13;
<h4>linux内核技巧与手段</h4>&#13;
<h5>linux内核上下层通信方式</h5>&#13;
<p>         定义一个接口体，包含各种函数指针，并且管理其列表。下层通过生成一个这样的结构体，将自己的操作函数赋值给该结构体的对应域，然后调用上层的注册函数，将自己的信息注册到上层。如此，上层就可以用统一的函数调用不同的下层接口。上层可以遍历，或通过名字，或设置哪个有效来确定调用哪个下层结构体对应的同名操作。</p>&#13;
<p>         当上层调用一个下层的函数时，一般有3种返回值的方式，一种是通过语言规定的函数返回值，一种是传递的参数是函数外的指针，最后一种在内核中有广泛用处的是使用回调函数。也就是执行完一个函数并不是返回结果，而是调用某个函数返回结果。而这个函数通常是调用者提供的。</p>&#13;
<h5>资源竞争处理</h5>&#13;
<p>         队列缓存。例如将bio提交给设备。当其发现设备忙，就将该请求加入队列，然后返回。如果不忙就直接提交。这里很容易理解，但是其实现方式比较有趣，其利用对象的队列指针。如果队列指针为空，则说明设备不忙。而设备如果忙，该指针不为空。</p>&#13;
<h5>linux内核的结构体</h5>&#13;
<p>         linux的结构体之间可以有继承关系，但是不像是C++那种显式的继承，而是子结构体包含了父接口体的指针，通过父结构体可以找到子结构体，通过子结构体也可以找到父结构体。而子结构体可以继承多个父结构体。</p>&#13;
<p>         总体来说linux有两种结构体，一种是对对象的建模，另一种是对操作的建模。两个体系互相有交叉关系，但是两个体系各有各的继承结构。</p>&#13;
<p>         linux很多重要对象的结构体中的域都是为各个层次各个功能使用的。他们在写代码的时候需要改结构体提供某个域就会在其中添加，最后导致的结果是如果你单看结构体，会感觉时空错乱的莫名其妙。所以看linux的结构体必须要对应功能，而功能的跨度通常很大，所以看这种代码学习曲线很高，必须要全面的理解内核后才能看懂部分，而全面的理解又需要看懂部分来支撑，所以就需要迭代渐进的阅读和学习。</p>&#13;
<h1>横向系统</h1>&#13;
<p>         横向系统是指那些不是具体的物理功能，而是各个功能模块都需要对外展示的接口。例如cgroup、proc、sys文件系统。还有一部分是内核的基础元素功能，例如workqueue，tasklet等。</p>&#13;
<h1>纵向系统</h1>&#13;
<h4>纵览</h4>&#13;
<p>         一个用户端普通的操作USB文件的操作要走完内核中的各个层次，他们是：文件系统层、缓存层、通用块层、SCSI层、USB层。这里的每个层次又内部自分为多个层次，linux内核的习惯一般是分为3个。为上层提供统一接口的接口层，中间实现主要逻辑的功能层，适应下层统一接口但不同下层的驱动层。例如USB设备有很多，scsi设备也有很多，下层就有很多个驱动要实现，但他们提供给中层的API应该是统一的。</p>&#13;
<p>         文件系统层解释文件在磁盘中存储的物理布局，缓存层实现读写请求在内存中的存放方式（预读，延迟写等）。通用块层处理上层多个请求的调度（例如合并，排序），SCSI层负责把上层命令的内容转变为设备可以识别的SCSI指令，USB层负责把指令成功的送达对应的设备。</p>&#13;
<p>         不同的层次，不同的分工，他们顺序完成工作。</p>&#13;
<h4>块设备核心服务</h4>&#13;
<p>device_create_vargs(struct class *class,struct device *parent, dev_t devt, void *drvdata, const char *fmt, va_listargs)：创建设备并且放在sysfs的对应目录下。</p>&#13;
   &#13;
