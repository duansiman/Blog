
<span style="font-size:18px;"><strong style="background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3. GDB的实现 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">GDB是GNU发布的一个强大的程序调试工具，用以调试C/C++程序。可以使程序员在程序运行的时候观察程序在内存/寄存器中的使用情况。它的实现也是基于ptrace系统调用来完成的。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">其原理是利用ptrace系统调用，在被调试程序和gdb之间建立跟踪关系。然后所有发送给被调试程序的信号(除SIGKILL)都会被gdb截 获，gdb根据截获的信号，查看被调试程序相应的内存地址，并控制被调试的程序继续运行。GDB常用的使用方法有断点设置和单步跟踪，接下来我们来分析一 下他们是如何实现的。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3.1 建立调试关系 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">用gdb调试程序，可以直接gdb ./test,也可以gdb &lt;pid&gt;(test的进程号)。这对应着使用ptrace建立跟踪关系的两种方式: </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">1)fork: 利用fork+execve执行被测试的程序，子进程在执行execve之前调用ptrace(PTRACE_TRACEME)，建立了与父进程(debugger)的跟踪关系。如我们在分析strace时所示意的程序。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">2)attach: debugger可以调用ptrace(PTRACE_ATTACH，pid,...)，建立自己与进程号为pid的进程间的跟踪关系。即利用 PTRACE_ATTACH，使自己变成被调试程序的父进程(用ps可以看到)。用attach建立起来的跟踪关系，可以调用ptrace (PTRACE_DETACH，pid,...)来解除。注意attach进程时的权限问题，如一个非root权限的进程是不能attach到一个 root进程上的。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3.2 断点原理 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">断点是大家在调试程序时常用的一个功能,如break linenumber，当执行到linenumber那一行的时候被调试程序会停止，等待debugger的进一步操作。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3.3 单步跟踪原理 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">单步跟踪就是指在调试程序的时候，让程序运行一条指令/语句后就停下。GDB中常用的命令有next, step, nexti, stepi。单步跟踪又常分为语句单步(next, step)和指令单步(如nexti, stepi)。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /></strong></span><p><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong>在linux上，指令单步可以通过ptrace来实现。调用ptrace(PTRACE_SINGLESTEP,pid,...)可以使被调试的进程在每执行完一条指令后就触发一个SIGTRAP信号，让GDB运行。下面来看一个例子: </strong></span></span></p><p><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;"></span></p><pre name="code" class="cpp" style="background-color: rgb(241, 245, 248); font-size: 14px;">child = fork(); 
    if(child == 0) { 
         execl("./HelloWorld", "HelloWorld", NULL); 
    } 
    else { 
ptrace(PTRACE_ATTACH,child,NULL,NULL); 
        while(1){ 
        wait(&amp;val); 
        if(WIFEXITED(val)) 
            break; 
        count++; 
        ptrace(PTRACE_SINGLESTEP,child,NULL,NULL); 
        } 
    printf("Total Instruction number= %d\n",count); 
    } </pre><br /><span style="font-size:18px;"><strong style="background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">这段程序比较简单，子进程调用execve执行HelloWorld,而父进程则先调用ptrace(PTRACE_ATTACH, pid,...)建立与子进程的跟踪关系。然后调用ptrace(PTRACE_SINGLESTEP, pid, ...)让子进程一步一停，以统计子进程一共执行了多少条指令(你会发现一个简单的HelloWorld实际上也执行了好几万条指令才完成)。当然你也完 全可以在这个时候查看EIP寄存器中存放的指令，或者某个变量的值，当然前提是你得知道这个变量在子进程内存镜像中的位置。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">指令单步可以依靠硬件完成，如x86架构处理器支持单步模式(通过设置EFLAGS寄存器的TF标志实现)，每执行一条指令，就会产生一次异常 (在Intel 80386以上的处理器上还提供了DRx调试寄存器以用于软件调试)。也可以通过软件完成，即在每条指令后面都插入一条断点指令，这样每执行一条指令都会 产生一次软中断。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">语句单步基于指令单步实现，即GDB算好每条语句所对应的指令，从什么地方开始到什么地方结束。然后在结束的地方插入断点，或者指令单步一步一步的走到结束点，再进行处理。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">当然gdb的实现远比今天我们所说的内容要复杂，它能让我们很容易的监测，修改被调试的进程，比如通过行号，函数名，变量名。而要真正实现这些， 一是需要在编译的时候提供足够的信息，如在gcc时加入-g选项，这样gcc会把一些程序信息放到生成的ELF文件中，包括函数符号表，行号，变量信息， 宏定义等，以便日后gdb调试，当然生成的文件也会大一些。二是需要我们对ELF文件格式，进程的内存镜像(布局)以及程序的指令码十分熟悉。这样才能保 证在正确的时机(断点发生？单步？)找到正确的内存地址(代码？数据？)并链接回正确的程序代码(这是哪个变量？程序第几行？)。感兴趣的同学可以找到相 应的代码仔细分析一下。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">小结: </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">ptrace可以实时监测和修改另一个进程的运行，它是如此的强大以至于曾经因为它在unix-like平台(如Linux, *BSD)上产生了各种漏洞。但换言之，只要我们能掌握它的使用，就能开发出很多以前在用户态下不可能实现的应用。当然这可能需要我们掌握编译，文件格 式，程序内存布局等相当多的底层知识。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">最后让我们来回顾一下ptrace的使用: </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">1)用PTRACE_ATTACH或者PTRACE_TRACEME 建立进程间的跟踪关系。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">2)PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR等读取子进程内存/寄存器中保留的值。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3)PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR等把值写入到被跟踪进程的内存/寄存器中。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">4)用PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP控制被跟踪进程以何种方式继续运行。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">5)PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">TIPS: </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">1. 进程状态TASK_TRACED用以表示当前进程因为被父进程跟踪而被系统停止。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">2. 如在子进程结束前，父进程结束，则trace关系解除。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">3. 利用attach建立起来的跟踪关系，虽然ps看到双方为父子关系，但在"子进程"中调用getppid()仍会返回原来的父进程id。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">4. 不能attach到自己不能跟踪的进程，如non-root进程跟踪root进程。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">5. 已经被trace的进程，不能再次被attach。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">6. 即使是用PTRACE_TRACEME建立起来的跟踪关系，也可以用DETACH的方式予以解除。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">7. 因为进入/退出系统调用都会触发一次SIGTRAP，所以通常的做法是在第一次(进入)的时候读取系统调用的参数，在第二次(退出)的时候读取系统调用的返回值。但注意execve是个例外。 </span><br style="line-height: 25px; color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif;" /><span style="color: rgb(0, 51, 102); font-family: Verdana, Arial, Helvetica, 宋体, sans-serif; line-height: 25px;">8. 程序调试时的断点由int 3设置完成，而单步跟踪则可由ptrace(PTRACE_SINGLESTEP)实现。 </span></strong></span><br />   &#13;
