
<p><strong>    <span style="font-size:24px;">    Linux系统运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数（比如C库函数）再有库函数通过系统调用界面，让内核带其完成各种不同的任务。</span></strong></p><p><strong><span style="font-size:24px;">下面这张图显示的就是应用程序，内核和硬件之间的关系：</span></strong></p><p style="text-align: center;"><strong><span style="font-size:24px;"><img src="http://img.blog.csdn.net/20130805203411015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></strong></p><p><strong><span style="font-size:24px;"><br /></span></strong></p><p><strong><span style="font-size:24px;">      在任何时间点上我们都可以将每个处理器的活动概括为以下三者之一：</span></strong></p><p><strong><span style="font-size:24px;"><br /></span></strong></p><p><strong><span style="font-size:24px;">1.运行于用户空间，执行用户进程</span></strong></p><p><strong><span style="font-size:24px;">2.运行于内核空间，处于进程上下文，代表某个特定的进程执行</span></strong></p><p><strong><span style="font-size:24px;">3.运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断</span></strong></p><p><strong><span style="font-size:24px;"><br /></span></strong></p><p><strong><span style="font-size:24px;">      以上所列几乎包括所有的情况，即使边边角角的情况也不例外，例如，当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。</span></strong></p><p><strong><span style="font-size:24px;"><br /></span></strong></p><p><strong><span style="font-size:24px;">      Linux是一个单内核，也就是说，Linux内核运行在单独的内核地址空间上。不过，Linux汲取了微内核的精华：其引以为豪的是模块化设计，抢占式内核，支持内核线程以及动态装载内核模块的能力。不仅于此，Linux还避其微内核设计上性能损失的缺陷，让所有事情都运行于内核态，直接调用函数，无需消息传递。至今，Linux是模块化的，多线程的以及内核本身可调度的操作系统。</span></strong></p>   &#13;
