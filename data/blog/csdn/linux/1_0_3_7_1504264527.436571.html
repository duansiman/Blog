

<h1 style="line-height:50px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 21.6pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">1</span><span style="line-height:normal; font-family:'Times New Roman'">       </span></span><span style="font-family:宋体"><span style="line-height:43px">系统调用意义</span></span></span></span></h1>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">linux</span></span><span style="font-family:宋体"><span style="color:#000000">内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，</span><span style="color:red">只是系统调用由操作系统核心提供，运行于核心态，而普通的函数调用由函数库或用户自己提供，运行于用户态。</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。</span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">CPU</span><span style="font-family:宋体">硬件决定了这些（这就是为什么它被称作</span><span lang="EN-US" xml:lang="EN-US">"</span><span style="font-family:宋体">保护模式</span><span lang="EN-US" xml:lang="EN-US">"</span></span><span style="font-family:宋体"><span style="color:#000000">）。为了和用户空间上运行的进程进行交互，内核提供了一组接口。</span><span style="color:red">透过该接口，应用程序可以访问硬件设备和其他操作系统资源。</span><span style="color:#000000">这组接口在应用程序和内核之间扮演了使者的角色，</span><span style="color:red">应用程序发送各种请求，而内核负责满足这些请求</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">(</span><span style="color:red; font-family:宋体">或者让应用程序暂时搁置</span><span lang="EN-US" style="color:red" xml:lang="EN-US">)</span><span style="font-family:宋体"><span style="color:#000000">。实际上提供这组接口主要是为了</span><span style="color:red">保证系统稳定可靠</span><span style="color:#000000">，避免应用程序肆意妄行，惹出大麻烦。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-family:宋体"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span lang="EN-US" style="font-family:Wingdings" xml:lang="EN-US"><span style="color:#000000"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span></span><span style="font-family:宋体"><span style="line-height:28px"><span style="color:#000000">它为用户空间提供了一种统一的</span><span style="color:red">硬件的抽象接口</span><span style="color:#000000">。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span lang="EN-US" style="font-family:Wingdings" xml:lang="EN-US"><span style="color:#000000"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span></span><span style="line-height:28px"><span style="color:red; font-family:宋体">系统调用保证了系统的稳定和安全</span><span style="font-family:宋体"><span style="color:#000000">。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span lang="EN-US" style="font-family:Wingdings" xml:lang="EN-US"><span style="color:#000000"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span></span><span style="line-height:28px"><span style="font-family:宋体"><span style="color:#000000">每个进程都运行在虚拟系统中，而在</span><span style="color:red">用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。</span><span style="color:#000000">如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">Linux</span></span><span style="font-family:宋体"><span style="color:#000000">中，</span><span style="color:red">系统调用是用户空间访问内核的惟一手段</span><span style="color:#000000">；除异常和中断外，它们是内核惟一的合法入口。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h1 style="line-height:50px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 21.55pt; text-indent:-21.55pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">2</span><span style="line-height:normal; font-family:'Times New Roman'">       </span></span><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">API/POSIX/C</span></span><span style="font-family:宋体"><span style="line-height:43px">库的关系</span></span></span></span></h1>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">一般情况下，</span><span style="color:red">应用程序通过应用编程接口</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">(API)</span><span style="color:red; font-family:宋体">而不是直接通过系统调用来编程</span><span style="font-family:宋体"><span style="color:#000000">。这点很重要，</span><span style="color:red">因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应</span><span style="color:#000000">。一个</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">API</span></span><span style="font-family:宋体"><span style="color:#000000">定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，</span><span style="color:red">而完全不使用任何系统调用也不存在问题</span><span style="color:#000000">。实际上，</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">API</span><span style="color:red; font-family:宋体">可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">在</span><span lang="EN-US" xml:lang="EN-US">Unix</span><span style="font-family:宋体">世界中，最流行的应用编程接口是基于</span><span lang="EN-US" xml:lang="EN-US">POSIX</span><span style="font-family:宋体">标准的，其目标是提供一套大体上基于</span><span lang="EN-US" xml:lang="EN-US">Unix</span><span style="font-family:宋体">的可移植操作系统标准。</span><span lang="EN-US" xml:lang="EN-US">POSIX</span><span style="font-family:宋体">是说明</span><span lang="EN-US" xml:lang="EN-US">API</span><span style="font-family:宋体">和系统调用之间关系的一个极好例子。在大多数</span><span lang="EN-US" xml:lang="EN-US">Unix</span><span style="font-family:宋体">系统上，根据</span><span lang="EN-US" xml:lang="EN-US">POSIX</span><span style="font-family:宋体">而定义的</span><span lang="EN-US" xml:lang="EN-US">API</span><span style="font-family:宋体">函数和系统调用之间有着直接关系。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span lang="EN-US" style="color:red" xml:lang="EN-US">Linux</span><span style="color:red; font-family:宋体">的系统调用像大多数</span><span lang="EN-US" style="color:red" xml:lang="EN-US">Unix</span><span style="color:red; font-family:宋体">系统一样，作为</span><span lang="EN-US" style="color:red" xml:lang="EN-US">C</span><span style="color:red; font-family:宋体">库的一部分提供</span><span style="color:#000000"><span style="font-family:宋体">如下图所示。</span><span lang="EN-US" xml:lang="EN-US">C</span><span style="font-family:宋体">库实现了</span><span lang="EN-US" xml:lang="EN-US"> Unix</span><span style="font-family:宋体">系统的主要</span><span lang="EN-US" xml:lang="EN-US">API</span><span style="font-family:宋体">，包括标准</span><span lang="EN-US" xml:lang="EN-US">C</span><span style="font-family:宋体">库函数和系统调用。所有的</span><span lang="EN-US" xml:lang="EN-US">C</span><span style="font-family:宋体">程序都可以使用</span><span lang="EN-US" xml:lang="EN-US">C</span><span style="font-family:宋体">库，而由于</span><span lang="EN-US" xml:lang="EN-US">C</span><span style="font-family:宋体">语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong></strong></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">从程序员的角度看，系统调用无关紧要，他们只需要跟</span><span lang="EN-US" xml:lang="EN-US">API</span><span style="font-family:宋体">打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span style="color:#000000"><span style="line-height:28px"><span style="font-family:宋体">关于</span><span lang="EN-US" xml:lang="EN-US">Unix</span></span></span><span style="line-height:28px"><span style="font-family:宋体"><span style="color:#000000">的界面设计有一句通用的格言</span><span style="color:red">“提供机制而不是策略”</span><span style="color:#000000">。换句话说，</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">Unix</span></span><span style="font-family:宋体"><span style="color:#000000">的</span><span style="color:red">系统调用抽象出了用于完成某种确定目的的函数</span><span style="color:#000000">。至干这些函数怎么用完全不需要内核去关心。区别对待机制</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">(mechanism)</span><span style="font-family:宋体">和策略</span><span lang="EN-US" xml:lang="EN-US">(policy)</span><span style="font-family:宋体">是</span><span lang="EN-US" xml:lang="EN-US">Unix</span><span style="font-family:宋体">设计中的一大亮点。大部分的编程问题都可以被切割成两个部分</span><span lang="EN-US" xml:lang="EN-US">:</span><span style="font-family:宋体">“需要提供什么功能”</span><span lang="EN-US" xml:lang="EN-US">(</span><span style="font-family:宋体">机制</span><span lang="EN-US" xml:lang="EN-US">)</span><span style="font-family:宋体">和“怎样实现这些功能”</span><span lang="EN-US" xml:lang="EN-US">(</span><span style="font-family:宋体">策略</span><span lang="EN-US" xml:lang="EN-US">)</span><span style="font-family:宋体">。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h1 style="line-height:50px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 21.55pt; text-indent:-21.55pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">3</span><span style="line-height:normal; font-family:'Times New Roman'">       </span></span><span style="font-family:宋体"><span style="line-height:43px">系统调用的实现</span></span></span></span></h1>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.8pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">3.1</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">系统调用处理程序</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">您或许疑惑：</span><span lang="EN-US" xml:lang="EN-US"> “</span><span style="font-family:宋体">当我输入</span><span lang="EN-US" xml:lang="EN-US"> cat /proc/cpuinfo </span><span style="font-family:宋体">时，</span><span lang="EN-US" xml:lang="EN-US">cpuinfo() </span><span style="font-family:宋体">函数是如何被调用的？</span><span lang="EN-US" xml:lang="EN-US">”</span><span style="font-family:宋体">内核完成引导后，控制流就从相对直观的</span><span lang="EN-US" xml:lang="EN-US">“</span><span style="font-family:宋体">接下来调用哪个函数？</span><span lang="EN-US" xml:lang="EN-US">”</span><span style="font-family:宋体">改变为取决于系统调用、异常和中断。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-family:宋体"><span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000">用户空间的程序无法直接执行内核代码。</span><span style="color:red">它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上</span><span style="color:#000000">。如果进程可以直接在内核的地址空间上读写的话，</span><span style="color:red">系统安全就会失去控制。</span><span style="color:#000000">所以，应用程序应该以</span><span style="color:red">某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，</span><span style="color:#000000">这样内核就可以代表应用程序来执行该系统调用了。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">通知内核的机制是</span><span style="color:red">靠软件中断实现的</span><span style="color:#000000">。首先，用户程序为系统调用设置参数。其中一个参数是系统调用编号。参数设置完成后，程序执行</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">“</span><span style="font-family:宋体">系统调用</span><span lang="EN-US" xml:lang="EN-US">”</span></span><span style="font-family:宋体"><span style="color:#000000">指令。</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">x86</span><span style="color:red; font-family:宋体">系统上的软中断由</span><span lang="EN-US" style="color:red" xml:lang="EN-US">int</span><span style="font-family:宋体"><span style="color:#000000">产生。</span><span style="color:red">这个指令会导致一个异常：产生一个事件，这个事件会致使处理器</span><span style="color:#000000">切换到内核态并</span><span style="color:red">跳转到一个新的地址，并开始执行那里的</span><span style="color:#000000">异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。它与硬件体系结构紧密相关。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">新地址的指令会保存程序的状态，计算出应该调用哪个系统调用，调用内核中实现那个系统调用的函数，恢复用户程序状态，然后将控制权返还给用户程序。</span><span style="color:red">系统调用是设备驱动程序中定义的函数最终被调用的一种方式。</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.8pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">3.2</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">系统调用号</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span style="color:#000000"><span style="line-height:28px"><span style="font-family:宋体">在</span><span lang="EN-US" xml:lang="EN-US">Linux</span></span></span><span style="font-family:宋体"><span style="line-height:28px"><span style="color:#000000">中，每个系统调用被赋予一个系统调用号。这样，</span><span style="color:red">通过这个独一无二的号就可以关联系统调用。</span><span style="color:#000000">当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。</span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">有一个“未实现”系统调用</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">sys_ni_syscall()</span><span style="color:red; font-family:宋体">，</span><span style="color:#000000"><span style="font-family:宋体">它除了返回一</span><span lang="EN-US" xml:lang="EN-US">ENOSYS</span><span style="font-family:宋体">外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">因为</span><span style="color:red">所有的系统调用陷入内核的方式都一样</span><span style="color:#000000">，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">x86</span></span><span style="font-family:宋体"><span style="color:#000000">上，</span><span style="color:red">系统调用号是通过</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">eax</span><span style="color:red; font-family:宋体">寄存器传递给内核的</span><span style="color:#000000"><span style="font-family:宋体">。在陷人内核之前，用户空间就把相应系统调用所对应的号放入</span><span lang="EN-US" xml:lang="EN-US">eax</span><span style="font-family:宋体">中了。这样系统调用处理程序一旦运行，就可以从</span><span lang="EN-US" xml:lang="EN-US">eax</span><span style="font-family:宋体">中得到数据。其他体系结构上的实现也都类似。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">内核记录了系统调用表中的</span><span style="color:red">所有已注册过的系统调用的列表</span><span style="color:#000000">，存储在</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">sys_call_table</span><span style="font-family:宋体"><span style="color:#000000">中。它</span><span style="color:red">与体系结构有关</span><span style="color:#000000">，一般在</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">entry.s</span><span style="font-family:宋体">中定义。这个表中为每一个有效的系统调用指定了惟一的系统调用号。</span><span lang="EN-US" xml:lang="EN-US">sys_call_table</span></span><span style="font-family:宋体"><span style="color:#000000">是一张由指向实现各种系统调用的</span><span style="color:red">内核函数的函数指针组成的表</span><span style="color:#000000">：</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-family:宋体"><span style="color:rgb(0,0,0)"></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US">system_call()</span><span style="font-family:宋体">函数通过将给定的系统调用号与</span><span lang="EN-US" xml:lang="EN-US">NR_syscalls</span><span style="font-family:宋体">做比较来检查其有效性。如果它大于或者等于</span><span lang="EN-US" xml:lang="EN-US">NR&#13;
 syscalls,</span><span style="font-family:宋体">该函数就返回一</span><span lang="EN-US" xml:lang="EN-US">ENOSYS</span><span style="font-family:宋体">。否则，就执行相应的系统调用。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US">      call *sys_ call-table(</span><span style="font-family:宋体">，</span><span lang="EN-US" xml:lang="EN-US">%eax, 4)</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">由于系统调用表中的表项是以</span><span lang="EN-US" xml:lang="EN-US">32</span><span style="font-family:宋体">位</span><span lang="EN-US" xml:lang="EN-US">(4</span><span style="font-family:宋体">字节</span><span lang="EN-US" xml:lang="EN-US">)</span><span style="font-family:宋体">类型存放的，所以内核需要将给定的系统调用号乘以</span><span lang="EN-US" xml:lang="EN-US">4</span><span style="font-family:宋体">，然后用所得的结果在该表中查询其位置</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">3.3</span><span style="line-height:normal; font-family:'Times New Roman'">    </span></span><span style="font-family:黑体">参数传递</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">除了系统调用号以外，大部分系统调用都还需要一些外部的参数输人。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样</span><span style="color:red">把这些参数也存放在寄存器里。在</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">x86</span><span style="color:red; font-family:宋体">系统上，</span><span lang="EN-US" style="color:red" xml:lang="EN-US">ebx,&#13;
 ecx, edx, esi</span><span style="color:red; font-family:宋体">和</span><span lang="EN-US" style="color:red" xml:lang="EN-US">edi</span><span style="color:red; font-family:宋体">按照顺序存放前五个参数。</span><span style="font-family:宋体"><span style="color:#000000">需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">给用户空间的返回值也通过寄存器传递</span><span style="color:#000000"><span style="font-family:宋体">。在</span><span lang="EN-US" xml:lang="EN-US">x86</span><span style="font-family:宋体">系统上，它存放在</span><span lang="EN-US" xml:lang="EN-US">eax</span><span style="font-family:宋体">寄存器中。接下来许多关于系统调用处理程序的描述都是针对</span><span lang="EN-US" xml:lang="EN-US">x86</span><span style="font-family:宋体">版本的。但不用担心，所有体系结构的实现都很类似。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">3.4</span><span style="line-height:normal; font-family:'Times New Roman'">    </span></span><span style="font-family:黑体">参数验证</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">系统调用必须仔细检查它们所有的参数是否合法有效。</span><span style="font-family:宋体"><span style="color:#000000">举例来说，</span><span style="color:red">与文件</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">I/O</span><span style="color:red; font-family:宋体">相关的系统调用必须检查文件描述符是否有效。</span><span style="color:#000000"><span style="font-family:宋体">与进程相关的函数必须检查提供的</span><span lang="EN-US" xml:lang="EN-US">PID</span><span style="font-family:宋体">是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">最重要的一种检查就是</span><span style="color:red">检查用户提供的指针是否有效</span><span style="color:#000000">。试想，如果一个进程可以给内核传递指针而又无须被检查，</span><span style="color:red">那么它就可以给出一个它根本就没有访问权限的指针，哄骗内核去为它拷贝本不允许它访问的数据</span><span style="color:#000000">，如原本属于其他进程的数据。在接收一个用户空间的指针之前，内核必须保证：</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><strong><span lang="EN-US" style="color:red; font-family:Wingdings" xml:lang="EN-US"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span><span style="line-height:28px"><span style="color:red; font-family:宋体">指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。</span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></span></strong></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span lang="EN-US" style="font-family:Wingdings" xml:lang="EN-US"><span style="color:#000000"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span></span><span style="font-family:宋体"><span style="line-height:28px"><span style="color:#000000">指针指向的内存区域</span><span style="color:red">在进程的地址空间里</span><span style="color:#000000">。进程决不能哄骗内核去读其他进程的数据。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt 21pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:-21pt">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span lang="EN-US" style="color:red; font-family:Wingdings" xml:lang="EN-US"><span style="line-height:28px">?</span><span style="line-height:normal; font-family:'Times New Roman'">      </span></span><span style="line-height:28px"><span style="font-family:宋体"><span style="color:#000000">如果是读，该内存应被标记为可读。如果是写，该内存应被标记为可写。</span><span style="color:red">进程决不能绕过内存访问限制。</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝</span><span style="color:#000000"><span style="font-family:宋体">。注意，内核无论何时都不能轻率地接受来自用户空间的指针</span><span lang="EN-US" xml:lang="EN-US">!</span><span style="font-family:宋体">这两个方法中必须有一个被调用。为了向用户空间写入数据，内核提供了</span><span lang="EN-US" xml:lang="EN-US">copy_to_user()</span><span style="font-family:宋体">，它需要三个参数。第一个参数是进程空间中的目的内存地址。第二个是内核空间内的源地址。最后一个参数是需要拷贝的数据长度</span><span lang="EN-US" xml:lang="EN-US">(</span><span style="font-family:宋体">字节数</span><span lang="EN-US" xml:lang="EN-US">)</span><span style="font-family:宋体">。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">为了从用户空间读取数据，内核提供了</span><span lang="EN-US" xml:lang="EN-US">copy_from_ user()</span><span style="font-family:宋体">，它和</span><span lang="EN-US" xml:lang="EN-US">copy-to-User()</span><span style="font-family:宋体">相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，返回</span><span lang="EN-US" xml:lang="EN-US">0</span><span style="font-family:宋体">。当出现上述错误时，系统调用返回标准</span><span lang="EN-US" xml:lang="EN-US">-EFAULT</span><span style="font-family:宋体">。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span style="color:#000000"><span style="line-height:28px"><span style="font-family:宋体">注意</span><span lang="EN-US" xml:lang="EN-US">copy_to_user()</span><span style="font-family:宋体">和</span><span lang="EN-US" xml:lang="EN-US">copy_from_user()</span></span></span><span style="font-family:宋体"><span style="line-height:28px"><span style="color:#000000">都有可能引起阻塞。</span><span style="color:red">当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候</span><span style="color:#000000">，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">3.5</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">系统调用的返回值</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000"><span style="font-family:宋体">系统调用</span><span lang="EN-US" xml:lang="EN-US">(</span><span style="font-family:宋体">在</span><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">中常称作</span><span lang="EN-US" xml:lang="EN-US">syscalls)</span><span style="font-family:宋体">通常通过函数进行调用。它们通常都需要定义一个或几个参数</span><span lang="EN-US" xml:lang="EN-US">(</span><span style="font-family:宋体">输入</span><span lang="EN-US" xml:lang="EN-US">)</span></span><span style="font-family:宋体"><span style="color:#000000">而且可能产生一些副作用，例如写某个文件或向给定的指针拷贝数据等等。为防止和正常的返回值混淆，</span><span style="color:red">系统调用并不直接返回错误码，而是将错误码放入一个名为</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">errno</span><span style="color:red; font-family:宋体">的全局变量中</span><span style="font-family:宋体"><span style="color:#000000">。通常</span><span style="color:red">用一个负的返回值来表明错误。</span><span style="color:#000000">返回一个</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">0</span><span style="font-family:宋体">值通常表明成功。如果一个系统调用失败，你可以读出</span><span lang="EN-US" xml:lang="EN-US">errno</span></span><span style="font-family:宋体"><span style="color:#000000">的值来确定问题所在。</span><span style="color:red">通过调用</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">perror()</span><span style="color:red; font-family:宋体">库函数</span><span style="font-family:宋体"><span style="color:#000000">，可以把该变量翻译成用户可以理解的错误字符串。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">errno</span><span style="font-family:宋体">不同数值所代表的错误消息定义在</span><span lang="EN-US" xml:lang="EN-US">errno.h</span><span style="font-family:宋体">中，你也可以通过命令</span><span lang="EN-US" xml:lang="EN-US">"man&#13;
 3 errno"</span><span style="font-family:宋体">来察看它们。需要注意的是，</span><span lang="EN-US" xml:lang="EN-US">errno</span><span style="font-family:宋体">的值只在函数发生错误时设置，如果函数不发生错误，</span><span lang="EN-US" xml:lang="EN-US">errno</span><span style="font-family:宋体">的值就无定义，并不会被置为</span><span lang="EN-US" xml:lang="EN-US">0</span><span style="font-family:宋体">。另外，在处理</span><span lang="EN-US" xml:lang="EN-US">errno</span></span><span style="font-family:宋体"><span style="color:#000000">前最好先把它的值存入另一个变量，</span><span style="color:red">因为在错误处理过程中，即使像</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">printf()</span><span style="color:red; font-family:宋体">这样的函数出错时也会改变</span><span lang="EN-US" style="color:red" xml:lang="EN-US">errno</span><span style="color:red; font-family:宋体">的值。</span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">当然，系统调用最终具有一种明确的操作。举例来说，如</span><span lang="EN-US" xml:lang="EN-US">getpid()</span><span style="font-family:宋体">系统调用，根据定义它会返回当前进程的</span><span lang="EN-US" xml:lang="EN-US">PID</span><span style="font-family:宋体">。内核中它的实现非常简单</span><span lang="EN-US" xml:lang="EN-US">:</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>asmlinkage long sys_ getpid(void)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>{</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>    return current-&gt; tgid;</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>}</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">上述的系统调用尽管非常简单，但我们还是可以从中发现两个特别之处。首先，注意函数声明中的</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">asmlinkage</span><span style="color:red; font-family:宋体">限定词，这是一个小戏法，用于通知编译器仅从栈中提取该函数的参数。</span><span style="font-family:宋体"><span style="color:#000000">所有的系统调用都需要这个限定词。其次，</span><span style="color:red">注意系统调用</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">get_pid()</span><span style="color:red; font-family:宋体">在内核中被定义成</span><span lang="EN-US" style="color:red" xml:lang="EN-US">sys_&#13;
 getpid</span><span style="color:red; font-family:宋体">。</span><span style="color:#000000"><span style="font-family:宋体">这是</span><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">中所有系统调用都应该遵守的命名规则</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h1 style="line-height:50px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 21.55pt; text-indent:-21.55pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">4</span><span style="line-height:normal; font-family:'Times New Roman'">       </span></span><span style="font-family:宋体"><span style="line-height:43px">添加新系统调用</span></span></span></span></h1>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">给</span><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">添加一个新的系统调用是件相对容易的工作。怎样设计和实现一个系统调用是难题所在，而把它加到内核里却无须太多周折。让我们关注一下实现一个新的</span><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">系统调用所需的步骤。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">实现一个新的系统调用的第一步是决定它的用途。它要做些什么？每个系统调用都应该有一个明确的用途。</span><span style="color:red">在</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">Linux</span><span style="color:red; font-family:宋体">中不提倡采用多用途的系统调用</span><span lang="EN-US" style="color:red" xml:lang="EN-US">(</span><span style="color:red; font-family:宋体">一个系统调用通过传递不同的参数值来选择完成不同的工作</span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">)</span><span style="font-family:宋体">。</span><span lang="EN-US" xml:lang="EN-US">ioctl()</span><span style="font-family:宋体">就应该被视为一个反例。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">新系统调用的参数、返回值和错误码又该是什么呢？系统调用的接口应该力求简洁，参数尽可能少。</span><span style="color:red">设计接口的时候要尽量为将来多做考虑</span><span style="color:#000000">。你是不是对函数做了不必要的限制</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">?</span></span><span style="color:red; font-family:宋体">系统调用设计得越通用越好。</span><span style="font-family:宋体"><span style="color:#000000">不要假设这个系统调用现在怎么用将来也一定就是这么用。系统调用的目的可能不变，但它的用法却可能改变。</span><span style="color:red">这个系统调用可移植吗</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">?</span><span style="color:red; font-family:宋体">别对机器的字节长度和字节序做假设。当你写一个系统调用的时候，要时刻注意可移植性和健壮性，不但要考虑当前，还要为将来做打算。</span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-family:宋体"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>当编写完一个系统调用后，把它注册成一个正式的系统调用是件琐碎的工作：</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">在系统调用表的最后加入一个表项。</span><span style="color:red">每种支持该系统调用的硬件体系都必须做这样的工作</span><span style="color:#000000">。从</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">0</span><span style="font-family:宋体">开始算起，系统调用在该表中的位置就是它的系统调用号。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">对于所支持的各种体系结构，</span><span style="color:red">系统调用号都必须定义于</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">&lt;asm/unistd.h&gt;</span><span style="font-family:宋体"><span style="color:#000000">中。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">系统调用必须被编译进内核映象</span><span lang="EN-US" style="color:red" xml:lang="EN-US">(</span><span style="color:#000000"><span style="font-family:宋体">不能被编译成模块</span><span lang="EN-US" xml:lang="EN-US">)</span></span><span style="font-family:宋体"><span style="color:#000000">。这只要把它</span><span style="color:blue">放进</span></span><span lang="EN-US" style="color:blue" xml:lang="EN-US">kernel/</span><span style="color:blue; font-family:宋体">下的一个相关文件中就可以。</span><span lang="EN-US" style="color:blue" xml:lang="EN-US"></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000"><span style="font-family:宋体">让我们通过一个虚构的系统调用</span><span lang="EN-US" xml:lang="EN-US">f00()</span><span style="font-family:宋体">来仔细观察一下这些步骤。首先，我们要把</span><span lang="EN-US" xml:lang="EN-US">sys_foo</span></span><span style="font-family:宋体"><span style="color:#000000">加入到系统调用表中去。</span><span style="color:blue">对于大多数体系结构来说，该表位干</span></span><span lang="EN-US" style="color:blue" xml:lang="EN-US">entry.s</span><span style="color:blue; font-family:宋体">文件</span><span style="color:#000000"><span style="font-family:宋体">中，形式如下</span><span lang="EN-US" xml:lang="EN-US">:</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>ENTRY(sys_ call_ table)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>      ·long sys_ restart_ syscall/*0*/</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>      .long sys_ exit</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>      ·long sys_ fork</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>      ·long sys_ read</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>      .long sys_write</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">我们把新的系统调用加到这个表的末尾</span><span lang="EN-US" xml:lang="EN-US">:</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>     .long sys_foo</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-size:18px"><span style="font-weight:bold"><span style="color:#000000"><span style="line-height:28px"><span style="font-family:宋体">虽然没有明确地指定编号，但我们加入的这个系统调用被按照次序分配给了</span><span lang="EN-US" xml:lang="EN-US">283</span></span></span><span style="font-family:宋体"><span style="line-height:28px"><span style="color:#000000">这个系统调用号。</span><span style="color:red">对于每种需要支持的体系结构，我们都必须将自己的系统调用加人到其系统调用表中去。</span><span style="color:#000000">每种体系结构不需要对应相同的系统调用号。</span></span></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">接下来，我们把系统调用号加入到</span><span lang="EN-US" xml:lang="EN-US">&lt;asm/unistd.h&gt;</span><span style="font-family:宋体">中，它的格式如下</span><span lang="EN-US" xml:lang="EN-US">:</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US">/*</span><span style="font-family:宋体">本文件包含系统调用号</span><span lang="EN-US" xml:lang="EN-US">*/</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define_ NR_ restart_ syscall</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR exit</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR fork</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR read</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR write</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR- mq getsetattr 282</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">然后，我们在该列表中加入下面这行</span><span lang="EN-US" xml:lang="EN-US">:</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>#define_ NR_ foo 283</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">最后，我们来实现</span><span lang="EN-US" xml:lang="EN-US">f00()</span><span style="font-family:宋体">系统调用。无论何种配置，该系统调用都必须编译到核心的内核映象中去，所以我们把它放进</span><span lang="EN-US" xml:lang="EN-US">kernel/sys.c</span><span style="font-family:宋体">文件中。你也可以将其放到与其功能联系最紧密的代码中去</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>asmlinkage long sys-foo(void)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>{</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>return THREAD SIZE</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">就是这样</span><span lang="EN-US" xml:lang="EN-US">!</span><span style="font-family:宋体">严格说来，现在就可以在用户空间调用</span><span lang="EN-US" xml:lang="EN-US">f00()</span><span style="font-family:宋体">系统调用了。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-family:宋体"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>建立一个新的系统调用非常容易，但却绝不提倡这么做。通常模块可以更好的代替新建一个系统调用。</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h1 style="line-height:50px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 21.55pt; text-indent:-21.55pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="line-height:43px">5</span><span style="line-height:normal; font-family:'Times New Roman'">       </span></span><span style="font-family:宋体"><span style="line-height:43px">访问系统调用</span></span></span></span></h1>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">5.1</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">系统调用上下文</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:red; font-family:宋体">内核在执行系统调用的时候处于进程上下文</span><span style="color:#000000"><span style="font-family:宋体">。</span><span lang="EN-US" xml:lang="EN-US">current</span><span style="font-family:宋体">指针指向当前任务，即引发系统调用的那个进程。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="font-family:宋体"><span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000">在进程上下文中，内核可以休眠并且可以被抢占。这两点都很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。休眠的能力会给内核编程带来极大便利。</span><span style="color:red">在进程上下文中能够被抢占，其实表明，像用户空间内的进程一样，当前的进程同样可以被其他进程抢占。</span><span style="color:#000000">因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重人的。当然，这也是在对称多处理中必须同样关心的问题。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">当系统调用返回的时候，控制权仍然在</span><span lang="EN-US" xml:lang="EN-US">system_call()</span><span style="font-family:宋体">中，它最终会负责切换到用户空间并让用户进程继续执行下去。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">5.2</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">系统调用访问示例</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">操作系统使用系统调用表将系统调用编号翻译为特定的系统调用。</span><span style="color:red">系统调用表包含有实现每个系统调用的函数的地址。</span><span style="color:#000000">例如，</span></span><span style="color:#000000"><span lang="EN-US" xml:lang="EN-US">read() </span><span style="font-family:宋体">系统调用函数名为</span><span lang="EN-US" xml:lang="EN-US"> sys_read</span><span style="font-family:宋体">。</span><span lang="EN-US" xml:lang="EN-US">read() </span><span style="font-family:宋体">系统调用编号是</span><span lang="EN-US" xml:lang="EN-US"> 3</span><span style="font-family:宋体">，所以</span><span lang="EN-US" xml:lang="EN-US"> sys_read()</span><span style="font-family:宋体">位于系统调用表的第四个条目中（因为系统调用起始编号为</span><span lang="EN-US" xml:lang="EN-US">0</span><span style="font-family:宋体">）。从地址</span><span lang="EN-US" xml:lang="EN-US"> sys_call_table&#13;
 + (3 * word_size) </span><span style="font-family:宋体">读取数据，得到</span><span lang="EN-US" xml:lang="EN-US"> sys_read() </span><span style="font-family:宋体">的地址。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000"><span style="font-family:宋体">找到正确的系统调用地址后，它将控制权转交给那个系统调用。我们来看定义</span><span lang="EN-US" xml:lang="EN-US"> sys_read() </span><span style="font-family:宋体">的位置，即</span><span lang="EN-US" xml:lang="EN-US">fs/read_write.c </span></span><span style="font-family:宋体"><span style="color:#000000">文件。</span><span style="color:red">这个函数会找到关联到</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"> fd </span><span style="color:red; font-family:宋体">编号（传递给</span><span lang="EN-US" style="color:red" xml:lang="EN-US"> read() </span><span style="color:red; font-family:宋体">函数的）的文件结构体。</span><span style="color:#000000"><span style="font-family:宋体">那个结构体包含指向用来读取特定类型文件数据的函数的指针。进行一些检查后，它调用与文件相关的</span><span lang="EN-US" xml:lang="EN-US"> read() </span></span><span style="font-family:宋体"><span style="color:#000000">函数，来真正从文件中读取数据并返回。</span><span style="color:red">与文件相关的函数是在其他地方定义的</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US"> —— </span><span style="color:red; font-family:宋体">比如套接字代码、文件系统代码，或者设备驱动程序代码</span><span style="font-family:宋体"><span style="color:#000000">。这是特定内核子系统最终与内核其他部分协作的一个方面。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="color:#000000"><span style="font-family:宋体">读取函数结束后，从</span><span lang="EN-US" xml:lang="EN-US"> sys_read() </span><span style="font-family:宋体">返回，它将控制权切换给</span><span lang="EN-US" xml:lang="EN-US"> ret_from_sys</span></span><span style="font-family:宋体"><span style="color:#000000">。它会去检查那些在</span><span style="color:red">切换回用户空间之前需要完成的任务。如果没有需要做的事情，那么就恢复用户进程的状态，并将控制权交还给用户程序。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="font-size:18px"><strong></strong></span></span></p>&#13;
<h2 style="line-height:37px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; margin:0cm 0cm 0pt 28.9pt; text-indent:-28.9pt">&#13;
<span style="color:#000000"><span style="font-size:18px"><span lang="EN-US" xml:lang="EN-US"><span style="font-family:Arial">5.3</span><span style="line-height:normal; font-family:'Times New Roman'"><span style="line-height:43px">    </span></span></span><span style="font-family:黑体">从用户空间直接访问系统调用</span></span></span></h2>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">通常，</span><span style="color:red">系统调用靠</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">C</span><span style="color:red; font-family:宋体">库支持。用户程序通过包含标准头文件并和</span><span lang="EN-US" style="color:red" xml:lang="EN-US">C</span><span style="color:red; font-family:宋体">库链接，就可以使用系统调用</span><span lang="EN-US" style="color:red" xml:lang="EN-US">(</span><span style="color:red; font-family:宋体">或者调用库函数，再由库函数实际调用</span><span lang="EN-US" style="color:red" xml:lang="EN-US">)</span><span style="color:#000000"><span style="font-family:宋体">。但如果你仅仅写出系统调用，</span><span lang="EN-US" xml:lang="EN-US">glibc</span><span style="font-family:宋体">库恐怕并不提供支持。值得庆幸的是，</span><span lang="EN-US" xml:lang="EN-US">Linux</span><span style="font-family:宋体">本身提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷人指令。这些宏是</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">_syscalln()</span><span style="color:red; font-family:宋体">，其中</span><span lang="EN-US" style="color:red" xml:lang="EN-US">n</span><span style="color:red; font-family:宋体">的范围从</span><span lang="EN-US" style="color:red" xml:lang="EN-US">0</span><span style="color:red; font-family:宋体">到</span><span lang="EN-US" style="color:red" xml:lang="EN-US">6</span><span style="color:red; font-family:宋体">。代表需要传递给系统调用的参数个数，这是由于该宏必须了解到底有多少参数按照什么次序压入寄存器。</span><span style="color:#000000"><span style="font-family:宋体">举个例子，</span><span lang="EN-US" xml:lang="EN-US">open()</span><span style="font-family:宋体">系统调用的定义是</span><span lang="EN-US" xml:lang="EN-US">:</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>long open(const char *filename, int flags, int mode)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">而不靠库支持，直接调用此系统调用的宏的形式为</span><span lang="EN-US" xml:lang="EN-US">:</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR_ open 5</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US">syscall3(long, open, const char*</span><span style="font-family:宋体">，</span><span lang="EN-US" xml:lang="EN-US">filename, int, flags, int, mode)</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">这样，应用程序就可以直接使用</span><span lang="EN-US" xml:lang="EN-US">open()</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="font-size:18px"><strong><span style="font-family:宋体"><span style="color:#000000">对于每个宏来说，都有</span></span><span lang="EN-US" style="color:red" xml:lang="EN-US">2+ n</span><span style="color:red; font-family:宋体">个参数。</span><span style="color:#000000"><span style="font-family:宋体">第一个参数对应着系统调用的返回值类型。第二个参数是系统调用的名称。再以后是按照系统调用参数的顺序排列的每个参数的类型和名称。</span><span lang="EN-US" xml:lang="EN-US">_NR_&#13;
 open</span><span style="font-family:宋体">在</span><span lang="EN-US" xml:lang="EN-US">&lt;asm/unistd.h&gt;</span><span style="font-family:宋体">中定义，是系统调用号。该宏会被扩展成为内嵌汇编的</span><span lang="EN-US" xml:lang="EN-US">C</span></span><span style="font-family:宋体"><span style="color:#000000">函数。</span><span style="color:red">由汇编语言执行前一节所讨论的步骤，将系统调用号和参数压入寄存器并触发软中断来陷入内核。</span><span style="color:#000000">调用</span></span><span lang="EN-US" xml:lang="EN-US"><span style="color:#000000">open()</span></span><span style="font-family:宋体"><span style="color:#000000">系统调用直接把上面</span><span style="color:red">的宏放置在应用程序中就可以了。</span></span></strong></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span style="font-family:宋体">让我们写一个宏来使用前面编写的</span><span lang="EN-US" xml:lang="EN-US">foo()</span><span style="font-family:宋体">系统调用，然后再写出测试代码炫耀一下我们所做的努力。</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>#define NR foo 283</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" style="color:red" xml:lang="EN-US"><span style="line-height:28px"><span style="font-size:18px"><strong>_sysca110(long, foo)</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>int main()</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>{</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>long stack size;</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>stack_ size=foo();</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>printf("The kernel stack</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span style="line-height:28px"><span style="color:#000000"><span style="font-size:18px"><strong><span lang="EN-US" xml:lang="EN-US">size is 81d\n"</span><span style="font-family:宋体">，</span><span lang="EN-US" xml:lang="EN-US">stack_ size);</span></strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>return;</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong>}</strong></span></span></span></p>&#13;
<p style="line-height:25px; margin:0cm 0cm 0pt; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53">&#13;
<span lang="EN-US" xml:lang="EN-US"><span style="color:rgb(0,0,0); line-height:28px"><span style="font-size:18px"><strong> </strong></span></span></span></p>&#13;
<br />&#13;
   &#13;
