

<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>当进程以阻塞的方式通信，在得到结果前进程会挂起休眠。<br />&#13;
为了将进程以一种安全的方式进入休眠，我们需要牢记两条规则：<br />&#13;
一、永远不要在原子上下文中进入休眠。<br />&#13;
二、进程休眠后，对环境一无所知。唤醒后，必须再次检查以确保我们等待的条件真正为真</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong><span style="color:#ff0000">简单休眠</span><br />&#13;
完成唤醒任务的代码还必须能够找到我们的进程，这样才能唤醒休眠的进程。需要维护一个称为等待队列的数据结构。等待队列就是一个进程链表，其中包含了等待某个特定事件的所有进程。<br />&#13;
linux维护一个“等待队列头”来管理，wait_queue_head_t,定义在&lt;linux/wait.h&gt;<br />&#13;
struct  __wait_queue_head {<br />&#13;
 wq_lock_t  lock;<br />&#13;
 struct  list_head  task_list;<br />&#13;
};<br />&#13;
typedef  struct __wait_queue_head  wait_queue_head_t;<br />&#13;
初始化方法：<br />&#13;
静态方法：<br />&#13;
DECLARE_WAIT_QUEUE_HEAD(name)<br />&#13;
动态方法：<br />&#13;
wait_queue_head_t my_queue;<br />&#13;
init_waitqueue_head(&amp;my_queue);</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>linux中最简单的休眠方式是下面的宏， <br />&#13;
wait_event(queue, condition)  /*进程将被置于非中断休眠（uninterruptible sleep）*/<br />&#13;
wait_event_interruptible(queue, condition) /*进程可被信号中断休眠,返回非0值表示休眠被信号中断*/<br />&#13;
wait_event_timeout(queue, condition, timeout)    /*等待限定时间jiffy，condition满足其一返回0*/<br />&#13;
wait_event_interruptible_timeout(queue, condition, timeout)<br />&#13;
queue是等待队列头，传值方式<br />&#13;
condition是任意一个布尔表达式，在休眠前后多次对condition求值，为真则唤醒</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>唤醒进程的基本函数是wake_up<br />&#13;
void wake_up(wait_queue_head_t *queue);    /*唤醒等待在给定queue上的所有进程*/<br />&#13;
void wake_up_interruptible(wait_queue_head_t *queue);</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>实践中，一般是wait_event和wake_up，wait_event_interruptible和wake_up_interruptible成对使用</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong><span style="color:#ff0000">高级休眠</span><br />&#13;
将进程置于休眠的步骤：<br />&#13;
（1）分配和初始化一个 wait_queue_t 结构， 随后将其添加到正确的等待队列</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>struct __wait_queue {        unsigned int flags;#define WQ_FLAG_EXCLUSIVE       0x01        void *private;        wait_queue_func_t func;        struct list_head task_list;};typedef struct __wait_queue wait_queue_t;（2）设置进程状态，标记为休眠。2.6内核中，使用下面的函数：<br />&#13;
      void set_current_state(int new_state);<br />&#13;
    在 &lt;linux/sched.h&gt; 中定义有几个任务状态：TASK_RUNNING 意思是进程能够运行。有 2 个状态指示一个进程是   在睡眠: TASK_INTERRUPTIBLE 和 TASK_UNTINTERRUPTIBLE</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>（3）最后一步是放弃处理器。 但必须先检查进入休眠的条件。如果不做检查会引入竞态： 如果在忙于上面的这个过程时有其他的线程刚刚试图唤醒你，你可能错过唤醒且长时间休眠。因此典型的代码下<br />&#13;
if (!condition) <br />&#13;
     schedule( );    /*调用调度器，并让出CPU*/<br />&#13;
如果代码只是从 schedule 返回，则进程处于TASK_RUNNING 状态。 如果不需睡眠而跳过对 schedule 的调用，必须将任务状态重置为 TASK_RUNNING，还必要从等待队列中去除这个进程，否则它可能被多次唤醒。</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong><span style="color:#ff0000">手工休眠</span><br />&#13;
上面的进程休眠步骤可通过手工设置：<br />&#13;
 （1）创建和初始化一个等待队列。常由宏定义完成:<br />&#13;
DEFINE_WAIT(my_wait);<br />&#13;
name 是等待队列入口项的名字. 也可以用2步来做:<br />&#13;
wait_queue_t my_wait;<br />&#13;
init_wait(&amp;my_wait);<br />&#13;
常用的做法是放一个 DEFINE_WAIT 在循环的顶部，来实现休眠</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>（2）添加等待队列入口到队列，并设置进程状态:<br />&#13;
void prepare_to_wait(wait_queue_head_t *queue, <br />&#13;
                               wait_queue_t *wait, <br />&#13;
                               int state); <br />&#13;
queue 和 wait 分别地是等待队列头和进程入口。state 是进程的新状态：TASK_INTERRUPTIBLE(可中断休眠，推荐)或TASK_UNINTERRUPTIBLE(不可中断休眠，不推荐)</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>（3）在检查确认仍然需要休眠之后调用 schedule<br />&#13;
if (!condition) <br />&#13;
     schedule( );    /*调用调度器，并让出CPU*/</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>（4）schedule 返回，就到了清理时间:<br />&#13;
void finish_wait(wait_queue_head_t *queue, wait_queue_t *wait);</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong>认真地看简单休眠中的 wait_event(queue, condition) 和 wait_event_interruptible(queue, condition) 底层源码会发现，其实他们只是手工休眠中的函数的组合。所以怕麻烦的话还是用wait_event比较好。</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong><span style="color:#ff0000">独占等待</span><br />&#13;
当一个进程调用 wake_up 在等待队列上，所有的在这个队列上等待的进程被置为可运行的。 这在许多情况下是正确的做法。但有时，可能只有一个被唤醒的进程将成功获得需要的资源，而其余的将再次休眠。这时如果等待队列中的进程数目大，这可能严重降低系统性能。为此，内核开发者增加了一个“独占等待”选项。它与一个正常的睡眠有 2 个重要的不同:<br />&#13;
（1）当等待队列入口设置了 WQ_FLAG_EXCLUSEVE 标志，它被添加到等待队列的尾部；否则，添加到头部。<br />&#13;
（2）当 wake_up 被在一个等待队列上调用, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止唤醒.但内核仍然每次唤醒所有的非独占等待。<br />&#13;
采用独占等待要满足 2 个条件:<br />&#13;
（1）希望对资源进行有效竞争；<br />&#13;
（2）当资源可用时，唤醒一个进程就足够来完全消耗资源。<br />&#13;
使一个进程进入独占等待，可调用： <br />&#13;
void prepare_to_wait_exclusive(wait_queue_head_t *queue, wait_queue_t *wait, int state); <br />&#13;
注意：无法使用 wait_event 和它的变体来进行独占等待.</strong></span></p>&#13;
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; line-height:25.600000381469727px">&#13;
<span style="font-size:18px"><strong><span style="color:#ff0000">唤醒函数</span><br />&#13;
很少会需要调用wake_up_interruptible 之外的唤醒函数，但为完整起见，这里是整个集合：<br />&#13;
wake_up(wait_queue_head_t *queue); <br />&#13;
wake_up_interruptible(wait_queue_head_t *queue); <br />&#13;
wake_up 唤醒队列中的每个非独占等待进程和一个独占等待进程。wake_up_interruptible 同样, 除了它跳过处于不可中断休眠的进程。它们在返回之前, 使一个或多个进程被唤醒、被调度(如果它们被从一个原子上下文调用, 这就不会发生).<br />&#13;
wake_up_nr(wait_queue_head_t *queue, int nr); <br />&#13;
wake_up_interruptible_nr(wait_queue_head_t *queue, int nr); <br />&#13;
这些函数类似 wake_up, 除了它们能够唤醒多达 nr 个独占等待者, 而不只是一个. 注意传递 0 被解释为请求所有的互斥等待者都被唤醒<br />&#13;
wake_up_all(wait_queue_head_t *queue); <br />&#13;
wake_up_interruptible_all(wait_queue_head_t *queue); <br />&#13;
这种 wake_up 唤醒所有的进程, 不管它们是否进行独占等待(可中断的类型仍然跳过在做不可中断等待的进程)<br />&#13;
wake_up_interruptible_sync(wait_queue_head_t *queue); <br />&#13;
一个被唤醒的进程可能抢占当前进程, 并且在 wake_up 返回之前被调度到处理器。 但是, 如果你需要不要被调度出处理器时，可以使用 wake_up_interruptible 的"同步"变体. 这个函数最常用在调用者首先要完成剩下的少量工作，且不希望被调度出处理器时。</strong></span></p>&#13;
   &#13;
