
<p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="color: blue; line-height: 21px;">Linux</span><span style="color: blue; line-height: 21px; font-family: 宋体;">内核的等待队列是以双循环链表为基础数据结构，与进程调度机制紧密结合，能够用于实现核心的异步事件通知机制。<img src="http://blogimg.chinaunix.net/blog/upfile2/080320094652.jpg" border="0" alt="" style="border: none; max-width: 100%;" /></span></strong></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: blue; line-height: 21px; font-family: 宋体;"><span style="font-size:18px;"><strong><span style="color: black;">在这个链表中，有两种数据结构：</span>等待队列头（wait_queue_head_t）和等待队列项（wait_queue_t）<span style="color: black;">。等待队列头和等待队列项中都包含一个</span><span style="color: black;">list_head</span><span style="color: black;">类型的域作为</span><span style="color: black;">"</span><span style="color: black;">连接件</span><span style="color: black;">"</span><span style="color: black;">。它通过一个双链表和把等待tast的头，和等待的进程列表链接起来。从上图可以清晰看到。所以我们知道，如果要实现一个等待队列，首先要有两个部分。队列头和队列项。下面看他们的数据结构。</span></strong></span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: blue; line-height: 21px; font-family: 宋体;"><span style="color: black;"></span></span></p><pre name="code" class="cpp"><span style="font-size:18px;"><strong>struct list_head {
    struct list_head *next, *prev;
};
struct __wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __wait_queue {
    unsigned int flags;
#define WQ_FLAG_EXCLUSIVE    0x01
    void *private;//2.6版本是采用void指针，而以前的版本是struct task_struct * task;
                  //实际在用的时候，仍然把private赋值为task
    wait_queue_func_t func;
    struct list_head task_list;
};
</strong></span></pre><span style="font-size:18px;"><strong><br /></strong></span><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>所以队列头和队列项是通过list_head联系到一起的，list_head是一个双向链表，在linux内核<span style="color: rgb(0, 0, 0);">中有着广泛的应用。并且在list.h中对它有着很多的操作。</span></strong></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong> </strong></span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>2.对列头和队列项的初始化：<br /> wait_queue_head_t my_queue;</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>init_waitqueue_head(&amp;my_queue);</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">直接定义并初始化。</span>init_waitqueue_head()<span style="font-family: 宋体;">函数会将自旋锁初始化为未锁，等待队列初始化为空的双向循环链表。</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>DECLARE_WAIT_QUEUE_HEAD(my_queue);</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-family: 宋体;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>定义并初始化</strong></span></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-family: 宋体;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>3.定义等待队列： DECLARE_WAITQUEUE(name,tsk);</strong></span></span></span></p><pre name="code" class="cpp"><span style="font-size:18px;"><strong>#define   DECLARE_WAITQUEUE(name,   tsk)       / 
wait_queue_t   name     =__WAITQUEUE_INITIALIZER(name,   tsk) 

#define   __WAITQUEUE_INITIALIZER(name,   tsk)   {         task:     tsk,        task_list:  {  NULL,   NULL   },  __WAITQUEUE_DEBUG_INI(name)} 
</strong></span></pre><span style="font-size:18px;"><strong><br /></strong></span><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="font-size:18px;"><strong><span style="color: rgb(0, 0, 0);">它的解释是: <br />通过DECLARE_WAITQUEUE宏将等待队列项初始化成对应的任务结构，并且用于连接的相关指针均设置为空。其中加入了调试相关代码。 <br />进程通过执行下面步骤将自己加入到一个等待队列中：<br />1） 调用DECLARE_WAITQUEUE()创建一个等待队列的</span>项；<br />2） 调用add_wait_queue()把自己加入到等待队列中。该队列会在进程等待的条件满足时唤醒它。在其他地方写相关代码，在事件发生时，对等的队列执行wake_up()操作。<br />3） 将进程状态变更为： TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE。<br />4） 如果状态被置为TASK_INTERRUPTIBLE ，则信号唤醒进程。即为伪唤醒（唤醒不是因为事件的发生），因此检查并处理信号。<br />5） 检查condition是否为真，为真则没必要休眠，如果不为真，则调用scheduled()。<br />6） 当进程被唤醒的时候，它会再次检查条件是否为真。真就退出循环，否则再次调用scheduled()并一直重复这步操作。<br />7） condition满足后，进程将自己设置为TASK_RUNNING 并通过remove_wait_queue()退出。</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong> </strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>4.(<span style="font-family: 宋体;">从等待队列头中</span>)<span style="font-family: 宋体;">添加／移出等待队列</span></strong></span></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="font-family: 宋体;"><span style="font-size:18px;"><strong>(1)add_wait_queue()函数： (2)remove_wait_queue()函数：</strong></span></span></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong> </strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="font-family: 宋体;"><span style="font-size:18px;"><strong>5.等待事件：（<span style="color: rgb(255, 0, 255);">有条件睡眠</span>）</strong></span></span></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="font-family: 宋体;"><span style="font-size:18px;"><strong>1)wait_event()宏：</strong></span></span></span></span></p><pre name="code" class="cpp"><span style="font-size:18px;"><strong>#define wait_event(wq, condition) / 

do { / 
if (condition) / 
break; / 
__wait_event(wq, condition); / 
} while (0) 
 
#define __wait_event_timeout(wq, condition, ret) / 

do { / 
DEFINE_WAIT(__wait); / 
/ 
for (;;) { / 
prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE); / 
if (condition) / 
break; / 
ret = schedule_timeout(ret); / 
if (!ret) / 
break; / 
} / 
finish_wait(&amp;wq, &amp;__wait); / 
} while (0) 
</strong></span></pre><span style="font-size:18px;"><strong><br /></strong></span><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">在等待会列中睡眠直到</span>condition<span style="font-family: 宋体;">为真。在等待的期间，进程会被置为</span>TASK_UNINTERRUPTIBLE<span style="font-family: 宋体;">进入睡眠，直到</span>condition<span style="font-family: 宋体;">变量变为真。每次进程被唤醒的时候都会检查</span>condition<span style="font-family: 宋体;">的值</span>.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>(2)wait_event_interruptible()<span style="font-family: 宋体;">函数</span>:</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">和</span>wait_event()<span style="font-family: 宋体;">的区别是调用该宏在等待的过程中当前进程会被设置为</span>TASK_INTERRUPTIBLE<span style="font-family: 宋体;">状态</span>.<span style="font-family: 宋体;">在每次被唤醒的时候</span>,<span style="font-family: 宋体;">首先检查</span>condition<span style="font-family: 宋体;">是否为真</span>,<span style="font-family: 宋体;">如果为真则返回</span>,<span style="font-family: 宋体;">否则检查如果进程是被信号唤醒</span>,<span style="font-family: 宋体;">会返回</span>-ERESTARTSYS<span style="font-family: 宋体;">错误码</span>.<span style="font-family: 宋体;">如果是</span>condition<span style="font-family: 宋体;">为真</span>,<span style="font-family: 宋体;">则返回</span>0.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>(3)wait_event_timeout()<span style="font-family: 宋体;">宏</span>:</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">也与</span>wait_event()<span style="font-family: 宋体;">类似</span>.<span style="font-family: 宋体;">不过如果所给的睡眠时间为负数则立即返回</span>.<span style="font-family: 宋体;">如果在睡眠期间被唤醒</span>,<span style="font-family: 宋体;">且</span>condition<span style="font-family: 宋体;">为真则返回剩余的睡眠时间</span>,<span style="font-family: 宋体;">否则继续睡眠直到到达或超过给定的睡眠时间</span>,<span style="font-family: 宋体;">然后返回</span>0.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>(4)wait_event_interruptible_timeout()<span style="font-family: 宋体;">宏</span>:</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">与</span>wait_event_timeout()<span style="font-family: 宋体;">类似</span>,<span style="font-family: 宋体;">不过如果在睡眠期间被信号打断则返回</span>ERESTARTSYS<span style="font-family: 宋体;">错误码</span>.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>(5) wait_event_interruptible_exclusive()<span style="font-family: 宋体;">宏</span></strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">同样和</span>wait_event_interruptible()<span style="font-family: 宋体;">一样</span>,<span style="font-family: 宋体;">不过该睡眠的进程是一个互斥进程</span>.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong> </strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>6.<span style="font-family: 宋体;">唤醒队列</span>:</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>(1)wake_up()<span style="font-family: 宋体;">函数</span>:</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">唤醒等待队列</span>.<span style="font-family: 宋体;">可唤醒处于</span>TASK_INTERRUPTIBLE<span style="font-family: 宋体;">和</span>TASK_UNINTERUPTIBLE<span style="font-family: 宋体;">状态的进程</span>,<span style="font-family: 宋体;">和</span>wait_event/wait_event_timeout<span style="font-family: 宋体;">成对使用</span>.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong>2)wake_up_interruptible()<span style="font-family: 宋体;">函数</span>: #define wake_up_interruptible(x) __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">和</span>wake_up()<span style="font-family: 宋体;">唯一的区别是它只能唤醒</span>TASK_INTERRUPTIBLE<span style="font-family: 宋体;">状态的进程</span>.,<span style="font-family: 宋体;">与</span>wait_event_interruptible/wait_event_interruptible_timeout/ wait_event_interruptible_exclusive<span style="font-family: 宋体;">成对使用</span>.</strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong> </strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="font-size:18px;"><strong>TASK_INTERRUPTIBLE，允许通过发送signal唤醒它（即可中断的睡眠状态）；</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="font-size:18px;"><strong>TASK_UNINTERRUPTIBLE，不接收任何 singal</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:18px;"><strong> </strong></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>7.<span style="font-family: 宋体;">在等待队列上睡眠：（<span style="color: rgb(255, 0, 255);">无条件睡眠，老内核使用，新内核建议不用</span>）</span></strong></span></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong> (1)sleep_on()<span style="font-family: 宋体;">函数</span>:</strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">该函数的作用是定义一个等待队列</span>(wait)<span style="font-family: 宋体;">，并将当前进程添加到等待队列中</span>(wait)<span style="font-family: 宋体;">，然后将当前进程的状态置为</span>TASK_UNINTERRUPTIBLE<span style="font-family: 宋体;">，并将等待队列</span>(wait)<span style="font-family: 宋体;">添加到等待队列头</span>(q)<span style="font-family: 宋体;">中。之后就被挂起直到资源可以获取，才被从等待队列头</span>(q)<span style="font-family: 宋体;">中唤醒，从等待队列头中移出。在被挂起等待资源期间，该进程不能被信号唤醒。</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>(2)sleep_on_timeout()<span style="font-family: 宋体;">函数：</span></strong></span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong> </strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">与</span>sleep_on()<span style="font-family: 宋体;">函数的区别在于调用该函数时，如果在指定的时间内</span>(timeout)<span style="font-family: 宋体;">没有获得等待的资源就会返回。实际上是调用</span>schedule_timeout()<span style="font-family: 宋体;">函数实现的。值得注意的是如果所给的睡眠时间</span>(timeout)<span style="font-family: 宋体;">小于</span>0<span style="font-family: 宋体;">，则不会睡眠。该函数返回的是真正的睡眠时间。</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>(3)interruptible_sleep_on()<span style="font-family: 宋体;">函数：</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong><span style="font-family: 宋体;">该函数和</span>sleep_on()<span style="font-family: 宋体;">函数唯一的区别是将当前进程的状态置为</span>TASK_INTERRUPTINLE<span style="font-family: 宋体;">，这意味在睡眠如果该进程收到信号则会被唤醒。</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>(4)interruptible_sleep_on_timeout()<span style="font-family: 宋体;">函数：</span></strong></span></span></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-family: 宋体;"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>类似于sleep_on_timeout()函数。进程在睡眠中可能在等待的时间没有到达就被信号打断而被唤醒，也可能是等待的时间到达而被唤醒。</strong></span></span></span></p><br />   &#13;
