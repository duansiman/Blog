
<h2 style="margin: 10px 0px 0px; padding: 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(221, 221, 221); position: relative; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">从开机加电，到执行main函数之前的过程</span></h2><p style="margin-top: 10px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><span style="background-color: rgb(255, 255, 255);"><strong>好吧，这里应该是有执行3个汇编的文件，但是我不太了解。囧</strong></span></p><h2 style="margin: 10px 0px 0px; padding: 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(221, 221, 221); position: relative; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">从main函数，到启动OK（即可以响应用户操作了）</span></h2><p style="margin-top: 10px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><span style="background-color: rgb(255, 255, 255);"><strong>这个步骤做了3件事情：</strong></span></p><ul style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>创建进程0，使之具备在主机中进行运算的能力，2.1</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>已进程0为母本创建进程1，不仅有运算能力，而且还能以文件的行驶与外设进行数据交互，2.2-2.4</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>以进程1为母本创建进程2，全面具备进程1的能力和环境，进一步具备支持“人机交互”，实现怠速，2.5-2.8</strong></span></li></ul><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">开中断之前的准备工作</span></h3><ol style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>复制根设备号和硬盘参数表</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>物理内存规划格局：除了1MB以内的内核区之外，其余物理内存要完成的工作是不同的，对这三类不同性质的区域，在大小，位置，以及管理方式上进行规划</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>“主内存区“：用来承载进程的相关信息，包括进程管理结构，进程对应的程序；</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>“缓冲区”：主机与外设进行数据交互的中转站</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>“虚拟盘区”：可选的区域，可将外设上的数据先复制到虚拟盘区，然后再使用。</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>虚拟盘设置与初始化：rd_init（某个设备请求的函数，对应到内核某块代码？？？？？）</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>内存管理结构mem_map初始化：mem_init,对于1MB以上的内存都是分页管理的。</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>异常处理类中断服务程序挂接：trap_init</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>初始化块设备请求项结构</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>与简历人机交互界面相关的外设的中断服务程序挂接</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>串行口设置</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>显示器设置</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>键盘设置</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>开机启动时间设置：进程0需要具备对时间的掌控能力，time_init()</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>系统开始激活进程0：sched_init函数开始</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>使其具备运算及创建其他进程的能力</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>时刻具备参与多进程轮询的能力</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>具备处理系统调用的能力</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程相关事务初始化设置：</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>“任务状态描述符表”和“局部数据描述符表”挂接到全局描述附表GDT中</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>对GDT和进程管理结构task[64]中除了与进程0相关的位置外，清空设置</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>将GDT中关于进程0的“任务状态描述符”和“局部数据描述符”分别记录在CPU中的“任务状态寄存器”和“局部数据寄存器”中。</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>时钟中断设置</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>系统调用服务程序挂接：set_system_gate与中断描述符表挂接</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>初始化缓冲区管理结构</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>初始化硬盘hd_init,hd_interrupt</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>初始化软盘floppy_init</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>开中断:<span style="margin: 0px; padding: 0px;">系统中所有中断服务程序都已经和中断描述附表正常挂接</span>，中断服务构建完毕，系统可以在32位保护模式下处理中断信号了。</strong></span></li></ol><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">进程创建的最基本动作</span></h3><ol style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>OS为进程0创建进程1做准备，</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>move_to_user_mode,从内核态转换到用户态</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>上述函数后，相当于进行了一次中断返回，CS特权级从0转换到3，内核→用户</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>用户态的进程0，从LDT去的代码段描述符，与弹出的EIP组成线性地址</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>调用fork函数</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>在进程槽中为进程1申请一个空闲位置并且获取进程号</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>find_empty_process，为进程1获得可用的进程号和空闲的任务号</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>全局变量last_pid存放系统开机以来累计的进程数。</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>内核的数据区中有个task[NR_TASKS]进程槽，存放task_struct指针。第一次遍历该数组，判断获得的进程号是否可用。ifyes,第二次遍历获得一个空的task_struct。linux0.11中，最多64个进程。</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>复制进程信息之前，先将一些数据压栈：将进程0的管理结构拷贝给进程1的管理结构</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>copy_process</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>初步设置进程1管理结构</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0的母本包括：“进程0的管理结构”，“进程0的页表项”</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0创建进程1的过程中发生时钟中断（场景分析）</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>中断服务程序开始工作，跳转到_timer_interrupt执行，xxx压入进程0内核栈，保护现场</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>_do_timer判断是否需要进程切换</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>从时钟中断返回</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>ret_from_sys_call开始执行</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>调整进程1管理结构</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0的管理结构数据信息不一定全都适用于进程1，还需针对具体情况调整。</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>设置进程1的线性地址空间及物理页面</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>创建页目录项和复制页表，从copy_mem开始</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>copy_page_tables</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>调整进程1管理结构</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>OS如何区分进程0和进程1</strong></span><ul style="margin: 0px 0px 0px 20px; padding: 0px;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>_syscall0函数中，if(res&gt;=0)这一行就是进程0中断返回后将要执行的第一行指令。。。</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>到底如何区分，我也没搞清楚。。。</strong></span></li></ul></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0准备切换到进程1</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>系统切换到进程1执行</strong></span></li></ol><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">加载根文件系统（进程1来完成；原文中均有流程图说明）</span></h3><ul style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1通过对一些与硬盘管理相关的数据结构进行设置，进一步为进程依托系统与硬盘以文件行驶进行数据交互创造条件</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程11用虚拟盘代替软盘，使之成为根设备</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1以虚拟盘中提供的数据为依据，加载根文件系统</strong></span></li></ul><hr style="margin: 0px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;" /><ol style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>开始执行：从_syscall0的if(__res&gt;=0)这行代码开始,然后调用init函数</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>开始执行：在init中，先调用setup</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1开始以数据块的形式操作硬盘</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>将找到的缓冲块与请求项挂接</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>将请求项与硬盘处理函数挂接</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进行硬盘读盘前的准备工作</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>给硬盘下达读盘指令</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1由于等待读盘操作挂起</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>系统切换到进程0执行</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0的执行过程</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程0执行过程中发生硬盘中断</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>硬盘中断服务程序响应后，进程0继续执行</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>再次响应硬盘中断并唤醒进程1</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>读盘操作完成后，进程1继续执行</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1继续设置硬盘管理结构</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1获取软盘超级块，为加载根文件系统做准备</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1备份超级快数据</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1将根文件系统从软盘拷贝到虚拟盘</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1开始加载根文件系统</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1准备根文件系统超级块</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1准备读取根目录i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1加载根目录i节点 1。进程1结束加载根文件系统的过程</strong></span></li></ol><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">打开中断设备文件及复制文件句柄</span></h3><ol style="margin: 10px 0px 0px 20px; padding: 0px; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 28px; text-align: justify;"><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1与内核文件表挂接，为打开文件做准备</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>确定打开操作的起点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>获得枝梢i节点-dev目录文件的i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>确定dev目录文件i节点为枝梢i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>继续返回枝梢i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>查找tty0文件的i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>将tty0设备文件的i节点返回给sys_open系统调用</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>分析tty0文件i节点</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>设置文件管理结构并返回给用户进程</strong></span></li><li style="margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255);"><strong>进程1复制tty0文件句柄</strong></span></li></ol><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">创建进程2</span></h3><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">进程1等待进程2退出</span></h3><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">shell程序的加载</span></h3><h3 style="margin: 10px 0px 0px; padding: 0px; font-size: 1.3em; font-family: HelveticaNeue-Light, 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, sans-serif; text-align: justify;"><span style="background-color: rgb(255, 255, 255);">系统实现怠速</span></h3>   &#13;
