
<p sizset="81" sizcache="22" style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="minor2.1" rel="nofollow" id="minor2.1"><span style="line-height: 28px;"><span style="font-size:18px;"><strong>Linux 2.6 中提供的几种文件访问方式</strong></span></span></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>所有的 I/O 操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器，都看成是文件系统中的文件。访问文件的方法多种多样，这里列出下边这几种 Linux 2.6 中支持的文件访问方式。</strong></span></p><p sizset="82" sizcache="22" style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="4.1.1. 标准访问文件的方式 |outline" rel="nofollow" id="4.1.1. 标准访问文件的方式 |outline"><span style="font-size:18px;"><strong>标准访问文件的方式</strong></span></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>在 Linux 中，这种访问文件的方式是通过两个系统调用实现的：read() 和 write()。当应用程序调用 read() 系统调用读取一块数据的时候，如果该块数据已经在内存中了，那么就直接从内存中读出该数据并返回给应用程序；如果该块数据不在内存中，那么数据会被从磁盘上读到页高缓存中去，然后再从页缓存中拷贝到用户地址空间中去。如果一个进程读取某个文件，那么其他进程就都不可以读取或者更改该文件；对于写数据操作来说，当一个进程调用了 write() 系统调用往某个文件中写数据的时候，数据会先从用户地址空间拷贝到操作系统内核地址空间的页缓存中去，然后才被写到磁盘上。但是对于这种标准的访问文件的方式来说，在数据被写到页缓存中的时候，write() 系统调用就算执行完成，并不会等数据完全写入到磁盘上。Linux 在这里采用的是我们前边提到的延迟写机制（ deferred writes ）。</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>图1.以标准方式对文件进行读写</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><img src="http://img.blog.csdn.net/20130609130352578" alt="" /><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"></p><p sizset="84" sizcache="22" style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="4.1.3. 同步访问文件的方式 |outline" rel="nofollow" id="4.1.3. 同步访问文件的方式 |outline"><span style="font-size:18px;"><strong>同步访问文件的方式</strong></span></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>同步访问文件的方式与上边这种标准的访问文件的方式比较类似，这两种方法一个很关键的区别就是：同步访问文件的时候，写数据的操作是在数据完全被写回磁盘上才算完成的；而标准访问文件方式的写数据操作是在数据被写到页高速缓冲存储器中的时候就算执行完成了。</strong></span></p><p style="font-size: 14px; line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><br /></p><span style="font-size:18px;"><strong> 图2.数据同步写回磁盘</strong></span><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><img src="http://img.blog.csdn.net/20130609130550515" alt="" /><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"></p><p sizset="86" sizcache="22" style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="4.1.5. 内存映射方式 |outline" rel="nofollow" id="4.1.5. 内存映射方式 |outline"><span style="font-size:18px;"><strong>内存映射方式</strong></span></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>在很多操作系统包括 Linux 中，内存区域（ memory region ）是可以跟一个普通的文件或者块设备文件的某一个部分关联起来的，若进程要访问内存页中某个字节的数据，操作系统就会将访问该内存区域的操作转换为相应的访问文件的某个字节的操作。Linux 中提供了系统调用 mmap() 来实现这种文件访问方式。与标准的访问文件的方式相比，内存映射方式可以减少标准访问文件方式中 read() 系统调用所带来的数据拷贝操作，即减少数据在用户地址空间和操作系统内核地址空间之间的拷贝操作。映射通常适用于较大范围，对于相同长度的数据来讲，映射所带来的开销远远低于 CPU 拷贝所带来的开销。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。</strong></span></p><br /><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>图3.利用mmap代替read</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><img src="http://img.blog.csdn.net/20130609130721218" alt="" /><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"></p><p sizset="88" sizcache="22" style="font-size: 14px; line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="4.1.7. 直接 I/O 方式 |outline" rel="nofollow" id="4.1.7. 直接 I/O 方式 |outline"><strong>直接 I/O 方式</strong></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>凡是通过直接 I/O 方式进行数据传输，数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，完全不需要页缓存的支持。操作系统层提供的缓存往往会使应用程序在读写数据的时候获得更好的性能，但是对于某些特殊的应用程序，比如说数据库管理系统这类应用，他们更倾向于选择他们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。</strong></span></p><br /><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>图四.数据传输不经过操作系统内核缓冲区</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><img src="http://img.blog.csdn.net/20130609130810890" alt="" /><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><br /></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"></p><p sizset="90" sizcache="22" style="font-size: 14px; line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><a name="4.1.9. 异步访问文件的方式 |outline" rel="nofollow" id="4.1.9. 异步访问文件的方式 |outline"><strong>异步访问文件的方式</strong></a></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>Linux 异步 I/O 是 Linux 2.6 中的一个标准特性，其本质思想就是进程发出数据传输请求之后，进程不会被阻塞，也不用等待任何操作完成，进程可以在数据传输的时候继续执行其他的操作。相对于同步访问文件的方式来说，异步访问文件的方式可以提高应用程序的效率，并且提高系统资源利用率。直接 I/O 经常会和异步访问文件的方式结合在一起使用。</strong></span></p><div><span style="font-size:18px;"><strong><br /></strong></span></div><span style="font-size:18px;"><strong>图5.CPU处理其他任务和I/O操作可以重叠进行</strong></span><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><img src="http://img.blog.csdn.net/20130609131010359" alt="" /><br /></p>   &#13;
