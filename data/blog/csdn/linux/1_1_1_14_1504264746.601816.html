
<pre name="code" class="cpp">1、定义
#include &lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
pid_t fork( void );</pre><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">pid_t 是一个宏定义，其实质是</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">int</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">，被定义在</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">#include&lt;sys/types.h&gt;</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">中</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">返回值：若成功调用一次则返回两个值，子进程返回</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">0</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">，父进程返回子进程</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">ID</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">；否则，出错返回</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">-1</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">2、函数说明：</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">一个现有进程可以调用</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">函数创建一个新进程。由</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">创建的新进程被称为子进程（</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">child process</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">）。</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">0</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">值而父进程中返回子进程</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">ID</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">。</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">子进程是父进程的副本，</span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;"><span color="#ff0000" style="margin: 0px; padding: 0px; color: rgb(255, 0, 0);">它将获得父进程数据空间、堆、栈等资源的副本</span></span></span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">File locks and pending signals are not inherited. </span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">【</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">3</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">】</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">If the call to fork() is executed successfully, Unix will</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 20pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">① </span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">make two identical copies of address spaces, one for the parent and the other for the child.</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 20pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">② </span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">Both processes will start their execution at the next statement following the fork() call.</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">3、为什么</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">会返回两次？</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">由于在复制时</span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;"><span color="#ff0000" style="margin: 0px; padding: 0px; color: rgb(255, 0, 0);">复制了父进程的堆栈段</span></span></span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">，所以两个进程都停留在</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">函数中，等待返回。因为</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="left" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">After a new child process is created, both processes will execute the next instruction following the fork() system call.</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">调用</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">之后，代码有两份，都从</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">fork</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">函数中返回。</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; text-indent: 24pt; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span color="#ff0000" style="margin: 0px; padding: 0px; color: rgb(255, 0, 0);"><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">Please note that Unix will make an exact copy of the parent's address space and give it to the child. Therefore, the parent and child processes have separate address spaces</span></span></span></span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px;">.</span></span></strong></span></span></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong>实例代码1：</strong></span></p><p></p><pre name="code" class="cpp">
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;

int main(int argc,char**argv)
{
    int pid=fork();
    if(pid == -1)
    {
        print("error!");
    }
    else if(pid == 0)
    {
        print("This is the child process!");
    }
    else
    {
        print("This is the parent process! child process id = %d", pid);
    }
    return 0;
}</pre><br /><span style="font-size:18px;"><strong>示例代码2：</strong></span><p></p><pre name="code" class="cpp">
#include  &lt;stdio.h&gt;
#include  &lt;string.h&gt;
#include  &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define   MAX_COUNT  200
#define   BUF_SIZE   100

void  main(void)
{
     pid_t  pid;
     int    i;
     char   buf[BUF_SIZE];

     fork();
     pid = getpid();
     for (i = 1; i &lt;= MAX_COUNT; i++) {
          sprintf(buf, "This line is from pid %d, value = %d\n", pid, i);
          write(1, buf, strlen(buf));
     } 
}</pre><br /><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">为什么用</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">write</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">，而不用</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">printf</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">呢？</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">because printf() is "buffered," meaning printf() will group the output of a process together</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">，这样，会把子进程和父进程的输出混起来。所以用</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">use the "unbuffered" write</span></span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">。</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;"><span style="font-size:18px;"><strong><br /></strong></span></span></span></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="margin: 0px; padding: 0px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">示例代码</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">3：</span></span></strong></span></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;"></span></span></span></p><pre name="code" class="cpp" style="font-size: 12pt;">
#include  &lt;stdio.h&gt;
#include  &lt;sys/types.h&gt;

#define   MAX_COUNT  200

void  ChildProcess(void);                /* child process prototype  */
void  ParentProcess(void);               /* parent process prototype */

int  main(void)
{
     pid_t  pid;

     pid = fork();
     if (pid == 0) 
          ChildProcess();
     else 
          ParentProcess();
    return 0;
}

void  ChildProcess(void)
{
     int   i;

     for (i = 1; i &lt;= MAX_COUNT; i++)
          printf("   This line is from child, value = %d\n", i);
     printf("   *** Child process is done ***\n");
}

void  ParentProcess(void)
{
     int   i;

     for (i = 1; i &lt;= MAX_COUNT; i++)
          printf("This line is from parent, value = %d\n", i);
     printf("*** Parent is done ***\n");
}</pre><br /><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">4、</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">Error Codes</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">出错返回错误信息如下</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">:</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">EAGAIN ：达到进程数上限</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">.</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;"><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">ENOMEM ：没有足够空间给一个新进程分配</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">.</span></span></span><span style="margin: 0px; padding: 0px;"></span></strong></span></p><p class="p0" align="justify" style="margin: 0pt; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 20px;"><span style="margin: 0px; padding: 0px;"><span style="font-size:18px;"><strong><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;"><span style="margin: 0px; padding: 0px;">fork()系统在</span></span><span style="margin: 0px; padding: 0px;"><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">Linux</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">中的返回值是没有</span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';">NULL</span><span face="宋体" style="margin: 0px; padding: 0px; font-family: 宋体;">的</span></span><span face="Times New Roman" style="margin: 0px; padding: 0px; font-family: 'Times New Roman';"><span style="margin: 0px; padding: 0px;">.</span></span></strong></span></span></p><br /><br />   &#13;
