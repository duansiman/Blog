
<p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:18px;line-height: 32px;"><span style="color:#0000ff;"><strong>如何查看进程发生缺页中断的次数</strong>？</span></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">         用ps -o majflt,minflt -C program命令查看。</span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">          <strong>majflt代表major fault，中文名叫<span style="color:#0000ff;">大错误</span>，minflt代表minor fault，中文名叫<span style="color:#0000ff;">小错误</span></strong>。</span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong>          这两个数值表示一个进程自启动以来所发生的<span style="color:#0000ff;">缺页中断的次数</span>。</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><strong><span style="font-size:18px;color:#0000ff;line-height: 32px;">发成缺页中断后，执行了那些操作？</span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><span style="font-size:14px;"><span style="color:#000000;"><span style="font-size:18px;line-height: 32px;"><strong>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作</strong>： </span><br /></span></span><strong>1、<span style="color:#ff0000;">检查要访问的虚拟地址是否合法 <br /></span>2、<span style="color:#ff0000;">查找/分配一个物理页 <br /></span>3、<span style="color:#ff0000;">填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）</span> <br />4、</strong><span style="color:#ff0000;"><strong>建立映射关系（虚拟地址到物理地址） <br /></strong></span>重新执行发生缺页中断的那条指令 <br /><strong><span style="color:#ff00ff;">如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。 </span></strong><br /></span><strong><span style="font-size:24px;color:#ff0000;line-height: 43px;"></span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><strong><span style="font-size:24px;color:#ff0000;line-height: 43px;">内存分配的原理</span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;">从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：<strong><span style="color:#0000ff;">brk和mmap（不考虑共享内存）。</span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><strong><span style="font-size:14px;line-height: 28px;">1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为<span style="color:#0000ff;">文件映射区域的地方</span>）找一块空闲的虚拟内存</strong>。</span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong>     这两种方式分配的都是<span style="color:#ff0000;">虚拟内存</span>，没有分配物理内存</strong>。<strong>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</strong></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><strong><br /></strong>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><br /><strong><span style="font-size:18px;color:#0000ff;line-height: 32px;">下面以一个例子来说明内存分配的原理：</span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-weight: bold;"><span style="color:#ff0000;"><span style="font-size:14px;line-height: 28px;"><span style="font-size:18px;color:#0000ff;line-height: 32px;">情况一、</span>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</span></span></span></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><strong><span style="color:#ff0000;"><span style="font-size:14px;line-height: 28px;"><img src="http://img.blog.csdn.net/20130625110751828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></span></span></strong></p><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-weight: bold;"><span style="color:#ff0000;"><span style="font-size:14px;line-height: 28px;"></span></span></span></p><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#0000ff;">1、</span></strong>进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。</span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">      其中，<strong>mmap内存映射文件是在堆和栈的中间</strong>（例如libc-2.2.93.so，其它数据文件等），为了简单起见，</span><span style="font-size:14px;line-height: 28px;">省略了内存映射文件。</span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">      <strong><span style="color:#0000ff;">_edata指针（glibc里面定义）指向数据段的最高地址。</span> <br /><span style="color:#0000ff;">2、</span></strong>进程调用A=malloc(30K)以后，内存空间如图2：</span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">      malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong>      你可能会问：</strong></span><span style="font-size:14px;line-height: 28px;"><span style="color:#ff0000;">只要把_edata+30K就完成内存分配了？</span></span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><span style="color:#ff0000;"></span>      事实是这样的，_edata+30K只是完成虚拟地址的分配，</span><span style="font-size:14px;line-height: 28px;">A这块内存现在还是没有物理页与之对应的，</span><span style="font-size:14px;line-height: 28px;">等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。</span><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#0000ff;">也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 <br /></span><span style="color:#0000ff;">3、</span></strong>进程调用B=malloc(40K)以后，内存空间如图3。</span></div><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;color:#ff0000;line-height: 28px;"><strong><span style="font-size:18px;color:#0000ff;line-height: 32px;">情况二、</span>malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：</strong></span></p><img src="http://img.blog.csdn.net/20130625110817750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-weight: bold;"><span style="color:#ff0000;"><span style="font-size:14px;line-height: 28px;"></span></span></span></p><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#0000ff;">4、</span></strong>进程调用C=malloc(200K)以后，内存空间如图4：</span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;">      默认情况下，<strong>malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，<span style="color:#0000ff;">而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存</span>。</strong></span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#ff0000;">      这样子做主要是因为::</span></strong></span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#ff0000;">      </span><span style="color:#0000ff;">brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候<span style="color:#ff0000;">紧缩</span>看下面），而mmap分配的内存可以单独释放。</span></strong></span></div><div style="line-height: 25px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-size:14px;line-height: 28px;"><strong><span style="color:#0000ff;">      </span></strong>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 <br /><strong><span style="color:#0000ff;">5、</span></strong>进程调用D=malloc(100K)以后，内存空间如图5；<br /><strong><span style="color:#0000ff;">6、</span></strong>进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。</span></div><img src="http://img.blog.csdn.net/20130625110835437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /><p style="line-height: 25px; margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 0px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53; font-size: 14px;"><span style="font-weight: bold;"><span style="color:#ff0000;"><span style="font-size:14px;line-height: 28px;"></span></span></span></p><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong><span style="color:#0000ff;">7、</span></strong>进程调用free(B)以后，如图7所示：</div><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong><span style="color:#ff0000;">        B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢</span></strong>？</div><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong><span style="color:#ff0000;">当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了</span></strong>。 <br /><strong><span style="color:#0000ff;">8、</span></strong>进程调用free(D)以后，如图8所示：</div><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong></strong><span style="color:#ff0000;"><strong>        B和D连接起来，变成一块140K的空闲内存。</strong></span></div><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong><span style="color:#0000ff;">9、</span></strong>默认情况下：</div><div style="line-height: 28px; color: rgb(105, 105, 105); font-family: Arial, Helvetica, simsun, u5b8bu4f53;font-size:14px;"><strong><span style="color:#ff0000;">       当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。</span></strong>在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</div><br />   &#13;
