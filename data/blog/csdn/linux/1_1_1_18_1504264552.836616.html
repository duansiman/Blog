
<p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);">Linux 内核简介</span></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>现在让我们从一个比较高的高度来审视一下 GNU/Linux 操作系统的体系结构。您可以从两个层次上来考虑操作系统，如图 2 所示。</strong></span></p><br style="font-family: Simsun;font-size:14px;" /><a name="figure2" style="font-family: Simsun;font-size:14px;" id="figure2"><span style="font-size: 0.76em; padding: 0.3em 5px 0.7em; font-family: arial, sans-serif;">图 2. GNU/Linux 操作系统的基本体系结构</span></a><br style="font-family: Simsun;font-size:14px;" /><img alt=" GNU/Linux &#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x7684;&#x57FA;&#x672C;&#x4F53;&#x7CFB;&#x7ED3;&#x6784;" height="250" src="http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/figure2.jpg" width="370" style="border: 0px; padding: 0.3em 5px 0.7em; font-family: Simsun;font-size:14px;" /><span style="font-family: Simsun;font-size:14px;"> </span><br style="font-family: Simsun;font-size:14px;" /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。 更多信息，请参看 <a href="http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/#resources" style="color: rgb(153, 102, 153);">参考资料</a> 一节中的链接。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 <code>read</code> 和 <code>write</code>。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);">Linux 内核的属性</span></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>在讨论大型而复杂的系统的体系结构时，可以从很多角度来审视系统。体系结构分析的一个目标是提供一种方法更好地理解源代码，这正是本文的目的。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);">Linux的主要子系统</span></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>现在使用图 3 中的分类说明 Linux 内核的主要组件。</strong></span></p><br style="font-family: Simsun;font-size:14px;" /><a name="figure3" style="font-size:14px; font-family: Simsun;" id="figure3"><span style="font-size: 0.76em; padding: 0.3em 5px 0.7em; font-family: arial, sans-serif;">图 3. Linux 内核的一个体系结构透视图</span></a><br style="font-family: Simsun;font-size:14px;" /><span style="padding-top: 0.3em; padding-bottom: 0.7em;"><img alt="Linux 内核的一个体系结构透视图" height="249" src="http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/figure3.jpg" width="319" style="border: 0px; padding: 0.3em 5px 0.7em; font-family: Simsun;font-size:14px;" /></span><span style="font-size:14px; font-family: Simsun;"> </span><br style="font-family: Simsun;font-size:14px;" /><p style="font-size: 0.76em; font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N100E7" id="N100E7"><span class="smalltitle" style="font-size: 1.2em; font-weight: bold;">系统调用接口</span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N100F4" id="N100F4"><span class="smalltitle"><span style="font-size:18px;"><strong>进程管理</strong></span></span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>进程管理的重点是进程的执行。在内核中，这些进程称为<em>线程</em>，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用<em>进程</em> 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。 O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N1010C" id="N1010C"><span class="smalltitle"><span style="font-size:18px;"><strong>内存管理</strong></span></span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的<em>内存页</em> 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为<em>交换</em>，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N10123" id="N10123"><span class="smalltitle"><span style="font-size:18px;"><strong>虚拟文件系统</strong></span></span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。</strong></span></p><br style="font-family: Simsun;font-size:14px;" /><a name="figure4" style="font-size:14px; font-family: Simsun;" id="figure4"><span style="font-size: 0.76em; padding: 0.3em 5px 0.7em; font-family: arial, sans-serif;">图 4. VFS 在用户和文件系统之间提供了一个交换层</span></a><br style="font-family: Simsun;font-size:14px;" /><span style="padding-top: 0.3em; padding-bottom: 0.7em;"><img alt="VFS 在用户和文件系统之间提供了一个交换层" height="295" src="http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/figure4.jpg" width="361" style="border: 0px; padding: 0.3em 5px 0.7em; font-family: Simsun;font-size:14px;" /></span><span style="font-size:14px; font-family: Simsun;"> </span><br style="font-family: Simsun;font-size:14px;" /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</strong></span></p><p style="font-size: 0.76em; font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N10141" id="N10141"><span class="smalltitle" style="font-size: 1.2em; font-weight: bold;">网络堆栈</span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N1014D" id="N1014D"><span class="smalltitle"><span style="font-size:18px;"><strong>设备驱动程序</strong></span></span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N10156" id="N10156"><span class="smalltitle"><span style="font-size:18px;"><strong>依赖体系结构的代码</strong></span></span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 i386 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</strong></span></p><br /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;color:#ff0000;"><strong>以上的内容来自：<a href="http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/">http://www.ibm.com/developerworks/cn/linux/l-linux-kernel/</a></strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;color:#ff0000;"><strong><br /></strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="background-color: rgb(255, 255, 0);"><span style="font-size:24px;"><strong>下面介绍内核缓冲区的内容：</strong></span></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:24px;"><strong style="background-color: rgb(255, 255, 0);">为什么总是需要将数据由内核缓冲区换到用户缓冲区或者相反呢？</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:24px;"><strong style="background-color: rgb(255, 255, 0);">答：<span style="font-family: song, Verdana; line-height: 22.390625px;">用户进程是运行在用户空间的，不能直接操作内核缓冲区的数据。 用户进程进行系统调用的时候，会由用户态切换到内核态，待内核处理完之后再返回用户态</span></strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><span style="font-weight: bold;"><span style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="word-wrap: break-word;">应</span></span></span><span style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;"><span style="word-wrap: break-word;"><span style="word-wrap: break-word;">用缓冲技术能很明显的提高系统效率</span>。内核与外围设备的数据交换，内核与用户空间的数据交换都是比较费时的，使用缓冲区就是为了优化这些费时的操作。其实核心到用户空间的操作本身是不buffer的，是由I/O库用buffer来优化了这个操作。比如read本来从内核读取数据时是比较费时的，所以一次取出一块，以避免多次陷入内核。</span><br style="word-wrap: break-word;" /><span style="word-wrap: break-word;"></span><span style="word-wrap: break-word;">      应用内核缓冲区的 <span style="word-wrap: break-word;">主要思想</span>就是<span style="color: rgb(229, 51, 51); word-wrap: break-word;">一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据</span><span style="color:#666666;">。</span></span><br style="word-wrap: break-word;" /><span style="color: rgb(102, 102, 102); word-wrap: break-word;">      </span><span style="word-wrap: break-word;">管理员模式和用户模式之间的切换需要消耗时间，但相比之下，<span style="word-wrap: break-word;">磁盘的I/O操作消耗的时间更多，为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度</span>。</span></span><span style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;"><span style="color: rgb(102, 102, 102); word-wrap: break-word;"><span style="word-wrap: break-word;"></span></span><span style="color: rgb(229, 51, 51); word-wrap: break-word;"><span style="word-wrap: break-word;"><span style="word-wrap: break-word;">磁盘是数据块 的集合，内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而 是将内核缓冲区中的数据复制到进程的缓冲区中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起，接着为其 他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程</span></span></span><span style="word-wrap: break-word;"><span style="color: rgb(229, 51, 51); word-wrap: break-word;">。</span><br style="word-wrap: break-word;" /><span style="word-wrap: break-word;"><span style="color:#666666;">     </span> 注：理解内核缓冲区技术的原理有助于更好的掌握系统调用read&amp;write，<span style="word-wrap: break-word;">read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换</span>。</span><br style="word-wrap: break-word;" /><span style="word-wrap: break-word;">      从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一 次写入。有时会导致意外情况，比如断电，内核还来不及把内核缓冲区中的数据写道磁盘上，这些更新的数据就会丢失。</span><br style="word-wrap: break-word;" /><span style="word-wrap: break-word;">      应用内核缓冲技术导致的结果是：提高了磁盘的I/O效率；优化了磁盘的写操作；需要及时的将缓冲数据写到磁盘。</span></span></span></span></span><br /></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><br /></p><br />   &#13;
