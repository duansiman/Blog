
<p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;color:#ff0000;"><strong>命令行参数</strong></span></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">在</span>C<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">中，</span>main<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">函数有很多的变种，比如</span></strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"></span></p><pre name="code" class="cpp"><span style="font-size:18px;"><strong>main(),
int main(),
int main(int argc, char *argv[]),
int main(int argc, char *argv[], char *env[])。</strong></span></pre><span style="font-size:18px;"><strong><br /></strong></span><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">在很长一段时间里（特别是在</span>windows<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">下），我都不清楚后面两种</span>main<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">函数中这么多参数有什么用，直到转到</span>linux<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">下，才明白了这些参数并不是多余的。</span></strong></span></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong>int main(int argc, char *argv[])。这两个参数也就是我们在命令行中跟在要执行程序名后面的参数。比如 ./necho hello world。参数的个数存储在argc中（在这个例子中是3，necho也算参数），参数的内容存储在argv指向的一个二维数组中（necho存储在二维数组中的第一个位置），参数名后面都以NULL结尾。</strong></span></p><p><a href="http://blog.chinaunix.net/attachment/201112/13/10231348_1323776443Z5j8.jpg" target="_blank"><span style="font-size:18px;color:#000000;"><strong><img src="http://blog.chinaunix.net/attachment/201112/13/10231348_1323776443Z5j8.jpg" load="imgResize(this, 650);" border="0" style="word-wrap: break-word; border: 0px;" alt="" /></strong></span></a></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">使用</span>argv[0]<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的一点小技巧</span></strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">在实际工作中，我们可以对一个程序创建多个不同名称的链接。当从不同名称的链接执行该程序时，我们在程序中可以通过</span>argv[0]<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">知道到底是哪个链接在执行该程序，这样我们就可以调用程序的不同部分来执行。这样做的好处是，同一个程序在不同链接名的调用下，表现出不同程序的特性。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">几种不使用</span>main<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">函数参数来获得命令行参数的用法（不可移植）：</span></strong></span></p><p><span style="font-size:18px;"><strong>1.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">在</span>linux<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">系统中，可以通过</span>/proc/PID/cmdline<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来获得命令行参数，但是参数之间的空格被忽略。比如上面例子中，如果</span>cat /proc/PID/cmdline <span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">将会得到</span>./nechohelloworld<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。如果在程序中可以通过下面代码来获得命令名：</span></strong></span></p><p><span style="font-size:18px;"><strong>       int fd = open(“/proc/self/cmdline”,  O_RDONLY);</strong></span></p><p><span style="font-size:18px;"><strong>       read(fd, buff, 100);</strong></span></p><p><span style="font-size:18px;"><strong>2.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">在</span>C<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">库中，为了使程序能知道命令的路径，提供了两个全局变量</span>program_invocation_name, program_invocation_short_name<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">（定义在</span>&lt;errno.h&gt;<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">，必须在程序中定义</span>_GNU_SOURCE<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">）。第一个全局变量提供了命令的完整路径，而第二个只提供了一个命令名。比如</span>/home/share/src/necho<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">和</span>necho<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span></strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">通常情况下，我们的命令行参数不会多到溢出，不过了解存储该参数的空间大小对编程也没什么坏处。我们可以通过</span>ARG_MAX<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">（定义在</span>&lt;limits.h&gt;<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">）</span><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">这个宏或者</span>sysconf(_SC_ARG_MAX)<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">系统调用来了解参数空间大小（该空间存储命令行参数和环境变量）。在</span>linux<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">系统上，</span>ARG_MAX<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">曾经被固定的设置为</span>32<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">个页的大小。但是从</span>2.6.32<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">起，该存储空间的大小被定义为</span>RLIMIT_STACK<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的四分之一。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;color:#ff0000;"><strong>环境变量</strong></span></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">每个进程都有相关联的环境列表（</span>Environment List<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">），环境列表由多个环境字符串组成。环境字符串被定义成</span>name=value<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">格式。</span>name<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">叫做环境变量（</span>Environment Variable<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">）。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">当一个进程被创建时，该进程继承父进程的环境列表。这个特性可以作为父进程和子进程通信的一种方法。比如，当父进程要创建子进程时，可以先设置某个环境变量，子进程随后在自己的环境列表中读取该环境变量。不过这种通信是单向的（</span>one-way<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">）和一次性的（</span>once-only<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">），子进程在创建后，就完全拥有和父进程独立环境列表了。程序可以通过检查环境变量来改变程序的特性</span>(<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">像使用命令行参数一样</span>)<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">环境变量通常在</span>shell<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">中使用，在</span>shell<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">中创建的进程都继承了</span>shell<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的环境列表。通常在</span>bash<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">下，我们像下面这样使用环境变量：</span></strong></span></p><p><span style="font-size:18px;"><strong>export SHELL = /bin/bash</strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;"><strong>如果只是想设置某一个程序的环境变量，可以这样使用：</strong></span></span></p><p><span style="font-size:18px;"><strong>name1=var1 name2=var2 nameN=varN program</strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">使用</span>printenv<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">显示当前的环境列表：</span></strong></span></p><p><span style="font-size:18px;"><strong>$printenv</strong></span></p><p><span style="font-size:18px;"><strong>SHELL=/bin/bash</strong></span></p><p><span style="font-size:18px;"><strong>HOME=/home/ddb</strong></span></p><p><span style="font-size:18px;"><strong>PATH=/usr/local/bin:/usr/bin:/bin:</strong></span></p><p><span style="font-size:18px;"><strong><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">可以通过</span>cat /proc/PID/environ<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来查看进程环境列表。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;color:#ff0000;"><strong>程序中如何使用环境列表</strong></span></span></p><p><span style="font-size:18px;"><strong>1.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">通过全局变量</span>char **environ<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span>environ<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">和</span>argv<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">很相似。也可以通过</span></strong></span></p><p><span style="font-size:18px;"><strong>int main(int argc, char *argv[], char *envp[])<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">中的</span>envp<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来访问。</span></strong></span></p><p><a href="http://blog.chinaunix.net/attachment/201112/13/10231348_1323776561LfMB.jpg" target="_blank"><span style="font-size:18px;color:#000000;"><strong><img src="http://blog.chinaunix.net/attachment/201112/13/10231348_1323776561LfMB.jpg" load="imgResize(this, 650);" border="0" style="word-wrap: break-word; border: 0px;" alt="" /></strong></span></a></p><p><span style="font-size:18px;"><strong>2.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">使用程序提供的</span>API<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span></strong></span></p><p><span style="font-size:18px;"><strong>char *getenv(const char *name)</strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;"><strong>注意点：</strong></span></span></p><p><span style="font-size:18px;"><strong>a.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">该函数返回指定环境变量的字符值。</span></strong></span></p><p><span style="font-size:18px;"><strong>b.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">不要直接修改返回值，因为在类</span>UNIX<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的大部分实现中，返回指针实际上是指向环境字符串中的</span>value<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">部分的。如果要改变该值，使用</span>setenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">或</span>putenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span></strong></span></p><p><span style="font-size:18px;"><strong>c.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">当程序得到一个返回指针后，要用一个私有</span>buff<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来保存该值。因为在某些实现中，该函数内部使用一个静态</span>buff<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来保存需要返回的值，这使得在下一次函数被调用后，静态</span>buff<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">中的值被其他值覆盖。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span style="font-size:18px;color:#ff0000;"><strong>int putenv(char *string)</strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;"><strong>注意点：</strong></span></span></p><p><span style="font-size:18px;"><strong>1.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">成功返回</span>-0<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">，失败返回</span>-<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">非</span>0<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">（不是</span>-1<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">）。</span></strong></span></p><p><span style="font-size:18px;"><strong>2.string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的格式为</span>”name=value”<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">。</span></strong></span></p><p><span style="font-size:18px;"><strong>3.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">不要把</span>string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">声明成自动变量，</span>string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">将成为环境列表的一部分，也就是说，该程序不会复制</span>string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">到环境列表中，而是把</span>string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">当做列表的一部分，当程序中改变</span>string<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">，会影响该进程的环境变量。</span></strong></span></p><p><span style="font-size:18px;"><strong>4.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">使用该函数通常是父进程想让它所创建的子进程继承某个改变的环境变量。或者是想让自己根据改变的环境变量来改变程序的特性（先改变某些环境变量，然后执行</span>exec()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">函数群来调用自己，程序重启，然后根据这些改变的环境变量来改变程序运行的特性）。</span></strong></span></p><p><span style="font-size:18px;"><strong>int setenv(const char *name, const char *value, int overwrite)</strong></span></p><p><span style="font-size:18px;"><strong>int unsetenv(const char *name)</strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;"><strong>注意点：</strong></span></span></p><p><span style="font-size:18px;"><strong>1.setenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">会创建一个新的</span>buff<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来存储参数“</span>name=value<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">“（跟</span>putenv<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">对比），我们没必要再</span>name<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">后面或</span>value<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">前面添加</span>”=”<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">号，因为在该函数中会自动添加。</span></strong></span></p><p><span style="font-size:18px;"><strong>2.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">只有在</span>overwrite<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">为非</span>0<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">，环境变量才会改变。</span></strong></span></p><p><span style="font-size:18px;"><strong> </strong></span></p><p><span style="font-size:18px;"><strong>#define _BSD_SOURCE</strong></span></p><p><span style="font-size:18px;"><strong>int clearenv(void)</strong></span></p><p><span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;"><span style="font-size:18px;"><strong>注意点：</strong></span></span></p><p><span style="font-size:18px;"><strong>1.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">该函数清除整个环境列表。也可以通过</span>environ=NULL<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">来清除。</span></strong></span></p><p><span style="font-size:18px;"><strong>2.<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">当该函数跟</span>setenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">一起使用时，会产生内存泄露。因为</span>clearenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">不会清除</span>setenv()<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">分配的内存。这两个函数不会频繁的调用，所有通常不是什么大问题。</span></strong></span></p><p><span style="font-size:18px;"><strong>ABI<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">的讨论</span></strong></span></p><p><span style="font-size:18px;"><strong>Application Binary Interface<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">是一组规则，它指定了一个二进制程序在运行时如何和内核、库交换信息。</span>ABI<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">指定了交换信息的寄存器和栈位置。一个</span>ABI<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">兼容的程序被编译后，它就可以在所有</span>ABI<span times="" new="" roman="" mso-hansi-font-family:="" style="word-wrap: break-word; font-family: 宋体;">兼容的系统上运行了。</span></strong></span></p><br />   &#13;
