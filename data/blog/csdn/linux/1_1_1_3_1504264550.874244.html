
<p><strong><span style="font-size:24px;">文件和目录管理</span></strong></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><strong><span style="font-size:24px;background-color: rgb(255, 255, 0);"><img alt="微笑" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" />一.文件与其元数据</span></strong></p><p></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>我们首先看一下一个简单的文本文件是怎么保存的：</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>打开vim，编辑一段文本：</strong></span></p><pre name="code" class="html">[root@localhost ~]# vim hello.txt</pre><br /><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>编辑内容如下：</strong></span></span><br /><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></p><pre name="code" class="html" style="font-size: 14px;">opencfg.com is best website for java </pre><br /><span style="font-size:18px;"><strong>查看其属性：</strong></span><p></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></p><pre name="code" class="html" style="font-size: 14px;">[root@localhost ~]# ls -l
-rw-r--r--  1 root root    37  9月  4 19:03 hello.txt</pre><br /><p></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>据这个例子的目的，是为了说明Linux系统中文件是由3个部分组成：</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>1.数据-data(编辑内容, opencfg.com is best websire for java)</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>2.元数据-metadata(当你用ls -l 命令 或者ll命令时，列出的信息就是元数据, 在Linux，Unix系统中，所有与文件相关的元数据都保存在一个被叫做inode的结构中)</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>3.文件名-directtory entry(也叫做目录项，保存文件名)</strong></span></p><p style="font-size: 14px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"> </p><p style="font-size: 14px; text-align: center; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><img src="http://dl.iteye.com/upload/picture/pic/98191/d6585f72-328f-3df6-9bdb-f2cdc831d45d.gif" height="395" width="528" alt="" style="border: 0px;" /></p><p style="font-size: 14px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"> </p><p style="font-size: 14px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"> </p><h2 style="line-height: 1.5em; margin: 0px 0px 0.5em; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif;"><span style="font-size:18px;background-color: rgb(204, 51, 204);">inode节点</span></h2><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>    在Linux、Unix文件系统中的每个文件都有一个相关的inode节点，保存了除文件名、文件内容(data)以外的所有文件信息，其中包括：</strong></span></p><h3 style="line-height: 25.1875px; margin: 0px 0px 0.5em; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif;"><span style="font-size:18px;background-color: rgb(204, 51, 204);">1.文件类型</span></h3><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>    在Linux、Unix文件系统内的任何东西，包括一般文件和目录、符号连接、设备节点、与进程间通信相关的 命名管道函数，套接字(socket)都是文件类型中的一种，下边列出了可能出现的文件类型：</strong></span></p><pre name="code" class="cpp" style="font-size: 14px;">Linux文件类型
文件类型	ls缩写	应用范围
常规文件	-	保存数据
目录	d	存放文件名
符号连接	l	指向其他文件
字符设备节点	c	访问设备
块设备节点	b	访问设备
命名管道函数	p	进程间通信
套接字	s	进程间通信
</pre><br /><span style="font-size:18px;"><strong><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;">这7种文件类型，具有相同的inode节点结构，他们具有相同的属性：所有者的身份、权限、修改时间、当使用命令ls -l 或者命令ll列出文件时，稳健类in个由第一个字符标识，该字符所对应的是上表中的缩写标记.</span><br /></strong></span><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><span style="background-color: rgb(204, 51, 204);">file命令</span></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>除了使用ls -l 与 ll 两个命令外，还可以使用file命令来查看文件的类型：</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>这里再写一个hello.sh:</strong></span></p><pre name="code" class="python" style="font-size: 14px;">#!/bin/sh

echo "hello"</pre><br /><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>下边使用file分别查看hello.txt与hello.sh，看看输出结果：</strong></span></span><br /><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></span></p><pre name="code" class="html" style="font-size: 14px;">[root@localhost ~]# file hello.txt 
hello.txt: ASCII text
[root@localhost ~]# file hello.sh 
hello.sh: POSIX shell script text executable</pre><br /><p></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>file命令可以深入文件内容，查看具体的文件类型，给出的描述比较清晰</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="font-size: 14px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="background-color: rgb(255, 255, 0);"> </span></p><h3 style="line-height: 25.1875px; margin: 0px 0px 0.5em; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif;"><span style="font-size:18px;background-color: rgb(255, 255, 0);">2. 所有者的身份与权限</span></h3><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>    每个常规文件、目录都所有者、组 和 三组访问权限： 读取、写入、执行，当使用ls -l 或者ll命令列出文件时，第一列显示权限(其中第一个字符表示文件类型缩写), 第三列显示用户所有者，第四列显示组。</strong></span></p><pre name="code" class="python" style="font-size: 14px;">[root@localhost ~]# ls -l
-rw-r--r--  1 root root    37  9月  4 19:03 hello.txt</pre><br /><pre name="code" class="cpp" style="font-size: 14px;">第一列是-rw-r--r--, 其中第一个字符是"-"，在缩写表中对应常规文件
                            以后的权限是rw-r--r--,表示权限
 
第二列是1              表示连接数，如果有硬连接到这个文件，这里的数值会+1，删除硬连接这里会-1
 
第三列是root         表示文件所有者是root
 
第四列是root         表示文件所有组是root
 
第五列是37           表示文件占用37字节
 
第六列是9月 4 19:03  默认表示文件最后的ctime, change-time
 
第七列是hello.txt   表示文件名</pre><br /><h3 style="line-height: 25.1875px; margin: 0px 0px 0.5em; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif;"><span style="font-size:18px;background-color: rgb(255, 255, 0);">3. 更多的inode信息</span></h3><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong> </strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>我们可以使用stat命令来查看文件更多的元数据信息：</strong></span></p><pre name="code" class="python" style="font-size: 14px;">[root@localhost ~]# stat hello.sh 
  File: "hello.sh"
  Size: 24              Blocks: 8          IO Block: 4096   普通文件
Device: fd00h/64768d    Inode: 149215      Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2011-09-04 20:41:02.153122391 +0800
Modify: 2011-09-04 20:40:59.160742070 +0800
Change: 2011-09-04 20:40:59.178744361 +0800</pre><br /><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"><strong>stat命令列出了更多的元数据信息：</strong></span></span><br /><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></span></span></p><pre name="code" class="cpp" style="font-size: 14px;">size   表示文件的理论长度，单位是字节
Block 与 IO Block 的乘积是文件所占的实际大小，在linux下文件所占的空间分配，最小的单位是块(Bolck)，而块的大小与块的数量，决定了文件实际占用的磁盘空间.
 
Device 表示内核对该设备的编号
Inode  是内核为每一个文件分配的标志
Links   表示文件名指向的inode节点的数量
Access:(0755/-rwxr-xr-x) 表示了访问权限，以及文件类型
uid:     表示了文件所有者，包括了系统为所有者分配的数值id
gid:     表示了文件组，包括了系统为组分配的数值id
 
接下来有三个时间通常被叫做文件的atime, ctime, mtime:
 
 
文件时间信息
缩写	全称	名称	描述
atime	access time	访问时间	文件数据每次被阅读后所记录的时间
ctime	change time	改变时间	文件的inode节点信息被改变后记录的时间
mtime	modify time	修改时间	文件内容数据被修改后记录的时间</pre><br /><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);"><strong><img alt="微笑" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" />二.链接</strong></span></span><p></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></span></span></p><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;"><strong>Linux 文件系统最重要的特点之一是它的文件链接。链接是对文件的引用，这样您可以让文件在文件系统中多处被看到。不过，在 Linux 中，链接可以如同原始文件一样来对待。链接可以与普通的文件一样被执行、编辑和访问。对系统中的其他应用程序而言，链接就是它所对应的原始文件。当您通过链接对文件进行编辑时，您编辑的实际上是原始文件。链接不是副本。有两种类型的链接：<span style="color:#ff0000;"><span style="padding: 0px; margin: 0px;">硬链接</span>和<span style="padding: 0px; margin: 0px;">符号链接(软链接)</span></span>。</strong></span></div><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;"><strong><span style="padding: 0px; margin: 0px;"></span> </strong></span></div><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;"><strong><span style="padding: 0px; margin: 0px;"><span style="color:#ff0000;">硬链接</span></span>只能引用同一文件系统中的文件。它引用的是文件在文件系统中的物理索引（也称为 inode）。当您移动或删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。硬链接的文件不需要用户有访问原始文件的权限，也不会显示原始文件的位置，这样有助于文件的安全。如果您删除的文件有相应的硬链接，那么这个文件依然会保留，直到所有对它的引用都被删除。</strong></span></div><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;"><strong><span style="padding: 0px; margin: 0px;"></span> </strong></span></div><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;"><strong><span style="padding: 0px; margin: 0px;"><span style="color:#ff0000;">符号链接(软链接)</span></span>是一个指针，指向文件在文件系统中的位置。符号链接可以跨文件系统，甚至可以指向远程文件系统中的文件。符号链接只是指明了原始文件的位置，用户需要对原始文件的位置有访问权限才可以使用链接。如果原始文件被删除，所有指向它的符号链接也就都被破坏了。它们会指向文件系统中并不存在的一个位置。</strong></span></div><div style="padding: 0px; margin: 0px; font-family: &#x5B8B;&#x4F53;, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-size:18px;color:#ff0000;"><strong>两种链接都可以通过命令 ln <source style="padding: 0px; margin: 0px;"><target style="padding: 0px; margin: 0px;">来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建符号链接。</target></source></strong></span></div><br /><p></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);"><strong><img alt="微笑" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" />三.带外通信--ioctl（）</strong></span></span><br /></span></span></span></span></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-size:18px;"></span></span></span></span></span></p><p style="word-wrap: break-word; margin-top: 1em; margin-bottom: 0.5em; padding-top: 0px; padding-bottom: 0px; font-family: verdana, sans-serif; line-height: 21px;"><span style=" color: rgb(102, 102, 102);"><strong> </strong></span><span style="font-size:18px;"><strong>什么是ioctl <br style="word-wrap: break-word;" /><span style="color: rgb(51, 102, 255); word-wrap: break-word;">    ioctl是设备驱动程序中对设备的I/O通道进行管理的函数</span><span style="color: rgb(102, 102, 102);"> </span>。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下： <br style="word-wrap: break-word;" />int ioctl(int fd, ind cmd, …)； <br style="word-wrap: break-word;" />    其中fd是用户程序打开设备时使用open函数返回的文件标示符，cmd是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。 <br style="word-wrap: break-word;" />    ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。</strong></span></p><p style="word-wrap: break-word; margin-top: 1em; margin-bottom: 0.5em; padding-top: 0px; padding-bottom: 0px; font-family: verdana, sans-serif; line-height: 21px;"><span style="font-size:18px;"><strong> ioctl的必要性 <br style="word-wrap: break-word;" />    如果不用ioctl的话，也可以实现对设备I/O通道的控制，但那是蛮拧了。例如，我们可以在驱动程序中实现write的时候检查一下是否有特殊约定的数 据流通过，如果有的话，那么后面就跟着控制命令（一般在socket编程中常常这样做）。但是如果这样做的话，会导致代码分工不明，程序结构混乱，程序员 自己也会头昏眼花的。所以，我们就使用ioctl来实现控制的功能。<span style="color: rgb(51, 102, 255); word-wrap: break-word;">要记住，用户程序所作的只是通过<span style="word-wrap: break-word; color: rgb(255, 0, 0);">命令码(cmd)</span> 告诉驱动程序它想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。</span></strong></span></p><span style="font-size:18px;"><strong>下面给出几个实用实例</strong></span><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></span></span></p><pre name="code" class="cpp">/*如下是获取网络设备的信息的程序*/
#include &lt;stdio.h&gt;   
#include &lt;unistd.h&gt;   
#include &lt;sys/ioctl.h&gt;   
#include &lt;sys/types.h&gt;   
#include &lt;stdlib.h&gt;   
#include &lt;sys/socket.h&gt;   
#include &lt;netinet/in.h&gt;   
#include &lt;arpa/inet.h&gt;   
#include &lt;net/if.h&gt;   
unsigned char g_eth_name[16];   
unsigned char g_macaddr[6];   
unsigned char g_subnetmask;   
unsigned char g_ipaddr;   
unsigned char g_broadcast_ipaddr;   
  
  
void init_net(void)   
{   
    int i;   
    int sock;   
    struct sockaddr_in sin;   
    struct ifreq ifr;   
  
    sock = socket(AF_INET,SOCK_DGRAM,0);   
    if (sock == -1)   
    {   
         perror("socket");   
    }   
       
    strcpy(g_eth_name,"eth0");   
    strcpy(ifr.ifr_name,g_eth_name);   
    printf("eth name:\t%s\n",g_eth_name);   
  
      
    if (ioctl(sock,SIOCGIFHWADDR,&amp;ifr) &lt; 0)   
    {   
         perror("ioctl");   
    }   
    memcpy(g_macaddr,ifr.ifr_hwaddr.sa_data,6);   
  
    printf("local mac:\t");   
    for (i=0;i&lt;5;i++)   
    {   
        printf("%.2x:",g_macaddr[i]);   
    }   
    printf("%.2x:\n",g_macaddr[i]);   
  
    //获取并打印IP地址   
    if (ioctl(sock,SIOCGIFADDR,&amp;ifr) &lt; 0)   
    {   
          perror("ioctl");   
    }   
    memcpy(&amp;sin,&amp;ifr.ifr_addr,sizeof(sin));   
    g_ipaddr = sin.sin_addr.s_addr;   
    printf("local eth0:\t%s\n",inet_ntoa(sin.sin_addr));   
  
    //获取并打印广播地址   
    if (ioctl(sock,SIOCGIFBRDADDR,&amp;ifr) &lt; 0)   
    {   
      perror("ioctl");   
    }   
    memcpy(&amp;sin,&amp;ifr.ifr_addr,sizeof(sin));   
    g_broadcast_ipaddr = sin.sin_addr.s_addr;   
    printf("broadcast:\t%s\n",inet_ntoa(sin.sin_addr));   
  
    //获取并打印子网掩码   
    if (ioctl(sock,SIOCGIFNETMASK,&amp;ifr) &lt; 0)   
    {   
        perror("ioctl");   
    }   
    memcpy(&amp;sin,&amp;ifr.ifr_addr,sizeof(sin));   
    g_subnetmask = sin.sin_addr.s_addr;   
    printf("subnetmask:\t%s\n",inet_ntoa(sin.sin_addr));   
  
    close(sock);   
}   
  
int main()   
{   
      
    init_net();   
      
    return 0;   
}  </pre><br /><span style="font-size:18px;"><strong>程序说明：程序先创建一个用于网络通信的套接字，然后利用ioctl对其操作，获取网络信息。程序中的函数net_ntoa用来将网络地址转换成字符串形式。<br /></strong></span><p></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><br /></span></span></span></span></p><p><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"><span style="font-family: Helvetica, Tahoma, Arial, sans-serif; line-height: 25.1875px;"></span></span></span></span></p><pre name="code" class="cpp">//调节音量 
#include &lt;sys/types.h&gt; 
#include &lt;sys/stat.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;sys/ioctl.h&gt; 
#include &lt;sys/soundcard.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;math.h&gt; 
#include &lt;string.h&gt; 
#include &lt;stdlib.h&gt; 
 
#define  BASE_VALUE 257 
 
int main(int argc,char *argv[]) 
{ 
        int mixer_fd=0; 
        char *names[SOUND_MIXER_NRDEVICES]=SOUND_DEVICE_LABELS; 
        int value,i; 
 
        //检查参数 
        if (argc&lt;3) 
        { 
                printf("\nusage:%s dev_no.[0..24] value[0..100]\n\n",argv[0]); 
                printf("eg. %s 0 100\n",argv[0]); 
                printf("    will change the volume to MAX volume.\n\n"); 
                printf("The dev_no. are as below:\n"); 
                for (i=0; i&lt;SOUND_MIXER_NRDEVICES; i++){ 
                        if (i%3==0) 
                                printf("\n"); 
                        printf("%s:%d\t\t",names[i], i); 
                } 
                printf("\n\n"); 
                exit(1); 
        } 
 
        //打开文件 
        if ((mixer_fd = open("/dev/mixer",O_RDWR))){ 
                printf("Mixer opened successfully,working...\n"); 
                value = BASE_VALUE*atoi(argv[2]); 
 
                //修改文件 
                if (ioctl(mixer_fd,  MIXER_WRITE(atoi(argv[1])), &amp;value)==0) 
                        printf("successfully....."); 
                else 
                        printf("unsuccessfully....."); 
                printf("done.\n"); 
         }else 
                printf("can't open /dev/mixer error....\n"); 
        exit(0); 
} </pre><p><br /></p><p><span style="font-size:18px;"><strong>下面这个程序用于打开光驱</strong></span></p><p></p><pre name="code" class="cpp">/*下面的程序会使用CDROMEJECT（由用户提供的参数）请求弹出CD-ROM设备的媒体托盘*/
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/cdrom.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
int fd,ret;
if(argc &lt; 2){
fprintf(stderr,"usage :%s &lt;device to eject&gt;\n", argv[0]);
return 1;
} 
/*
*以只读方式打开CD-ROM设备。O_NONBLOCK用于通知内核，
*即使设备中没有媒体，我们也要打开该设备
*/
fd = open(argv[1], O_RDONLY | O_NONBLOCK);
if(fd &lt; 0){
perror("open");
return 1;
}
/*给CD-ROM设备送出弹出命令*/
ret = ioctl(fd, CDROMEJECT, 0);
if(ret){
perror("ioctl");
return 1;
}
ret = close(fd);
if(ret){
perror("close");
return 1;
}
return 0;
}</pre><br /><br /><p></p><p><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);"><strong><img alt="微笑" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" />四.监视文件事件</strong></span></span></p><p><span style="background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong><span style="line-height: 26px; font-family: arial, nsimsun, sans-serif;">Inotify</span><span style="line-height: 26px; font-family: arial, nsimsun, sans-serif;"> 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。在实际项目中，如果项目带有配置文件，那么怎么让配置文件的改变和项目程序同步而不需要重启程序呢？一个明显的应用是：在一个程序中，使用Inotify监视它的配置文件，如果该配置文件发生了更改（更新，修改）时，Inotify会产生修改的事件给程序，应用程序就可以实现重新加载配置文件，检测哪些参数发生了变化，并在应用程序内存的一些变量做相应的修改。当然另一种方法可以是通过cgi注册命令，并通过命令更新内存数据及更新配置文件</span></strong></span></span><br /></p><p><span style="background-color: rgb(255, 255, 255);"><span style="line-height: 26px; font-family: arial, nsimsun, sans-serif;"></span></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>1．	Inotify 不需要对被监视的目标打开文件描述符，而且如果被监视目标在可移动介质上，那么在 umount 该介质上的文件系统后，被监视目标对应的 watch 将被自动删除，并且会产生一个 umount 事件。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>2．	Inotify 既可以监视文件，也可以监视目录。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>3．	Inotify 使用系统调用而非 SIGIO 来通知文件系统事件。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>4．	Inotify 使用文件描述符作为接口，因而可以使用通常的文件 I/O 操作select 和 poll 来监视文件系统的变化。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>Inotify 可以监视的文件系统事件包括：</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">IN_ACCESS，即文件被访问
IN_MODIFY，文件被 write
IN_ATTRIB，文件属性被修改，如 chmod、chown、touch 等
IN_CLOSE_WRITE，可写文件被 close
IN_CLOSE_NOWRITE，不可写文件被 close
IN_OPEN，文件被 open
IN_MOVED_FROM，文件被移走,如 mv
IN_MOVED_TO，文件被移来，如 mv、cp
IN_CREATE，创建新文件
IN_DELETE，文件被删除，如 rm
IN_DELETE_SELF，自删除，即一个可执行文件在执行时删除自己
IN_MOVE_SELF，自移动，即一个可执行文件在执行时移动自己
IN_UNMOUNT，宿主文件系统被 umount
IN_CLOSE，文件被关闭，等同于(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
IN_MOVE，文件被移动，等同于(IN_MOVED_FROM | IN_MOVED_TO)
注：上面所说的文件也包括目录。</pre><br /><p></p><p style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em; font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><a name="N1009A" style="color: rgb(76, 110, 148);" id="N1009A"><span class="atitle" style="font-size: 1.5em; font-weight: bold;">用户接口</span></a></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>在用户态，inotify 通过三个系统调用和在返回的文件描述符上的文件 I/ 操作来使用，使用 inotify 的第一步是创建 inotify 实例：</strong></span></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">int fd = inotify_init ();</pre><br /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>每一个 inotify 实例对应一个独立的排序的队列。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>文件系统的变化事件被称做 watches 的一个对象管理，每一个 watch 是一个二元组（目标，事件掩码），目标可以是文件或目录，事件掩码表示应用希望关注的 inotify 事件，每一个位对应一个 inotify 事件。Watch 对象通过 watch描述符引用，watches 通过文件或目录的路径名来添加。目录 watches 将返回在该目录下的所有文件上面发生的事件。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>下面函数用于添加一个 watch：</strong></span></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">int wd = inotify_add_watch (fd, path, mask);</pre><br /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>fd 是 inotify_init() 返回的文件描述符，path 是被监视的目标的路径名（即文件名或目录名），mask 是事件掩码, 在头文件 linux/inotify.h 中定义了每一位代表的事件。可以使用同样的方式来修改事件掩码，即改变希望被通知的inotify 事件。Wd 是 watch 描述符。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>下面的函数用于删除一个 watch：</strong></span></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">int ret = inotify_rm_watch (fd, wd);</pre><br /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>fd 是 inotify_init() 返回的文件描述符，wd 是 inotify_add_watch() 返回的 watch 描述符。Ret 是函数的返回值。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>文件事件用一个 inotify_event 结构表示，它通过由 inotify_init() 返回的文件描述符使用通常文件读取函数 read 来获得</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">struct inotify_event {
        __s32           wd;             /* watch descriptor */
        __u32           mask;           /* watch mask */
        __u32           cookie;         /* cookie to synchronize two events */
        __u32           len;            /* length (including nulls) of name */
        char            name[0];        /* stub for possible name */
};</pre><br /><p></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>结构中的 wd 为被监视目标的 watch 描述符，mask 为事件掩码，len 为 name字符串的长度，name 为被监视目标的路径名，该结构的 name 字段为一个桩，它只是为了用户方面引用文件名，文件名是变长的，它实际紧跟在该结构的后面，文件名将被 0 填充以使下一个事件结构能够 4 字节对齐。注意，len 也把填充字节数统计在内。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>通过 read 调用可以一次获得多个事件，只要提供的 buf 足够大。</strong></span></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;"> size_t len = read (fd, buf, BUF_LEN);</pre><br /><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>buf 是一个 inotify_event 结构的数组指针，BUF_LEN 指定要读取的总长度，buf 大小至少要不小于 BUF_LEN，该调用返回的事件数取决于 BUF_LEN 以及事件中文件名的长度。Len 为实际读去的字节数，即获得的事件的总长度。</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>可以在函数 inotify_init() 返回的文件描述符 fd 上使用 select() 或poll(), 也可以在 fd 上使用 ioctl 命令 FIONREAD 来得到当前队列的长度。close(fd)将删除所有添加到 fd 中的 watch 并做必要的清理。</strong></span></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">int inotify_init (void);
        int inotify_add_watch (int fd, const char *path, __u32 mask);
        int inotify_rm_watch (int fd, __u32 mask);</pre><br /><p><span style="font-size:18px;"><strong>取得事件队列的大小</strong></span></p><p><span style="font-size:18px;"><strong>未决事件队列的大小可有inotify实例的文件描述符上的FIONREAD ioctl 请求来取得。此请求的参数用于接收队列的大小（以字节为单位），这是一个无符号整数。</strong></span></p><p></p><pre name="code" class="cpp" style="font-weight: bold; font-size: 18px;">integer:
unsigned int queue_len;
int ret;
ret = ioctl(fd, FIONREAD, &amp;queue_len);
if(ret &lt; 0)
perror("ioctl");
else
printf("%u bytes pending in queue\n",queue_len);</pre><br /><span style="font-size:18px;"><strong>请注意，此请求所返回的是队列的大小（以字节为单位），而不是队列中事件的数目。一个程序可以根据inotify_event 结构已知的大小（由sizeof（）取得），从字节数目估算出时间数目，并且猜测出name字段的平均大小。然而，比较有用的是字节数目，因为这可让进程进行大小适当的读取操作。</strong></span><p></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong>销毁一个 inotify 实例</strong></span></p><p><span style=" font-size: 18px; font-family: arial, nsimsun, sans-serif;"><strong>销毁一个inotify 实例以及任何相关联的监视项目就如关闭该实例文件描述符一样简单：</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">int ret;
/*fd 经inotify_init() 取得*/
ret = close(fd);
if(fd == -1)
perror("close");</pre><br /><span style="font-size: 18px;"><strong>当然，如同任何的文件描述符一样，内核会自动关闭文件描述符，并且在进程结束时清理资源。</strong></span><p></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>下面给出一个实例：</strong></span></p><p style="font-family: arial, nsimsun, sans-serif; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"></p><pre name="code" class="cpp" style="color: rgb(51, 51, 51); font-weight: bold; font-size: 0.76em;">#include &lt;stdio.h&gt;//printf
#include &lt;string.h&gt; //strcmp
#include &lt;sys/inotify.h&gt;//inotify_init inotify_add_watch....
#include &lt;sys/select.h&gt;//select timeval
#include &lt;unistd.h&gt;//close

#define EVENT_SIZE  ( sizeof (struct inotify_event) )
#define BUF_LEN     ( 1024 * ( EVENT_SIZE + 16 ) )
#define ERR_EXIT(msg,flag)	{perror(msg);goto flag;}

int main( int argc, char **argv ) 
{
	int length, i = 0;
	int fd;
	int wd;
	char buffer[BUF_LEN];

	if((fd = inotify_init()) &lt; 0)
		ERR_EXIT("inotify_init",inotify_init_err);

	if( (wd = inotify_add_watch( fd, "/tmp",	IN_MODIFY | IN_CREATE | IN_DELETE ) ) &lt; 0)
		ERR_EXIT("inofity_add_watch", inotify_add_watch_err);
	
	fd_set rfd;
	struct timeval tv;
	tv.tv_sec = 0;
	tv.tv_usec = 10000;//10millsecond
	while(true)
	{
		int retval;
		FD_ZERO(&amp;rfd);
		FD_SET(fd, &amp;rfd);
		retval = select(fd + 1, &amp;rfd, NULL, NULL, &amp;tv);
		if(retval == 0) continue;
		else if(retval == -1)
			ERR_EXIT("select",select_err);

		// retval &gt; 0
		length = read( fd, buffer, BUF_LEN );  
		if(length &lt; 0)
			ERR_EXIT("read",read_err);

		//length &gt;= 0
		int i = 0;
		while ( i &lt; length ) 
		{
			struct inotify_event *event = ( struct inotify_event * ) &amp;buffer[ i ];
			if ( event-&gt;len ) 
			{
				if ( event-&gt;mask &amp; IN_CREATE ) 
				{
					if ( event-&gt;mask &amp; IN_ISDIR ) 
						printf( "The directory %s was created.\n", event-&gt;name );       
					else
						printf( "The file %s was created.\n", event-&gt;name );
					if(strcmp(event-&gt;name,"kill") == 0)
						ERR_EXIT("success exit",success_exit);

				}
				else if ( event-&gt;mask &amp; IN_DELETE ) 
				{
					if ( event-&gt;mask &amp; IN_ISDIR ) 
						printf( "The directory %s was deleted.\n", event-&gt;name );       
					else
						printf( "The file %s was deleted.\n", event-&gt;name );
				}
				else if ( event-&gt;mask &amp; IN_MODIFY ) 
				{
					if ( event-&gt;mask &amp; IN_ISDIR )
						printf( "The directory %s was modified.\n", event-&gt;name );
					else
						printf( "The file %s was modified.\n", event-&gt;name );
				}
			}else
			{
				//TODO
				//when only a file(not directory) is specified by add watch function, event-&gt;len's value may be zero, we can handle it here
			}
			i += EVENT_SIZE + event-&gt;len;
		}
	}
success_exit:
	( void ) inotify_rm_watch( fd, wd );
	( void ) close( fd );
	return 0;

read_err:
select_err:
inotify_add_watch_err:
	( void ) inotify_rm_watch( fd, wd );
inotify_init_err:
	( void ) close( fd );

	return -1;
}</pre><br /><p></p><p style="font-family: Arial; line-height: 26px; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>以上代码需要注意的地方：</strong></span></p><span style="font-size:18px;"><strong><span style="font-family: Arial; line-height: 26px;">1.如果在/tmp目录下touch kill文件，程序则会退出</span><span style="font-family: Arial; line-height: 26px;"></span></strong></span><p style="font-family: Arial; line-height: 26px; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>2.如果只有一个add watch 一个file,那么这个file的更改产生的event事件中event-&gt;len是为0，需要额外的处理，此代码省略了具体的处理过程，以注释代替</strong></span></p><p style="font-family: Arial; line-height: 26px; margin-top: 0px; margin-bottom: 0px; padding: 0.3em 5px 0.7em;"><span style="font-size:18px;"><strong>3.如果监测的是文件或目录的更改，使用 echo "xxx" &gt;&gt; file，会产生一个event事件，而使用echo "xxx" &gt; file 会产生两个event事件，查了相关的资料，可能是因为后者需要先清空file文件内容，造成第一次event事件，再将xxx写入file保存，造成了第二次的event事件。</strong></span></p><br /><br /><br /><p></p>   &#13;
