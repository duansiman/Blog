
<p><span style="font-size:18px;"><strong>这一章的主题是--缓冲式I/O</strong></span></p><p></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size:18px;"><strong><br /></strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size:18px;"><strong>一，流与缓冲    </strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>   流I/O是由C语言的标准函数提供的，这些I/O可以替代系统中提供的read和write函数。事实上流I/O的内</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>部封装了这两个基本的文件读写系统调用。使用流I/O在某些程度上来讲要方便一些，这些I/O在效率上没有</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>特别大的差异。</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>       </strong></span><span style="line-height: 12.666666984558105px; font-size: 18px;"><strong> 基于流的操作最终会调用read或者write函数进行操作。为了使程序的运行效率最高，流对象通常会提</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="line-height: 12.666666984558105px; font-size: 18px;"><strong>供缓冲区，以减少调用系统I/O库函数的次数。</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>        基于流的I/O提供以下2种缓冲：</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>1，全缓冲：直到缓冲区填满，才调用系统I/O函数。对于读操作来说，直到读入的内容的字节数等于缓冲区大</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>小或者文件以经到达结尾，才进行I/O操作将外存文件内容读入缓冲区；对于写操作来说，直到缓冲区填满，</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>才进行实际的I/O操作将缓冲区内容写到外存文件中。磁盘文件通常是全缓冲的。</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong><br /></strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>2，行缓冲：直到遇到换行符\n才调用系统I/O函数。对于读操作来说，遇到换行符\n才进行I/O操作，将所</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>读内容写入缓冲区；对于写操作来说，遇到换行符\n才进行I/O操作，将缓冲区内容写到外存。由于缓冲区大</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>小是有限制的，所以当缓冲区填满时即使没有遇到\n，也同样会进行实际的I/O操作。标准输入stdin和标准</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>输出stdout都默认是行缓冲的。</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong><br /></strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>3，无缓冲：没有缓冲区，数据会立即读入或者输出到外存文件和设备上。标准出错stderr是无缓冲的，这样</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong>也能保证错误提示和输出能及时地反馈给用户，供用户排除错误。</strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size: 18px;"><strong><br /></strong></span></p><p style="margin: 10px auto; line-height: 12.666666984558105px; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="font-size:18px;"><strong>二，基于文件流的操作</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 12.666666984558105px;"><span style="font-size:18px;"><strong>常用函数：</strong></span></p><pre name="code" class="cpp"><span style="font-size:18px;"><strong>打开和关闭流

#include&lt;stdio.h&gt;

FILE*fopen(const char * restrict pathname,const char*restrict type);

FILE*fdopen(int fileds,const char*type);</strong></span></pre><span style="font-size:18px;"><strong><br /></strong></span><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>fopen函数的第一个参数表示需要打开的文件的路径，第二个参数表示打开的方式。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>fdopen函数用于在一个已经打开的文件上建立一个流，第一个参数是已打开文件的文件描述符，第二个参数是与fopen函数的第二个参数一样。只有一点不同的是，由于文件已经打开，所以fdopen函数不会再创建新文件，而且也不会将文件截短为0，这一点要热别注意，这两点在打开文件描述符的时候已经完成。</strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><span style="background-color: rgb(204, 51, 204);"><strong>Type说明如下：</strong></span></span></p><table border="1" cellspacing="0" cellpadding="0" align="left" style="text-align: center; color: rgb(0, 0, 0);"><tbody><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>type</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件类型</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>是否新建</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>是否清空</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>可读</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>可写</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>读写位置</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>r</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>r+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>w</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>w+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>a</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件结尾</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>a+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文本文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件结尾</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>rb</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>r+b或rb+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>wb</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>w+b或wb+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件开头</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>ab</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件结尾</strong></span></p></td></tr><tr><td valign="top"><p align="center"><span style="font-size:18px;"><strong>a+b或ab+</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>二进制文件</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>NO</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>YES</strong></span></p></td><td valign="top"><p align="center"><span style="font-size:18px;"><strong>文件结尾</strong></span></p></td></tr></tbody></table><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><p style="text-align: center;"><span style="font-size:18px;"><strong> </strong></span></p><div style="text-align: center;"><span style="font-size:18px;"><strong><br /></strong></span></div><div style="text-align: center;"><span style="font-size:18px;"><strong><br /></strong></span></div><p style="text-align: center;"><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong><br /></strong></span></p><p><span style="font-size:18px;"><strong><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"> Linux里用fclose函数关闭一个文件流，函数原型如下：</span><br /></strong></span></p><p><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong></strong></span></span></p><pre name="code" class="cpp">#include&lt;stdio.h&gt;

int fclose(FILE *fp);</pre><br /><p></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>如果执行成功，函数返回0，失败返回EOF，这个值在定义在stdio.h中，其值为-1。fclose函数关闭文件时，该函数会将保存在内存中未来得及写回到磁盘的文件内容写回到磁盘上。了解这一点很重要，如果没有调用fclose函数，就必 须等待内存中缓冲区被填满，由系统将其内容写回到磁盘上去。对于fclose函数是否需要检查返回值的问题困扰着许多程序员。虽然严格地说应该检查所有的 系统调用的返回值，并且进行错误处理，但对于fclose函数出错的几率很小，几乎为0.但如果去关闭一个网络环境中的远程文件，fclose函数就有可 能出错。由于fclose函数在关闭文件时会将缓冲区的内容写回到磁盘上，因此fclose函数实际是进行了一个写操作。在网络环境中，文件的内容是要通 过网络传输到目的主机上并写入磁盘上的。在这个传输过程中，如果网络链接出现问题或者传输数据出错，就会导致文件内容写入失败。这时fclose函数就会 出错。由此可知，<span style="color: rgb(255, 0, 0);">如果在本地关闭一个文件可以不用检查返回值；如果在网络环境中关闭一个文件，检查fclose函数的返回值是有必要的</span>。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>三，以字符为单位读写数据</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>       每次读写一个字符数据的I/O方式称为每次一个字符的I/O。Linux下使用fgetc函数获得一个字符，其函数原型如下：</strong></span></p><pre name="code" class="cpp">#include&lt;stdio.h&gt;

             int fgetc(FILE*fp);</pre><br /><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>函数如果执行成功则返回该字符的ASCLL值，如果执行失败，则返回EOF。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>Linux环境下使用fputc函数输出一个字符数据，函数原型如下：</strong></span></p><pre name="code" class="cpp">#include&lt;stdio.h&gt;

int fputc(int c,FILE*fp)</pre><br /><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>第一个参数表示想要输出的字符的ASCLL值（源），第二个参数表示想要输出的文件流（目的地）。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>四，以行为单位读写数据</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>      当输入内容遇到\n时则将流中\n之前的内容送到缓冲区中的I/O方式称为每一次行的I/O。Linux使用下列函数提供一次读入一行的功能。</strong></span></p><pre name="code" class="cpp">#include&lt;stdio.h&gt;

char*fgets(char *restrict buf,int n,FILE*restrict fp);

char*gets(char*);</pre><br /><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>fgets函数的第一个参数表示存放读入的缓冲区，第二个参数n表示读入的字符个数，此参数的最大值不能超过缓冲区的长度。fgets函数一直读，直到遇到\n为止，如果在n-1个字符內未遇到换行符，则只读入n-1个字符。最后一个字符用于存储字符串结束标志\0.需要注意的是fgets函数会将‘\n’换行符也读进缓冲区中，因此缓冲区的实际有效内容应该是缓冲区实际字节数（不包括‘\0’）减1.fgets函数的第三个参数是需要读入的流对象。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>          fgets函数的换回值有以下两种情况：1，成功读取一行，返回缓冲区的首地址。2，读取出错或者文件已经到达结尾则返回NULL。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>gets函数和fgets函数类似，该函数从标准输入流中读取一行并将其存入一个缓冲区，并不将‘\n’读进缓冲区中。gets函数的返回值和fgets相同。</strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>       Linux 环境下用fputs函数和puts函数实现输出一行字符串，其函数原型如下：</strong></span></p><pre name="code" class="cpp">#include&lt;stdio.h&gt;

int fputs(const char*restrict str,FILE *restrict fp);

int puts(const char*str);</pre><br /><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>puts函数的第一个参数表示存放输出内容的缓冲区，第二个参数表示要输出的文件。如果执行成功则返回输出的字节数，失败返回-1。puts函数用与向标准输出输出一行字符串，其参数和fputs函数的第一个参数相同，如果成功输出，则返回输出的字节数，失败则返回-1，值得注意的是，<span style="color: rgb(255, 0, 0);">虽然gets函数不读入\n，但是puts函数却输出\n。<span style="color: rgb(0, 0, 0);">fputs和puts函数都不输出字符串的结束符‘\0’。对于I/O来说，fputs函数和fgets函数的搭配是安全又可靠的。</span></span></strong></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>五，gets函数的漏洞</strong></span></span></span></p><p style="margin: 10px auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size:18px;"><strong>gets函数和fgets函数最大的不同是gets函数的缓冲区虽然由用户提供，但是用户无法指定其一次最多读入多少个字节的内容。这一点导致gets函数变成了一个危险的函数。</strong></span></span></span></p><span style="font-size:18px;"><strong>六，二进制I/O</strong></span><p><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><strong><span style="font-size:18px;"></span></strong></span></p><p style="color: rgb(51, 51, 51); font-family: tahoma, &#x5B8B;&#x4F53;; line-height: 22px;"><span style="background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong>把数据写到文件效率最高的方法是用二进制形式写入。二进制输出避免了在数值转换为字符串过程中所涉及的开销和精度损失。但二进制数据并非人眼所能阅读。所以该方法只有当数据被另一个程序按顺序读取时才能使用。</strong></span></span></p><p style="color: rgb(51, 51, 51); font-family: tahoma, &#x5B8B;&#x4F53;; line-height: 22px;"><span style="background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong>fread函数用于读取二进制数据，fwrite函数用于写入二进制数据。</strong></span></span></p><span style="color: rgb(51, 51, 51); font-family: tahoma, &#x5B8B;&#x4F53;; line-height: 22px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong>fread和fwrite</strong></span></span><br /><p><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="color: rgb(51, 51, 51); font-family: tahoma, 宋体; line-height: 22px;"><span style="font-size:18px;"><strong></strong></span></span></span></p><pre name="code" class="cpp" style="background-color: rgb(239, 239, 239);">1.fread()和fwirte函数原型

size_t fread(void  *buffer,size_t  size,size_t count,FILE  *stream);

size_t fwirte(void  *buffer,size_t  size,size_t count,FILE *stream);

2.buffer是一个指向用于保存数据的内存位置的指针，size是缓冲区中每个元素的字节数，count是读取或写入的元素数，当然stream是数据读取或写入的留。

3.函数的返回值是实际读取或写入的元素（并非字节数目）。如果输入过程中遇到了文件末尾或者输出过程中出现了错误，这个数字可能比请求的元素数目要小。</pre><span style="font-size:18px;"><strong><br /><span style="background-color: rgb(255, 255, 255);">注意和示例</span></strong></span><p></p><p><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; line-height: 19px;"><span style="font-family: tahoma, 宋体; line-height: 22px;"></span></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size: 18px;"><span style=" background-color: rgb(255, 255, 255);"><strong>在使用 fread 读二进制文件（png 图片）的时候， 发现读取到内存中的数据和 二进制文件中的数据不一致， 同样， 在  使用 fwrite 写二进制文件（png 图片）的时候， 发现写入到内存中的数据和 二进制文件中的数据和内存中的数据也不一致。 </strong></span></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><span style="background-color: rgb(255, 255, 255);"><strong>就是<span style="color: rgb(0, 0, 255); word-wrap: break-word;">在读写二进制文件的时候，必须确保文件的打开形式是以 二进制读写的形式打开的</span><span style="color:#666666;">， </span><span style="color: rgb(0, 0, 255); word-wrap: break-word;"> 即：文件的打开形式必须是 "rb", "wb" </span>要不然，读写数据的时候，就会出现错误。</strong></span></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"></p><pre name="code" class="cpp" style="background-color: rgb(239, 239, 239); color: rgb(102, 102, 102);"><span style="font-size:18px;"><strong>/*
* 函数说明: 写二进制文件
* 参数描述: _fileName, 文件名称
*           _buf, 要写的内存缓冲。
*           _bufLen, 内存缓冲的长度
*   返回值: 0, 成功
*           -1, 失败
*
*/
int writeFile(const STR* _fileName, void* _buf, int _bufLen)
{
    FILE * fp = NULL;
    if( NULL == _buf || _bufLen &lt;= 0 ) return (-1);

    fp = fopen(_fileName, "wb"); // 必须确保是以 二进制写入的形式打开

    if( NULL == fp )
    {
        return (-1);
    }

    fwrite(_buf, _bufLen, 1, fp); //二进制写

    fclose(fp);
    fp = NULL;

    return 0;    
}

/*
 * 函数说明:  读二进制文件
*  参数描述: _fileName, 文件名称
*             _buf, 读出来的数据存放位置
*             _bufLen, 数据的长度信息
*    返回值:  0, 成功
*             -1, 失败
*
*/
int readFile(const char* _fileName, void* _buf, int _bufLen)
{
    FILE* fp = NULL;
    if( NULL == _buf || _bufLen &lt;= 0 ) return (-1);

    fp = fopen(_fileName, "rb"); // 必须确保是以 二进制读取的形式打开 

    if( NULL == fp )
    {
        return (-1);
    }

    fread(_buf, _bufLen, 1, fp); // 二进制读

    fclose(fp);
    return 0;        
}</strong></span></pre><span style="font-size:18px;background-color: rgb(239, 239, 239);"><strong><br /></strong></span><pre class="reply-text mb10" id="content-435996380" style="background-color: rgb(255, 255, 255); word-wrap: break-word; margin-top: 0px; margin-bottom: 10px; padding: 0px; line-height: 24px; orphans: 2; widows: 2; font-family: Arial; white-space: pre-wrap; zoom: 1;"><span style="font-size:18px;"><strong>fread函数和fwrite函数<span style="word-wrap: break-word; border-collapse: separate; font-family: Simsun; line-height: normal; white-space: normal; border-spacing: 0px;"><span style="word-wrap: break-word; font-family: Arial; line-height: 26px;"></span></span></strong></span><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>1.函数功能</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>  用来读写一个数据块。</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>2.一般调用形式</strong></span></p><p style="color: rgb(102, 102, 102); word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong> <span style="color:#0000ff;word-wrap: break-word;"> fread(buffer,size,count,fp);</span></strong></span></p><p style="color: rgb(102, 102, 102); word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="color:#0000ff;word-wrap: break-word;"><span style="font-size:18px;"><strong>  fwrite(buffer,size,count,fp);</strong></span></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>3.说明</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>  （1）buffer：是一个指针，对fread来说，它是读入数据的存放地址。对fwrite来说，是要输出数据的地址。</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>  （2）size：要读写的字节数；</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>  （3）count:要进行读写多少个size字节的数据项；</strong></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px;"><span style="font-size:18px;"><strong>  （4）fp:文件型指针。</strong></span></p><div><span style="font-size:18px;color: rgb(102, 102, 102);"><strong></strong></span><pre name="code" class="cpp" style="color: rgb(102, 102, 102);"><span style="font-size:18px;"><strong>#include &lt;string.h&gt;

#include &lt;stdio.h&gt;

int main(void)

{

   FILE *stream;

   char msg[] = "this is a test";

   char buf[20];

   if ((stream = fopen("DUMMY.FIL", "w+"))

       == NULL)

   {

      fprintf(stderr,

              "Cannot open output file.\n");

      return 1;

   }

   /* write some data to the file */

   fwrite(msg, strlen(msg)+1, 1, stream);

   /* seek to the beginning of the file */

   fseek(stream, SEEK_SET, 0);

   /* read the data and display it */

   fread(buf, 1, strlen(msg)+1, stream);

   printf("%s\n", buf);

   fclose(stream);

   return 0;

}</strong></span></pre><span style="font-size:18px;"><strong><span style="color:#666666;"><br /></span>刷新一个流--fflush</strong></span></div><div><span style="font-size:18px;"><strong><span style="font-family: 宋体, Arial; line-height: 26px;">函数名: fflush 　　</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">功 能: 清除文件缓冲区，文件以写方式打开时将缓冲区内容写入文件 　　</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">原型:int fflush(FILE *stream)</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">返回值： 　　</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">如果成功刷新,fflush返回0。指定的流没有缓冲区或者只读打开时也返回0值。返回EOF指出一个错误。 　　</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">注意:如果fflush返回EOF,数据可能由于写错误已经丢失。当设置一个重要错误处理器时,最安全的是用setvbuf函数关闭缓冲或者使用低级I/0例程,如open、close和write来代替流I/O函数。</span><span class="headline-content" style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;">fflush()函数</span><span style="font-family: 宋体, Arial; line-height: 26px;">fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃 　　</span><br style="word-wrap: break-word; font-family: 宋体, Arial; line-height: 26px;" /><span style="font-family: 宋体, Arial; line-height: 26px;">fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上 　　</span><br /></strong></span></div><div><span style="font-family: 宋体, Arial; line-height: 26px;"><span style="font-size:18px;"><strong>实例：</strong></span></span></div><div><span style="font-family: 宋体, Arial; line-height: 26px;"><span style="font-size:18px;"><strong></strong></span></span><pre name="code" class="cpp" style="color: rgb(102, 102, 102);">#include &lt;string.h&gt; 
　　#include &lt;stdio.h&gt; 
　　#include &lt;conio.h&gt; 
　　#include &lt;io.h&gt; 
　　void flush(FILE *stream); 
　　int main(void) 
　　{ 
　　FILE *stream; 
　　char msg[] = "This is a test"; 
　　/* create a file */ 
　　stream = fopen("DUMMY.FIL", "w"); 
　　/* write some data to the file */ 
　　fwrite(msg, strlen(msg), 1, stream); 
　　clrscr(); 
　　printf("Press any key to flush\ 
　　DUMMY.FIL:"); 
　　getch(); 
　　/* flush the data to DUMMY.FIL without\ 
　　closing it */ 
　　flush(stream); 
　　printf("\nFile was flushed, Press any key\ 
　　to quit:"); 
　　getch(); 
　　return 0; 
　　} 
　　void flush(FILE *stream) 
　　{ 
　　int duphandle; 
　　/* flush the stream's internal buffer */ 
　　fflush(stream); 
　　/* make a duplicate file handle */ 
　　duphandle = dup(fileno(stream)); 
　　/* close the duplicate handle to flush\ 
　　the DOS buffer */ 
　　close(duphandle); 
　　} </pre><span style="color:#666666;"><br /></span><span style="font-size:18px;"><strong><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 24.545454025268555px;">fflush 的返回值类型是int类型，那么这个int类型具体的返回是什么呢？ </span><span style="line-height: 24.545454025268555px;"><br style="line-height: 24.545454025268555px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;" /></span><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 24.545454025268555px;">　　返回值： </span><span style="line-height: 24.545454025268555px;"><br style="line-height: 24.545454025268555px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;" /></span><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 24.545454025268555px;">　　如果成功刷新,fflush返回0。指定的流没有缓冲区或者只读打开时也返回0值。返回EOF指出一个错误。 </span><span style="line-height: 24.545454025268555px;"><br style="line-height: 24.545454025268555px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;" /></span><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 24.545454025268555px;">　　注意:如果fflush返回EOF,数据可能由于写错误已经丢失。</span></strong></span><span style="color:#666666;"><br /></span></div><div><span style="font-family: 宋体, Arial; line-height: 26px;"><span style="font-size:18px;"><strong><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 24.545454025268555px;"><br /></span></strong></span></span></div></pre><span style="font-size:18px;"><span style="background-color: rgb(255, 255, 255);"><strong>下面介绍最后一个主题</strong></span></span><p></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><span style="background-color: rgb(255, 255, 255);"><strong>错误和EOF</strong></span></span></p><p style="word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-size:18px;"><span style="background-color: rgb(255, 255, 255);"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><strong>它是end of file的缩写，表示"文字流"（stream）的结尾。这里的"文字流"，可以是文件（file），也可以是标准输入（stdin）。</strong></span><br /></span></span></p><p style="text-align: center; word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong><img src="http://img.blog.csdn.net/20130606210326343" alt="" /><br /></strong></span></span></p><p style="text-align: left; word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;">比如，下面这段代码就表示，如果不是文件结尾，就把文件的内容复制到屏幕上。</span><br /></strong></span></span></p><p style="text-align: left; word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong></strong></span></span></span></p><pre name="code" class="cpp">　int c;

　　while ((c = fgetc(fp)) != EOF) {

　　　　putchar (c);

　　}</pre><br /><p></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>很自然地，我就以为，每个文件的结尾处，有一个叫做EOF的特殊字符，读取到这个字符，操作系统就认为文件结束了。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>但是，后来我发现，EOF不是特殊字符，而是一个定义在头文件stdio.h的常量，一般等于-1。</strong></span></p><pre name="code" class="cpp">　#define EOF (-1)</pre><br /><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>于是，我就困惑了。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>如果EOF是一个特殊字符，那么假定每个文本文件的结尾都有一个EOF（也就是-1），还是可以做到的，因为文本对应的ASCII码都是正值，不可能有负值。但是，二进制文件怎么办呢？怎么处理文件内部包含的-1呢？</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>这个问题让我想了很久，后来查了资料才知道，<span style="margin: 0px; padding: 0px;">在Linux系统之中，EOF根本不是一个字符，而是当系统读取到文件结尾，所返回的一个信号值（也就是-1）。</span>至于系统怎么知道文件的结尾，资料上说是通过比较文件的长度。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>所以，处理文件可以写成下面这样：</strong></span></p><pre name="code" class="cpp">int c;

　　while ((c = fgetc(fp)) != EOF) {

　　　　do something

　　}</pre><br /><span style="font-size:18px;"><strong><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;">这样写有一个</span><a href="http://www.cplusplus.com/reference/clibrary/cstdio/fgetc/" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 105, 214); line-height: 19px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;">问题</a><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;">。fgetc()不仅是遇到文件结尾时返回EOF，而且当发生错误时，也会返回EOF。因此，C语言又提供了feof()函数，用来保证确实是到了文件结尾。上面的代码feof()版本的写法就是：</span></strong></span><br /><p style="text-align: left; word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong></strong></span></span></span></span></p><pre name="code" class="cpp">int c;

　　while (!feof(fp)) {

　　　　c = fgetc(fp);

　　　　do something;

　　}</pre><br /><p></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>但是，这样写也有<a href="http://www.drpaulcarter.com/cs/common-c-errors.php#4.2" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 105, 214); line-height: inherit;">问题</a>。fgetc()读取文件的最后一个字符以后，C语言的feof()函数依然返回0，表明没有到达文件结尾；只有当fgetc()向后再读取一个字符（即越过最后一个字符），feof()才会返回一个非零值，表示到达文件结尾。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>所以，按照上面这样写法，如果一个文件含有n个字符，那么while循环的内部操作会运行n+1次。所以，最保险的<a href="http://www.geeksforgeeks.org/archives/9797" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 105, 214); line-height: inherit;">写法</a>是像下面这样：</strong></span></p><pre name="code" class="cpp">int c = fgetc(fp);

　　while (c != EOF) {

　　　　do something;

　　　　c = fgetc(fp);

　　}

　　if (feof(fp)) {

　　　　printf("\n End of file reached.");

　　} else {

　　　　printf("\n Something went wrong.");

　　}</pre><br /><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>除了表示文件结尾，EOF还可以表示标准输入的结尾。</strong></span></span><br /><p style="text-align: left; word-wrap: break-word; margin-top: 5px; margin-bottom: 5px; padding-top: 0px; padding-bottom: 0px; font-family: &#x5B8B;&#x4F53;, Arial; line-height: 26px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px; background-color: rgb(255, 255, 255);"><span style="font-size:18px;"><strong></strong></span></span></span></span></span></p><pre name="code" class="cpp">int c;

　　while ((c = getchar()) != EOF) {

　　　　putchar(c);

　　}</pre><br /><p></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>但是，标准输入与文件不一样，无法事先知道输入的长度，必须手动输入一个字符，表示到达EOF。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>Linux中，在新的一行的开头，按下Ctrl-D，就代表EOF（如果在一行的中间按下Ctrl-D，则表示输出"标准输入"的缓存区，所以这时必须按两次Ctrl-D）；Windows中，Ctrl-Z表示EOF。（顺便提一句，Linux中按下Ctrl-Z，表示将该进程中断，在后台挂起，用fg命令可以重新切回到前台；按下Ctrl-C表示终止该进程。）</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 19px;"><span style="font-size:18px;"><strong>那么，如果真的想输入Ctrl-D怎么办？这时必须先按下Ctrl-V，然后就可以输入Ctrl-D，系统就不会认为这是EOF信号。<a href="http://en.wikipedia.org/wiki/Ctrl-V" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 105, 214); line-height: inherit;">Ctrl-V</a>表示按"字面含义"解读下一个输入，要是想按"字面含义"输入Ctrl-V，连续输入两次就行了。</strong></span></p><span style="font-size:18px;"><strong><br /></strong></span><br />   &#13;
