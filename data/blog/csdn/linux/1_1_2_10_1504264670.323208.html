
<span style="font-size:18px;"><span style="font-weight: bold;"><span style="padding: 0px; margin: 0px; font-family: 宋体, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="padding: 0px; margin: 0px;"><span style="color:#ff0000;">逻辑地址</span>（Logical Address） </span>是指由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）。应用程序员仅需与逻辑地址打交道，而分段和分页机制对您来说是完全透明的，仅由系统编程人员涉及。应用程序员虽然自己可以直接操作内存，那也只能在操作系统给你分配的内存段操作。<br style="padding: 0px; margin: 0px;" /><br style="padding: 0px; margin: 0px;" /></span><span style="padding: 0px; margin: 0px; font-family: 宋体, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-family:宋体;padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;"><span style="color:#ff0000;">线性地址</span>（Linear Address）</span> 是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。Intel 80386的线性地址空间容量为4G（2的32次方即32根地址总线寻址）。<br style="padding: 0px; margin: 0px;" /><br style="padding: 0px; margin: 0px;" /></span></span></span></span></span><p><span style="padding: 0px; margin: 0px; font-family: 宋体, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-family: 宋体; padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;"><span style="font-size:18px;"><strong><span style="padding: 0px; margin: 0px;"><span style="color:#ff0000;">物理地址</span>（Physical Address）</span> 是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。</strong></span></span></span></span></p><p><span style="padding: 0px; margin: 0px; color: rgb(85, 85, 85); font-family: 宋体, 'Arial Narrow', arial, serif; font-size: 14px; line-height: 28px;"><span style="font-family:宋体;padding: 0px; margin: 0px;"><span style="color:#2f004a;padding: 0px; margin: 0px;"><br /></span></span></span></p><p><span style="padding: 0px; margin: 0px; font-family: 宋体, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-family: 宋体; padding: 0px; margin: 0px;"><span style="padding: 0px; margin: 0px;"></span></span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);"><strong>一、逻辑地址转线性地址</strong></span></span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="color: rgb(51, 51, 51); font-family: Calibri;">    </span>机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过<span style="font-family: Calibri;">MMU(CPU</span>中的内存管理单元<span style="font-family: Calibri;">)</span>转换成物理地址才能够被访问到。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">我们写个最简单的<span style="font-family: Calibri;">hello world</span>程序，用<span style="font-family: Calibri;">gccs</span>编译，再反编译后会看到以下指令：</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">mov    0x80495b0, %eax</span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">这里的内存地址<span style="font-family: Calibri;">0x80495b0 </span>就是一个逻辑地址，必须加上隐含的<span style="font-family: Calibri;">DS </span>数据段的基地址，才能构成线性地址。也就是说<span style="font-family: Calibri;"> 0x80495b0 </span>是当前任务的<span style="font-family: Calibri;">DS</span>数据段内的偏移。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">在<span style="font-family: Calibri;">x86</span>保护模式下，段的信息（段基线性地址、长度、权限等）即<strong>段描述符</strong>占<span style="font-family: Calibri;">8</span>个字节，段信息无法直接存放在段寄存器中（段寄存器只有<span style="font-family: Calibri;">2</span>字节）。<span style="font-family: Calibri;">Intel</span>的设计是段描述符集中存放在<span style="font-family: Calibri;">GDT</span>或<span style="font-family: Calibri;">LDT</span>中，而<strong>段寄存器存放的是段描述符在<span style="font-family: Calibri;">GDT</span>或<span style="font-family: Calibri;">LDT</span>内的索引值</strong><span style="font-family: Calibri;">(index)</span>。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><strong><span style="font-family: Calibri;">Linux</span>中逻辑地址等于线性地址</strong>。为什么这么说呢？因为<span style="font-family: Calibri;">Linux</span>所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从<span style="font-family: Calibri;"> 0x00000000 </span>开始，长度<span style="font-family: Calibri;">4G</span>，这样<span style="font-family: Calibri;"> </span>线性地址<span style="font-family: Calibri;">=</span>逻辑地址<span style="font-family: Calibri;">+ 0x00000000</span>，也就是说逻辑地址等于线性地址了。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">这样的情况下<strong><span style="font-family: Calibri;">Linux</span>只用到了<span style="font-family: Calibri;">GDT</span></strong>，不论是用户任务还是内核任务，都没有用到<span style="font-family: Calibri;">LDT</span>。<span style="font-family: Calibri;">GDT</span>的第<span style="font-family: Calibri;">12</span>和<span style="font-family: Calibri;">13</span>项段描述符是<span style="font-family: Calibri;"> __KERNEL_CS </span>和<span style="font-family: Calibri;">__KERNEL_DS</span>，第<span style="font-family: Calibri;">14</span>和<span style="font-family: Calibri;">15</span>项段描述符是<span style="font-family: Calibri;"> __USER_CS </span>和<span style="font-family: Calibri;">__USER_DS</span>。内核任务使用<span style="font-family: Calibri;">__KERNEL_CS</span>和<span style="font-family: Calibri;">__KERNEL_DS</span>，所有的用户任务共用<span style="font-family: Calibri;">__USER_CS </span>和<span style="font-family: Calibri;">__USER_DS</span>，也就是说不需要给每个任务再单独分配段描述符。内核段描述符和用户段描述符虽然起始线性地址和长度都一样，但<span style="font-family: Calibri;">DPL(</span>描述符特权级<span style="font-family: Calibri;">)</span>是不一样的。<span style="font-family: Calibri;">__KERNEL_CS </span>和<span style="font-family: Calibri;">__KERNEL_DS </span>的<span style="font-family: Calibri;">DPL</span>值为<span style="font-family: Calibri;">0</span>（最高特权），<span style="font-family: Calibri;">__USER_CS </span>和<span style="font-family: Calibri;">__USER_DS</span>的<span style="font-family: Calibri;">DPL</span>值为<span style="font-family: Calibri;">3</span>。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">用<span style="font-family: Calibri;">gdb</span>调试程序的时候，用<span style="font-family: Calibri;">info reg </span>显示当前寄存器的值：</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">cs             0x73     115</span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">ss             0x7b     123</span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">ds             0x7b     123</span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">es             0x7b     123</span></p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">可以看到<span style="font-family: Calibri;">ds</span>值为<span style="font-family: Calibri;">0x7b, </span>转换成二进制为<span style="font-family: Calibri;"> 00000000 01111011</span>，<span style="font-family: Calibri;">TI</span>字段值为<span style="font-family: Calibri;">0,</span>表示使用<span style="font-family: Calibri;">GDT</span>，<span style="font-family: Calibri;">GDT</span>索引值为<span style="font-family: Calibri;"> 01111</span>，即十进制<span style="font-family: Calibri;">15</span>，对应的就是<span style="font-family: Calibri;">GDT</span>内的<span style="font-family: Calibri;">__USER_DATA </span>用户数据段描述符。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;">从上面可以看到，<span style="font-family: Calibri;">Linux</span>在<span style="font-family: Calibri;">x86</span>的分段机制上运行，却通过一个巧妙的方式绕开了分段。</p><p style="font-size: 14px; font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">Linux</span>主要以分页的方式实现内存管理。</p><br /><p><span style="padding: 0px; margin: 0px; color: rgb(85, 85, 85); font-family: 宋体, 'Arial Narrow', arial, serif; line-height: 28px;"><span style="font-family: 宋体; padding: 0px; margin: 0px;"><span style="color: rgb(47, 0, 74); padding: 0px; margin: 0px;"></span></span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-size:24px;"><span style="background-color: rgb(255, 255, 0);">二、线性地址转物理地址</span></span></p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">前面说了<span style="font-family: Calibri;">Linux</span>中逻辑地址等于线性地址，那么线性地址怎么对应到物理地址呢？这个大家都知道，那就是通过分页机制，具体的说，就是通过页表查找来对应物理地址。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">准确的说分页是<span style="font-family: Calibri;">CPU</span>提供的一种机制，<span style="font-family: Calibri;">Linux</span>只是根据这种机制的规则，利用它实现了内存管理。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">在保护模式下，控制寄存器<span style="font-family: Calibri;">CR0</span>的最高位<span style="font-family: Calibri;">PG</span>位控制着分页管理机制是否生效，如果<span style="font-family: Calibri;">PG=1</span>，分页机制生效，需通过页表查找才能把线性地址转换物理地址。如果<span style="font-family: Calibri;">PG=0</span>，则分页机制无效，线性地址就直接做为物理地址。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">分页的基本原理是把内存划分成大小固定的若干单元，每个单元称为一页（<span style="font-family: Calibri;">page</span>），每页包含<span style="font-family: Calibri;">4k</span>字节的地址空间（为简化分析，我们不考虑扩展分页的情况）。这样每一页的起始地址都是<span style="font-family: Calibri;">4k</span>字节对齐的。为了能转换成物理地址，我们需要给<span style="font-family: Calibri;">CPU</span>提供<strong>当前任务的</strong>线性地址转物理地址的查找表，即页表<span style="font-family: Calibri;">(page table)</span>。注意，<strong>为了实现每个任务的平坦的虚拟内存，每个任务都有自己的页目录表和页表</strong>。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">为了节约页表占用的内存空间，<span style="font-family: Calibri;">x86</span>将线性地址通过页目录表和页表两级查找转换成物理地址。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><span style="font-family: Calibri;">32</span>位的线性地址被分成<span style="font-family: Calibri;">3</span>个部分：</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">最高<span style="font-family: Calibri;">10</span>位<span style="font-family: Calibri;"> Directory </span>页目录表偏移量，中间<span style="font-family: Calibri;">10</span>位<span style="font-family: Calibri;"> Table</span>是页表偏移量，最低<span style="font-family: Calibri;">12</span>位<span style="font-family: Calibri;">Offset</span>是物理页内的字节偏移量。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">页目录表的大小为<span style="font-family: Calibri;">4k</span>（刚好是一个页的大小），包含<span style="font-family: Calibri;">1024</span>项，每个项<span style="font-family: Calibri;">4</span>字节（<span style="font-family: Calibri;">32</span>位），项目里存储的内容就是<strong>页表的物理地址</strong>。如果页目录表中的页表尚未分配，则物理地址填<span style="font-family: Calibri;">0</span>。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">页表的大小也是<span style="font-family: Calibri;">4k</span>，同样包含<span style="font-family: Calibri;">1024</span>项，每个项<span style="font-family: Calibri;">4</span>字节，内容为最终物理页的物理内存起始地址。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><br /></p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;"><strong>每个活动的任务，必须要先分配给它一个页目录表，并把页目录表的物理地址存入<span style="font-family: Calibri;">cr3</span>寄存器。页表可以提前分配好，也可以在用到的时候再分配</strong>。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">还是以<span style="font-family: Calibri;"> mov    0x80495b0, %eax </span>中的地址为例分析一下线性地址转物理地址的过程。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">前面说到<span style="font-family: Calibri;">Linux</span>中逻辑地址等于线性地址，那么我们要转换的线性地址就是<span style="font-family: Calibri;">0x80495b0</span>。转换的过程是由<span style="font-family: Calibri;">CPU</span>自动完成的，<span style="font-family: Calibri;">Linux</span>所要做的就是准备好转换所需的页目录表和页表（假设已经准备好，给页目录表和页表分配物理内存的过程很复杂，后面再分析）。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">内核先将当前任务的页目录表的物理地址填入<span style="font-family: Calibri;">cr3</span>寄存器。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">线性地址<span style="font-family: Calibri;"> 0x80495b0 </span>转换成二进制后是<span style="font-family: Calibri;"> 0000 1000 0000 0100 1001 0101 1011 0000</span>，最高<span style="font-family: Calibri;">10</span>位<span style="font-family: Calibri;">0000 1000 00</span>的十进制是<span style="font-family: Calibri;">32</span>，<span style="font-family: Calibri;">CPU</span>查看页目录表第<span style="font-family: Calibri;">32</span>项，里面存放的是页表的物理地址。线性地址中间<span style="font-family: Calibri;">10</span>位<span style="font-family: Calibri;">00 0100 1001 </span>的十进制是<span style="font-family: Calibri;">73</span>，页表的第<span style="font-family: Calibri;">73</span>项存储的是最终物理页的物理起始地址。物理页基地址加上线性地址中最低<span style="font-family: Calibri;">12</span>位的偏移量，<span style="font-family: Calibri;">CPU</span>就找到了线性地址最终对应的物理内存单元。</p><p style="font-size: 14px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px;">我们知道<span style="font-family: Calibri;">Linux</span>中用户进程线性地址能寻址的范围是<span style="font-family: Calibri;">0 </span>－<span style="font-family: Calibri;"> 3G</span>，那么是不是需要提前先把这<span style="font-family: Calibri;">3G</span>虚拟内存的页表都建立好呢？一般情况下，物理内存是远远小于<span style="font-family: Calibri;">3G</span>的，加上同时有很多进程都在运行，根本无法给每个进程提前建立<span style="font-family: Calibri;">3G</span>的线性地址页表。<span style="font-family: Calibri;">Linux</span>利用<span style="font-family: Calibri;">CPU</span>的一个机制解决了这个问题。进程创建后我们可以给页目录表的表项值都填<span style="font-family: Calibri;">0</span>，<span style="font-family: Calibri;">CPU</span>在查找页表时，如果表项的内容为<span style="font-family: Calibri;">0,</span>则会引发一个缺页异常，进程暂停执行，<span style="font-family: Calibri;">Linux</span>内核这时候可以通过一系列复杂的算法给分配一个物理页，并把物理页的地址填入表项中，进程再恢复执行。当然进程在这个过程中是被蒙蔽的，它自己的感觉还是正常访问到了物理内存。</p><div style="font-size: 14px; text-align: center;"><img src="http://img.blog.csdn.net/20130616201608843" alt="" /></div>   &#13;
