
<h4 style="margin: 15px auto 2px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:18px;">简单归纳：fd只是一个整数，在open时产生。起到一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针filp。</span></h4><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>文件描述符的操作(如: open)返回的是一个文件描述符,内核会在每个进程空间中维护一个文件描述符表, 所有打开的文件都将通过此表中的文件描述符来引用; <br style="margin: 0px; padding: 0px;" />而流(如: fopen)返回的是一个FILE结构指针, FILE结构是包含有文件描述符的，FILE结构函数可以看作是对fd直接操作的系统调用的封装, 它的优点是带有I/O缓存</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>Linux支持各种各样的文件系统格式，如ext2、ext3、reiserfs、FAT、NTFS、iso9660等等，不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式，然而这些文件系统都可以<code style="margin: 0px; padding: 0px;">mount</code>到某个目录下，使我们看到一个统一的目录树，各种文件系统上的目录和文件我们用<code style="margin: 0px; padding: 0px;">ls</code>命令看起来是一样的，读写操作用起来也都是一样的，这是怎么做到的呢？Linux内核在各种不同的文件系统格式之上做了一个抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统看起来用起来都一样，这个抽象层称为虚拟文件系统（VFS，Virtual Filesystem）。上一节我们介绍了一种典型的文件系统在磁盘上的存储布局，这一节我们介绍运行时文件系统在内核中的表示。</strong></span></p><h5 style="margin: 15px auto 2px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;">3.1. 内核数据结构</span></h5><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>Linux内核的VFS子系统可以图示如下：</strong></span></p><p style="text-align: center; margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><a href="http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231814299707.png" style="margin: 0px; padding: 0px; color: black;"><span style="font-size:18px;"><strong><img title="33" border="0" alt="33" src="http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231814302772.png" width="413" height="416" style="margin: 0px; padding: 0px; border: 0px; background-image: none; display: inline;" /></strong></span></a></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><span style="margin: 0px; padding: 0px;">每个进程在PCB（Process Control Block）即进程控制块中都保存着一份文件描述符表，文件描述符就是这个表的索引，文件描述表中每个表项都有一个指向已打开文件的指针</span>，现在我们明确一下：已打开的文件在内核中用<code style="margin: 0px; padding: 0px;">file</code>结构体表示，文件描述符表中的指针指向<code style="margin: 0px; padding: 0px;">file</code>结构体。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>在<code style="margin: 0px; padding: 0px;">file</code>结构体中维护File Status Flag（<code style="margin: 0px; padding: 0px;">file</code>结构体的成员<code style="margin: 0px; padding: 0px;">f_flags</code>）和当前读写位置（<code style="margin: 0px; padding: 0px;">file</code>结构体的成员<code style="margin: 0px; padding: 0px;">f_pos</code>）。在上图中，进程1和进程2都打开同一文件，但是对应不同的<code style="margin: 0px; padding: 0px;">file</code>结构体，因此可以有不同的File Status Flag和读写位置。<code style="margin: 0px; padding: 0px;">file</code>结构体中比较重要的成员还有<code style="margin: 0px; padding: 0px;">f_count</code>，表示引用计数（Reference Count），后面我们会讲到，<code style="margin: 0px; padding: 0px;">dup</code>、<code style="margin: 0px; padding: 0px;">fork</code>等系统调用会导致多个文件描述符指向同一个<code style="margin: 0px; padding: 0px;">file</code>结构体，例如有<code style="margin: 0px; padding: 0px;">fd1</code>和<code style="margin: 0px; padding: 0px;">fd2</code>都引用同一个<code style="margin: 0px; padding: 0px;">file</code>结构体，那么它的引用计数就是2，当<code style="margin: 0px; padding: 0px;">close(fd1)</code>时并不会释放<code style="margin: 0px; padding: 0px;">file</code>结构体，而只是把引用计数减到1，如果再<code style="margin: 0px; padding: 0px;">close(fd2)</code>，引用计数就会减到0同时释放<code style="margin: 0px; padding: 0px;">file</code>结构体，这才真的关闭了文件。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>每个<code style="margin: 0px; padding: 0px;">file</code>结构体都指向一个<code style="margin: 0px; padding: 0px;">file_operations</code>结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中<code style="margin: 0px; padding: 0px;">read</code>一个文件描述符，<code style="margin: 0px; padding: 0px;">read</code>通过系统调用进入内核，然后找到这个文件描述符所指向的<code style="margin: 0px; padding: 0px;">file</code>结构体，找到<code style="margin: 0px; padding: 0px;">file</code>结构体所指向的<code style="margin: 0px; padding: 0px;">file_operations</code>结构体，调用它的<code style="margin: 0px; padding: 0px;">read</code>成员所指向的内核函数以完成用户请求。在用户程序中调用<code style="margin: 0px; padding: 0px;">lseek</code>、<code style="margin: 0px; padding: 0px;">read</code>、<code style="margin: 0px; padding: 0px;">write</code>、<code style="margin: 0px; padding: 0px;">ioctl</code>、<code style="margin: 0px; padding: 0px;">open</code>等函数，最终都由内核调用<code style="margin: 0px; padding: 0px;">file_operations</code>的各成员所指向的内核函数完成用户请求。<code style="margin: 0px; padding: 0px;">file_operations</code>结构体中的<code style="margin: 0px; padding: 0px;">release</code>成员用于完成用户程序的<code style="margin: 0px; padding: 0px;">close</code>请求，之所以叫<code style="margin: 0px; padding: 0px;">release</code>而不叫<code style="margin: 0px; padding: 0px;">close</code>是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，<code style="margin: 0px; padding: 0px;">read</code>、<code style="margin: 0px; padding: 0px;">write</code>等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的<code style="margin: 0px; padding: 0px;">file</code>结构体指向同一个<code style="margin: 0px; padding: 0px;">file_operations</code>结构体。如果打开一个字符设备文件，那么它的<code style="margin: 0px; padding: 0px;">read</code>、<code style="margin: 0px; padding: 0px;">write</code>操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以<code style="margin: 0px; padding: 0px;">file</code>结构体应该指向不同的<code style="margin: 0px; padding: 0px;">file_operations</code>结构体，其中的各种文件操作函数由该设备的驱动程序实现。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>每个<code style="margin: 0px; padding: 0px;">file</code>结构体都有一个指向<code style="margin: 0px; padding: 0px;">dentry</code>结构体的指针，“dentry”是directory entry（目录项）的缩写。我们传给<code style="margin: 0px; padding: 0px;">open</code>、<code style="margin: 0px; padding: 0px;">stat</code>等函数的参数的是一个路径，例如<code style="margin: 0px; padding: 0px;">/home/akaedu/a</code>，需要根据路径找到文件的inode。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个<code style="margin: 0px; padding: 0px;">dentry</code>结构体，只要沿着路径各部分的dentry搜索即可，从根目录<code style="margin: 0px; padding: 0px;">/</code>找到<code style="margin: 0px; padding: 0px;">home</code>目录，然后找到<code style="margin: 0px; padding: 0px;">akaedu</code>目录，然后找到文件<code style="margin: 0px; padding: 0px;">a</code>。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong>每个<code style="margin: 0px; padding: 0px;">dentry</code>结构体都有一个指针指向<code style="margin: 0px; padding: 0px;">inode</code>结构体。<code style="margin: 0px; padding: 0px;">inode</code>结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示<code style="margin: 0px; padding: 0px;">/home/akaedu/a</code>和<code style="margin: 0px; padding: 0px;">/home/akaedu/b</code>，它们都指向同一个inode，说明这两个文件互为硬链接。<code style="margin: 0px; padding: 0px;">inode</code>结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个<code style="margin: 0px; padding: 0px;">inode</code>结构体都有一个指向<code style="margin: 0px; padding: 0px;">inode_operations</code>结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。和<code style="margin: 0px; padding: 0px;">file_operations</code>不同，<code style="margin: 0px; padding: 0px;">inode_operations</code>所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各<code style="margin: 0px; padding: 0px;">inode</code>结构体可以指向同一个<code style="margin: 0px; padding: 0px;">inode_operations</code>结构体。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><code style="margin: 0px; padding: 0px;">inode</code>结构体有一个指向<code style="margin: 0px; padding: 0px;">super_block</code>结构体的指针。<code style="margin: 0px; padding: 0px;">super_block</code>结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。<code style="margin: 0px; padding: 0px;">super_block</code>结构体的<code style="margin: 0px; padding: 0px;">s_root</code>成员是一个指向<code style="margin: 0px; padding: 0px;">dentry</code>的指针，表示这个文件系统的根目录被<code style="margin: 0px; padding: 0px;">mount</code>到哪里，在上图的例子中这个分区被<code style="margin: 0px; padding: 0px;">mount</code>到<code style="margin: 0px; padding: 0px;">/home</code>目录下。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><code style="margin: 0px; padding: 0px;">file</code>、<code style="margin: 0px; padding: 0px;">dentry</code>、<code style="margin: 0px; padding: 0px;">inode</code>、<code style="margin: 0px; padding: 0px;">super_block</code>这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能<code style="margin: 0px; padding: 0px;">mount</code>到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是<code style="margin: 0px; padding: 0px;">rwxrwxrwx</code>，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><br /></strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;">     </span></strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;"><br /></span></strong></span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 18px;"><span style="font-size:18px;"><strong><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;">对于文件描述符的初识。APUE中是这样介绍文件描述符的（APUE  p59）：对于内核而言，所有打开的文件都通过文件描述符引用，文件描述符是一个非负整数，当打开一个现有或创建一个新的文件的时候，内核回想进程返回一个文件描述符，当读或者写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传递给read或write。</span><wbr style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"></wbr></strong></span></p><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong><br /></strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>       posix中，定义文件描述符0，1，2分别为：STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO.这些定义在&lt;unistd.h&gt;中。</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong><br /></strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>       关于文件描述符的优缺点：（来自维基百科）</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong><br /></strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>       优点：</strong></span></div><ul style="line-height: 27px; margin: 0.3em 0px 0px 1.6em; padding: 0px; list-style-type: square; font-family: sans-serif; text-align: -webkit-auto;"><li style="line-height: 22px; margin-bottom: 0.1em;"><span style="font-size:18px;"><strong>         基于文件描述符的<a title="I/O操作" class="new" rel="nofollow" href="http://zh.wikipedia.org/w/index.php?title=I/O%E6%93%8D%E4%BD%9C&amp;action=edit&amp;redlink=1" style="color: rgb(165, 88, 88); line-height: 27px; text-decoration: none; background-image: none;">I/O操作</a>兼容<a title="POSIX" rel="nofollow" href="http://zh.wikipedia.org/wiki/POSIX" style="color: rgb(11, 0, 128); line-height: 27px; text-decoration: none; background-image: none;">POSIX</a>标准。</strong></span></li><li style="line-height: 22px; margin-bottom: 0.1em;"><span style="font-size:18px;"><strong>         在UNIX、Linux的系统调用中，大量的系统调用都是依赖于文件描述符。</strong></span></li></ul><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;"><span style="font-size:18px;"><strong>        缺点：</strong></span></span><ul style="line-height: 22px; margin: 0.3em 0px 0px 1.6em; padding: 0px; list-style-type: square; font-family: sans-serif; text-align: -webkit-auto;"><li style="line-height: 27px; margin-bottom: 0.1em;"><span style="font-size:18px;"><strong>         在非UNIX/Linux<a title="操作系统" rel="nofollow" href="http://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" style="color: rgb(11, 0, 128); text-decoration: none; background-image: none;">操作系统</a>上(如Windows NT)，无法基于这一概念进行编程。</strong></span></li><li style="line-height: 27px; margin-bottom: 0.1em;"><span style="font-size:18px;"><strong>         由于文件描述符在形式上不过是个整数，当代码量增大时，会使编程者难以分清哪些整数意味着数据，那些意味着文件描述符。</strong></span></li></ul><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; text-align: -webkit-auto;"><span style="font-family:sans-serif;"><span style="line-height: 24px;"><span style="font-size:18px;"><strong>由于posix中定义的宏占用了0，1，2这三个文件描述符，所以，当调用能过返回文件描述符的系统调用时一般都是从3开始进行分配。</strong></span></span></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; text-align: -webkit-auto;"><span style="font-family:sans-serif;"><span style="line-height: 24px;"><span style="font-size:18px;"><strong><br style="line-height: 27px;" /></strong></span></span></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; text-align: -webkit-auto;"><span style="font-family:sans-serif;"><span style="line-height: 24px;"><span style="font-size:18px;"><strong><br style="line-height: 27px;" /></strong></span></span></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53; text-align: -webkit-auto;"><span style="font-family:sans-serif;"><span style="line-height: 24px;"><span style="font-size:18px;"><strong>以上只是对文件描述符的简单认识，其实一直很郁闷的是文件描述符只是一个int型的整数，如何通过它来对存在磁盘上的文件进行操作。通过进一步了解发现，其实在每个进程中都维护着一张文件描述符表，这张表中的文件描述符对应着一个文件指针，可以找到这个文件描述符所对应的文件，如果没有分配的文件描述符其所对应的指针为NULL。而文件指针中的inode成员便记录了该文件所对应的inode节点。</strong></span></span></span></div><span style="font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;"><span style="font-size:18px;"><strong>而很多系统调用都是通过对这个文件指针的操作来进行的。</strong></span></span><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong><br /></strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|--------|------------|                   |--------------------|</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|   fd    |文件指针 |-------------&gt; |  文件状态标志  |</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|--------|------------|                   |--------------------|                        </strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|--------|------------|                   |当前文件偏移量 |</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|   ...    |   ....        |                   |--------------------|</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>|--------|------------|                   |inode节点指针  |---------------------------&gt;|-----------------------------|</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>                                              |--------------------|                                    | inode节点信息            |</strong></span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"><span style="font-size:18px;"><strong>                                                                                                             |----------------------------|</strong></span></div><div><span style="font-size:18px;"><strong><br /></strong></span></div><br />   &#13;
