
<p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">引用百科</span></strong></p><p></p><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 28px; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;">组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 "组合对象" 的含义。</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 28px; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;"><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif;">有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构<a target="_blank" href="https://baike.baidu.com/item/%E8%A7%A3%E8%80%A6" style="color: rgb(19, 110, 194); text-decoration-line: none;">解耦</a>。</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif;"><br /></div></div><div class="para-title level-3" label-module="para-title" style="clear: both; zoom: 1; margin: 20px 0px 12px; line-height: 20px; color: rgb(51, 51, 51);"><h3 class="title-text" style="margin: 0px; padding: 0px;"><span style="font-family:FangSong_GB2312;font-size:18px;">涉及角色</span></h3></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">1.Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">2.Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">3.Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size: 18px; font-family: &quot;Microsoft YaHei&quot;, SimHei, Verdana; text-indent: 2em;">适用性</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"></span><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif;">以下情况下适用组合模式：</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif;">1．你想表示对象的部分-整体层次结构</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif;">2．你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</div></div><p><br /></p><p><span style="font-size:14px;">如：有个需求需求给一个连锁超市的用户会员卡积分进行累计计算，连锁超市即除了总店之外还有各地分店，用户在任意一个店面进行支付消费则会把产生的积分应用到所有超市店。</span></p><p><span style="font-size:14px;"><br /></span></p><p><br /></p><p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">具体实现</span></strong></p><p><img src="http://img.blog.csdn.net/20170922163136655" alt="" /><br /></p><p><br /></p><p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">相关代码：</span></strong></p><p><span style="font-size:14px;">1、定义<span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif;">Component 抽象类</span>MarketCommon</span></p><p></p><pre name="code" class="html">//超市会员卡积分抽象类
public abstract class MarketCommon {
	private String name;
	//积分
	private long cardScore;
	
	public void add(MarketCommon m){}
	public void remove(MarketCommon m){}
	public void pay(){}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public long getCardScore() {
		return cardScore;
	}
	public void setCardScore(long cardScore) {
		this.cardScore = cardScore;
	}
}</pre><br /><span style="font-size:14px;">2、创建具体实现</span><p></p><pre name="code" class="html">public class MarketBranchScore extends MarketCommon {
	public MarketBranchScore(String name) {
		super.setName(name);
	}
	//记录各个分店信息
	private List&lt;MarketCommon&gt; branchList = new ArrayList&lt;MarketCommon&gt;();
	
	public void add(MarketCommon m) {
		branchList.add(m);
	}

	public void remove(MarketCommon m) {
		branchList.remove(m);
	}

	public void pay() {
		for (MarketCommon card : branchList) {
			System.out.println(card.getName()+"消费累计积分："+card.getCardScore());
		}
	}
}</pre><br /><br /><p>3、客户端串接test</p><p></p><pre name="code" class="html">public class Client {

	private static void pay() {
		// 创建总店(总店也是分店的一种)
		MarketBranchScore leaderMark = new MarketBranchScore("总店");
		// 创建分店
		MarketBranchScore gzMark = new MarketBranchScore("广州分店");
		MarketBranchScore shMark = new MarketBranchScore("上海分店");
		// 消费
		gzMark.setCardScore(100);
		shMark.setCardScore(500);

		leaderMark.add(gzMark);
		leaderMark.add(shMark);
		// 刷卡支付时在各分店累计积分
		leaderMark.pay();
	}

	public static void main(String[] args) {
		pay();
	}
}</pre><br />通过以上代码简单实现了组合模式的应用，运行输出<p>广州分店消费累计积分：100<br />上海分店消费累计积分：500<br /></p><p><br /></p><p><span style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;"><span style="color:#454545;">这样在累积所有子店面积分的时候，就不需要去关心子店面的个数了，也不用关系是否是叶子节点还是组合节点了，也就是说不管是总店消费，还是分店消费，即：</span><u><span style="color:#ff0000;">将总店和所有分店组合当作一个整体</span></u><span style="color:#454545;">，都可以正确有效的计算出活动积分。</span></span><br /></p><p><span style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;"><span style="color:#454545;"><br /></span></span></p><p><span style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;"><span style="font-size:18px;color:#454545;"><span style="color: rgb(69, 69, 69); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;"><strong>结论：</strong></span></span></span></p><p><span style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;"><span style="color:#454545;"><span style="color: rgb(69, 69, 69); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;">“</span><span style="box-sizing: border-box; color: rgb(69, 69, 69); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px; padding: 0px; margin: 0px;">当发现需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式进行实现”<span style="color: rgb(69, 69, 69); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;">。</span></span><br /></span></span></p><p><span style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 16px;"><span style="color:#454545;"><br /></span></span></p><p><br /></p>   &#13;
