
        <div class="markdown_views"><h2 id="介绍">介绍</h2>

<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 <br />
原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>



<h2 id="优点">优点</h2>

<ol>
<li>性能提高。 </li>
<li>简化对象的创建</li>
</ol>



<h2 id="注意事项">注意事项</h2>

<ol>
<li>使用原型模式复制对象不会调用类的构造方法。</li>
<li>有深拷贝与浅拷贝。</li>
</ol>



<h2 id="结构图">结构图</h2>

<p><img src="http://img.blog.csdn.net/20170903150716803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzIzOTExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>



<h2 id="案例">案例</h2>

<p><strong>Prototype 类</strong></p>

<pre class="prettyprint"><code class=" hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> {</span>
    <span class="hljs-keyword">public</span> Prototype <span class="hljs-keyword">clone</span>(){
        Prototype prototype = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span>{
            prototype = (Prototype)super.<span class="hljs-keyword">clone</span>();
        }<span class="hljs-keyword">catch</span>(CloneNotSupportedException e){
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> prototype;
    }
}</code></pre>

<p><strong>ConcretePrototype 类</strong></p>

<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Prototype</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> show(){
        System.out.println(<span class="hljs-string">"原型模式实现类"</span>);
    }
}</code></pre>

<p><strong>Client类</strong></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Client {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        ConcretePrototype cp = <span class="hljs-keyword">new</span> ConcretePrototype();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++){
            ConcretePrototype clonecp = (ConcretePrototype)cp.clone();
            clonecp.show();
        }
    }
}</code></pre>

<p><img src="http://img.blog.csdn.net/20170903160049802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzIzOTExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>



<h2 id="浅克隆和深克隆">浅克隆和深克隆</h2>

<p><strong>浅克隆</strong></p>

<blockquote>
  <p>只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。</p>
</blockquote>

<p><strong>深克隆</strong></p>

<blockquote>
  <p>除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。</p>
</blockquote>

<p>说简单点就是复制值(浅克隆)还是引用(深克隆).深克隆还存在一个死循环的问题，所以需要多加注意。</p></div>&#13;
        <script type="text/javascript">&#13;
            $(function () {&#13;
                $('pre.prettyprint code').each(function () {&#13;
                    var lines = $(this).text().split('\n').length;&#13;
                    var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;
                    $(this).addClass('has-numbering').parent().append($numbering);&#13;
                    for (i = 1; i &lt;= lines; i++) {&#13;
                        $numbering.append($('&lt;li/&gt;').text(i));&#13;
                    };&#13;
                    $numbering.fadeIn(1700);&#13;
                });&#13;
            });&#13;
        </script>&#13;
   &#13;
