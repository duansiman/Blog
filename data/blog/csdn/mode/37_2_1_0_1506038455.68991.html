
<p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">引用百科</span></strong><br /></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><span style="white-space:pre">	</span>在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</span></p><p><span style="font-family: FangSong_GB2312; font-size: 18px;  text-indent: 2em; color: rgb(51, 51, 51);"><strong><br /></strong></span></p><p><span style="font-family: FangSong_GB2312; font-size: 18px;  text-indent: 2em; color: rgb(51, 51, 51);"><strong>基本信息</strong></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px;"></span></p><div class="para" label-module="para" style="word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-size: 14px; font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">共有两类适配器模式：</div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-size: 14px; font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 2em; word-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;"><span style="font-weight: 700;">类适配器模式</span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 2em; word-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">-- 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</div></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-size: 14px; font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-weight: 700;">对象适配器模式</span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-size: 14px; font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;">-- 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</span></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-size: 14px; font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family: &quot;ms shell dlg&quot;; text-indent: 2em;">模式所涉及的角色有：</span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;">　　●　　<strong>目标(Target)角色：</strong>所需要的结果。</p><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;">　　●　　<strong>源(OtherObject)角色：</strong>需要适配的角色。</p><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;">　　●　　<strong>适配器(Adaper)角色：</strong>适配器类是该模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;"><br /></p><span style="font-size: 14px;">如：有个需求是给某个目标类添加新方法method2，而目标类之前是只有一个方法method1的，即：最终实现结果就是提供两个方法method1和method2，并且在尽量不修改目标源方法的情况下实现。于是便可以用</span><strong><span style="font-size:18px;">适配器模式</span></strong><span style="font-size: 14px;">进行实现。</span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size: 14px;"><br /></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><p style="font-size: 14px; font-family: arial, 宋体, sans-serif;"></p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">类适配器模式实现：</span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><img src="http://img.blog.csdn.net/20170921161323549" alt="" /><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br />具体代码：</span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size:14px; font-family: FangSong_GB2312; text-indent: 2em;">1、定义最终提供目标方法</span><span style="font-size:14px; font-family: FangSong_GB2312; text-indent: 2em;">TargetInterface</span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size:14px; font-family: FangSong_GB2312; text-indent: 2em;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">下面给出的是目标角色的代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口新增了个个方法：method2()。而源角色<span style="color: rgb(51, 51, 51); font-family: &quot;ms shell dlg&quot;; font-size: 14px; text-indent: 24px;">OtherObject</span>是一个具体类，它有一个method2()方法，但是没有method1()方法。</span><br /></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><span style="font-size:14px;"></span></span><pre name="code" class="html">//目标方法
public interface TargetInterface {
	public String method2();
}</pre></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><span style="font-size:14px;">2、具体类：</span></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><span style="font-size:14px;"></span></span><pre name="code" class="html">//具体类
public class OtherObject {
	public String method1(){
		return "String";
	}
}</pre></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><span style="font-size:14px;">3、适配器：</span></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><span style="font-size:14px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">适配器角色Adapter扩展了<span style="color: rgb(51, 51, 51); font-family: FangSong_GB2312;font-size:18px; text-indent: 24px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">OtherObject</span></span>,同时又实现了目标(<span style="color: rgb(51, 51, 51); font-family: FangSong_GB2312;font-size:18px; text-indent: 24px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><span style="font-family: FangSong_GB2312;font-size:18px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">TargetInterface</span></span></span></span>)接口。由于<span style="color: rgb(51, 51, 51); font-family: &quot;ms shell dlg&quot;; font-size: 14px; text-indent: 24px;">OtherObject</span>没有提供method2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。</span><br /></span></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:18px;"><strong></strong></span><pre name="code" class="html">//适配器类
public class Adapter extends OtherObject implements TargetInterface {
	// 适配器实现OtherObject未实现的方法
	@Override
	public String method2() {
		return "";
	}
}</pre><span style="color: rgb(51, 51, 51); font-family: FangSong_GB2312; text-indent: 2em;"><span style="font-size:14px;">以上代码即是通过适配器模式实现了类的扩展！</span></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size: 24px; font-family: FangSong_GB2312; text-indent: 2em;"><br /></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family: FangSong_GB2312; text-indent: 2em;"><span style="font-size:18px;"><strong>对象配器模式实现</strong>：</span></span></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">　　与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到OtherObject类，而是使用委派关系连接到</span><span style="font-family: FangSong_GB2312;"><span style="font-size: 18px;">Adapter</span><span style="font-size: 14px;">类</span></span></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="color: rgb(51, 51, 51); text-indent: 24px;"><span style="font-family:FangSong_GB2312;font-size:18px;"><strong></strong></span></span><pre name="code" class="html">//具体类
public class OtherObject {
	public String method1() {
		return "String";
	}
}</pre><pre name="code" class="html">//适配器类
public class Adapter {

	//关联组合对象
	private OtherObject otherObject;

	public Adapter(OtherObject otherObject) {
		this.otherObject = otherObject;
	}

	/**
	 * 源类Adaptee有方法method1 因此适配器类直接委派即可
	 */
	public String method1() {
		return this.otherObject.method1();
	}

	// 适配器类需要补充此方法
	public void method2() {
		// TODO Auto-generated method stub

	}
}</pre><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;">从上图可以看出，OtherObject类并没有method2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个OtherObject的实例，从而此包装类能够把OtherObject的API与Target类的API衔接起来。Adapter与OtherObject是委派关系。</span></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="text-indent: 2em; font-family: FangSong_GB2312; font-size: 18px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;"></span></span><h3 style="font-size: 16px; border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><br /></h3></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><h3 style="font-size: 16px; border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><br /></h3></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size:18px;"><span style="text-indent: 2em; font-family: FangSong_GB2312;"><span style="font-family: &quot;ms shell dlg&quot;;"></span></span></span><h3 style="border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;">类适配器和对象适配器的对比</h3></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><h3 style="border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><span style="white-space: pre;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 16px; white-space: normal;"><span style="font-weight: normal;">1)</span></span><span style="font-weight: normal;"><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;;">类适配器</span><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;;">使用对象继承的方式，是静态的定义方式；而</span><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;;">对象适配器</span><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;;">使用对象组合的方式，是动态组合的方式。</span></span></span></h3></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><h3 style="border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><span style="white-space: pre;"><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;;"><span style="font-weight: normal;">2)</span></span></span></h3><span style="font-family: &quot;ms shell dlg&quot;;"></span><h3 style="border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><span style="white-space: pre;"><span style="font-size: 14px;"></span></span></h3><p style="word-wrap: break-word; margin: 10px auto; display: inline !important;"> <span style="font-weight: normal;">对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。</span></p><span style="font-family: &quot;ms shell dlg&quot;;"></span><h3 style="border-bottom: 1px dotted rgb(214, 214, 214); line-height: 1.5; margin: 10px 0px; display: inline !important;"><span style="white-space: pre;"><span style="font-size: 14px; font-family: &quot;ms shell dlg&quot;; font-weight: normal;"></span></span></h3><p style="word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><span style="font-weight: normal;">3) 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。</span></p><p style="word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><span style="font-weight: normal;">因此：</span></p><p style="word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; font-weight: normal;"><span style="white-space:pre">	</span><u><em>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。</em></u></span><br /></p><p style="word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><span style="font-family: &quot;ms shell dlg&quot;; font-size: 14px;"><u><em><br /></em></u></span></p></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="color: rgb(51, 51, 51); text-indent: 24px;"><span style="font-family: FangSong_GB2312;"><span style="font-family: &quot;ms shell dlg&quot;;"></span></span></span><div style="font-weight: bold; font-size: 14px;"><br /></div><h2 style="padding: 0px 0px 0px 20px; margin: 10px 0px; line-height: 1.5; display: inline !important;"><span style="font-size:18px;"><span style="font-family:FangSong_GB2312;">适配器模式的优点</span></span></h2></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-size: 10pt; text-indent: 2em;">1)更好的复用性</span></div><div class="para" label-module="para" style="text-align: left; color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;"><span style="font-weight: bold;">　</span>　系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</p><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;"><span style="font-size: 10pt; text-indent: 2em;">2)更好的扩展性</span></p><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;">　　在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能</p><p style="font-size: 14px; font-weight: bold; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;"><br /></p><h2 style="padding: 0px 0px 0px 20px; margin: 10px 0px; line-height: 1.5; display: inline !important;"><span style="font-family:FangSong_GB2312;font-size:18px;">适配器模式的缺点</span></h2><p style="font-size: 14px; word-wrap: break-word; margin: 10px auto; font-family: &quot;ms shell dlg&quot;;"><span style="font-weight: bold;">　　</span>过多的使用适配器，会让系统非常零乱，不易整体进行把握。如果需要适配的组件比较多，可以不使用适配器，而是直接对系统进行重构。</p><br /><br /></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:18px;"><strong><br /></strong></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:18px;"><strong><br /></strong></span></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></div><div class="para" label-module="para" style="color: rgb(51, 51, 51); word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><br /></div></div>   &#13;
