
<p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">引用百科</span></strong></p><p><span style="font-size:14px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;"><span style="white-space: pre;">	</span>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</span><br /></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;"><span style="font-size:14px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;">在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用</span><a target="_blank" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" style="color: rgb(19, 110, 194); text-decoration-line: none; font-family: arial, 宋体, sans-serif; text-indent: 28px;">面向对象</a><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;">的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。</span><br /></span></span></p><p><span style="color: rgb(51, 51, 51); font-size: 14px; text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-size: 14px; text-indent: 28px;"><span style="font-family:FangSong_GB2312;"><br /></span></span></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><span style="color: rgb(51, 51, 51); text-indent: 28px;"><span style="font-family:FangSong_GB2312;"><span style="color: rgb(85, 85, 85);"><span style="padding: 0px; margin: 0px;"><strong><span style="font-size:18px;">适用性：</span></strong></span></span><span style="color: rgb(85, 85, 85);"><br style="padding: 0px; margin: 0px;" /><span style="font-size:14px;">1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。 <br style="padding: 0px; margin: 0px;" />2<span style="color: rgb(85, 85, 85); text-indent: 28px;">）</span>设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。<br style="padding: 0px; margin: 0px;" /></span></span></span><span style="color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">3<span style="color: rgb(85, 85, 85); text-indent: 28px;">）</span>一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。 <br style="padding: 0px; margin: 0px;" />4<span style="color: rgb(85, 85, 85); text-indent: 28px;">）</span>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</span><br style="padding: 0px; margin: 0px;" /></span><br /></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; text-indent: 28px;"><strong><span style="font-size:18px;">如：</span></strong><u><span style="font-size:12px;">学校与学生的多纬度关系，一个城市可以有多所中学，例如初中、高中；每所中学都有男学生、女学生，如果要描述多个纬度的学生在上课，</span></u></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><u><span style="font-size:12px;">即：男学生，女学生在初中上课，同样男学生，女学生也可以在高中上课，至于各自的上课每个学生可以自由发挥，因此以上的业务可以考虑使用</span></u></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><u><span style="font-size:12px;">“桥接模式”来实现。</span></u></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="color:#333333;"></span></p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">如下关系结构：</span></strong><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><img src="http://img.blog.csdn.net/20170926102036846" alt="" /><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:FangSong_GB2312;font-size:18px;color:#333333;"><strong>具体代码：</strong></span></p><p style="text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif;"><span style="font-size:14px;">1、定义抽象</span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"></span></span></p><pre name="code" class="html">public abstract class School {
	Student student;
	//上课
	public void lesson(){}
}

public abstract class Student {
	//学习
	public void study(){}
}</pre><p></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><span style="white-space:pre">	</span><span style="font-size:14px;">2、具体实现</span><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"></span></span></p><pre name="code" class="html">public class HighSchool extends School {
	public void lesson() {
		this.student.study();
		System.out.println("高中上课!");
	}
}

public class MiddleSchool extends School {
	public void lesson() {
		this.student.study();
		System.out.println("初中上课!");
	}
}
</pre><p></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><pre name="code" class="html">public class BoyStudent extends Student {
	public void study() {
		System.out.print("男学生\t");
	}
}

public class GirlStudent extends Student {
	public void study() {
		System.out.print("女学生\t");
	}
}
</pre><br /><br /><span style="white-space:pre">	</span><span style="font-size:14px;">3、客户端Client</span><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"></span></span></p><pre name="code" class="html">public class Client {
	private static void study() {
		School middle = new MiddleSchool();
		middle.student = new BoyStudent();
		middle.lesson();
		middle.student = new GirlStudent();
		middle.lesson();

		School high = new HighSchool();
		high.student = new BoyStudent();
		high.lesson();
		high.student = new GirlStudent();
		high.lesson();
	}

	public static void main(String[] args) {
		study();
	}
}</pre><br /><br /><p></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size:14px;">运行</span></span></p><p style="text-indent: 28px;"><em><span style="font-size:14px;">男学生<span style="white-space:pre">	</span>初中上课!<br /> <span style="white-space:pre">	</span>女学生<span style="white-space:pre">	</span>初中上课!<br /><span style="white-space:pre">	</span>男学生<span style="white-space:pre">	</span>高中上课!<br /><span style="white-space:pre">	</span>女学生<span style="white-space:pre">	</span>高中上课!</span></em><br /></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="color: rgb(51, 51, 51); font-family: Verdana;"><strong><span style="font-size:18px;">桥接模式(Bridge)说明：</span></strong></span></span></p><p style="text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-family: Verdana;"><span style="font-size:14px;">1．Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</span></span></p><p style="text-indent: 28px;"><span style="font-family: arial, 宋体, sans-serif; color: rgb(51, 51, 51);"><span style="color: rgb(51, 51, 51); font-family: Verdana;"><span style="font-size:14px;">2．所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而实现不同学校的不同学生做不同的事</span></span></span></p><p style="text-indent: 28px;"><span style="font-family: arial, 宋体, sans-serif; color: rgb(51, 51, 51);"><span style="color: rgb(51, 51, 51); font-family: Verdana;"><span style="font-size:14px;">3．Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。</span></span></span></p><p style="text-indent: 28px;"><span style="font-family: arial, 宋体, sans-serif; color: rgb(51, 51, 51);"><span style="color: rgb(51, 51, 51); font-family: Verdana;"><span style="font-size:14px;">4．Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。</span></span><br /></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p><p style="text-indent: 28px;"><span style="font-family:arial, 宋体, sans-serif;color:#333333;"><span style="font-size: 14px;"><br /></span></span></p>   &#13;
