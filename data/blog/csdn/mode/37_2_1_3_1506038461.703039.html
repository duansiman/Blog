
<p><br /></p><p><span style="font-family: SimHei;"><strong><span style="font-size:24px;">概述：</span></strong></span></p><p><span style="font-family: SimHei;"><strong><span style="font-size:24px;"><br /></span></strong></span></p><p></p><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 28px; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 28px; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是<a target="_blank" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" style="color: rgb(19, 110, 194); text-decoration-line: none;">软件工程</a>的基石脉络，如同大厦的结构一样。</span></div><p><span style="font-family:FangSong_GB2312;"><span style="color: rgb(51, 51, 51); font-size: 14px; text-indent: 28px;"><span style="white-space:pre">	</span>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、</span><span style="color: rgb(51, 51, 51); font-size: 14px; text-indent: 28px;">保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块</span><span style="color: rgb(51, 51, 51); font-size: 14px;">砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断</span><span style="color: rgb(51, 51, 51); font-size: 14px;">重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</span></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px;"><br /></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><br /></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><strong><span style="font-family: SimHei;"><span style="font-size:24px;">设计原则：</span></span></strong></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><strong><span style="font-family: SimHei;"><span style="font-size:24px;"><br /></span></span></strong></span></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"></span></p><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面向对象有几个原则：<a target="_blank" href="https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99" style="color: rgb(19, 110, 194); outline: 0px;">单一职责原则</a> （Single Responsiblity Principle SRP）<a target="_blank" href="https://baike.baidu.com/item/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" style="color: rgb(19, 110, 194); text-decoration-line: none;">开闭原则</a>（Open Closed Principle，OCP）、<a target="_blank" href="https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99" style="color: rgb(19, 110, 194); text-decoration-line: none;">里氏代换原则</a>（Liskov Substitution Principle，LSP）、<a target="_blank" href="https://baike.baidu.com/item/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99" style="color: rgb(19, 110, 194); text-decoration-line: none;">依赖倒转原则</a>（Dependency Inversion Principle，DIP）、<a target="_blank" href="https://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99" style="color: rgb(19, 110, 194); text-decoration-line: none;">接口隔离原则</a>（Interface Segregation Principle，ISP）、合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、最小知识原则（Principle of Least Knowledge，PLK，也叫<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99" style="color: rgb(19, 110, 194); text-decoration-line: none;">迪米特法则</a>）。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;"><span style="text-indent: 2em;"><br /></span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;"><span style="text-indent: 2em;"><br /></span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="text-indent: 2em;"><strong><span style="font-family:SimHei;font-size:24px;">基本类型：</span></strong></span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">设计模式分为三种类型，共23种。</span></div><ul class="custom_dot  para-list list-paddingleft-1" style="margin: 0px 0px 15px 2em; padding: 0px; list-style: none; color: rgb(51, 51, 51);"><li class="list-dot list-dot-paddingleft" style="margin: 0px; padding: 0px; list-style: none;"><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; margin-bottom: 0px; line-height: 24px; zoom: 1; margin-left: 20px;"><span style="font-family:FangSong_GB2312;"><span style="font-weight: 700;">创建型模式</span>：单例模式、<a target="_blank" href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">抽象工厂模式</a>、建造者模式、工厂模式、原型模式。</span></div></li><li class="list-dot list-dot-paddingleft" style="margin: 0px; padding: 0px; list-style: none;"><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; margin-bottom: 0px; line-height: 24px; zoom: 1; margin-left: 20px;"><span style="font-family:FangSong_GB2312;"><span style="font-weight: 700;">结构型模式</span>：适配器模式、桥接模式、装饰模式、组合模式、外观模式、<a target="_blank" href="https://baike.baidu.com/item/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">享元模式</a>、代理模式。</span></div></li><li class="list-dot list-dot-paddingleft" style="margin: 0px; padding: 0px; list-style: none;"><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; margin-bottom: 0px; line-height: 24px; zoom: 1; margin-left: 20px;"><span style="font-family:FangSong_GB2312;"><span style="font-weight: 700;">行为型模式</span>：模版方法模式、命令模式、<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">迭代器模式</a>、<a target="_blank" href="https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">观察者模式</a>、中介者模式、备忘录模式、解释器模式（<a target="_blank" href="https://baike.baidu.com/item/Interpreter%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">Interpreter模式</a>）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</span></div></li></ul><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">按字典序排列简介如下。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Abstract Factory（<a target="_blank" href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">抽象工厂模式</a>）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Adapter（<a target="_blank" href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">适配器模式</a>）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Bridge（<a target="_blank" href="https://baike.baidu.com/item/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">桥接模式</a>）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Builder（<a target="_blank" href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">建造者模式</a>）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Chain of Responsibility（<a target="_blank" href="https://baike.baidu.com/item/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">责任链模式</a>）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Command（<a target="_blank" href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">命令模式</a>）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Composite（<a target="_blank" href="https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">组合模式</a>）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Decorator（<a target="_blank" href="https://baike.baidu.com/item/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">装饰模式</a>）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Facade（<a target="_blank" href="https://baike.baidu.com/item/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">外观模式</a>）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Factory Method（<a target="_blank" href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">工厂模式</a>）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Flyweight（<a target="_blank" href="https://baike.baidu.com/item/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">享元模式</a>）：运用共享技术有效地支持大量细粒度的对象。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Iterator（<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">迭代器模式</a>）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Mediator（<a target="_blank" href="https://baike.baidu.com/item/%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">中介模式</a>）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Memento（<a target="_blank" href="https://baike.baidu.com/item/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">备忘录模式</a>）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Observer（<a target="_blank" href="https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">观察者模式</a>）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Prototype（<a target="_blank" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">原型模式</a>）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Proxy（<a target="_blank" href="https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">代理模式</a>）：为其他对象提供一个代理以控制对这个对象的访问。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Singleton（<a target="_blank" href="https://baike.baidu.com/item/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">单例模式</a>）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">State（<a target="_blank" href="https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">状态模式</a>）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Strategy（<a target="_blank" href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">策略模式</a>）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;"><a target="_blank" href="https://baike.baidu.com/item/Template%20Method" style="color: rgb(19, 110, 194); text-decoration-line: none;">Template Method</a>（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</span></div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;">Visitor（<a target="_blank" href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">访问者模式</a>）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</span></div><br /><p></p>   &#13;
