
<p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">引用百科</span></strong></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><span style="white-space:pre">	</span>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</span><br /></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><br /></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><span style="font-family:FangSong_GB2312;font-size:18px;"><strong>特点</strong></span></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">（2） 装饰对象包含一个真实对象的引用（reference）</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><br /></div><strong><span style="font-family:FangSong_GB2312;font-size:18px;">使用场景</span></strong><p></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">1. 需要扩展一个类的功能，或给一个类添加附加职责。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><br /></div><strong><span style="font-family:FangSong_GB2312;font-size:18px;">相关角色</span></strong><p></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><p style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; word-wrap: break-word; margin: 10px auto;">　　●　　<strong>抽象构件(Component)角色：</strong>给出一个抽象接口，以规范准备接收附加责任的对象。</p><p style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; word-wrap: break-word; margin: 10px auto;">　　●　　<strong>具体构件(ConcreteComponent)角色：</strong>定义一个将要接收附加责任的类。</p><p style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; word-wrap: break-word; margin: 10px auto;">　　●　　<strong>装饰(Decorator)角色：</strong>持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</p><p style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; word-wrap: break-word; margin: 10px auto;">　　●　　<strong>具体装饰(<strong>Concrete</strong>Decorator)角色：</strong>负责给构件对象“贴上”附加的责任。</p><p style="font-family: &quot;ms shell dlg&quot;; font-size: 14px; word-wrap: break-word; margin: 10px auto;"><br /></p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">具体实现：</span></strong><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><img src="http://img.blog.csdn.net/20170929155528303" alt="" /><br /></span></strong></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;"><br /></span></strong></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><strong><span style="font-family:FangSong_GB2312;font-size:18px;">相关代码：</span></strong></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"><span style="font-family:FangSong_GB2312;font-size:14px;">1、抽象角色接口</span></span></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><pre name="code" class="html" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;">public interface Component {
	public void operation();
}</pre><p></p><p style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><br /></span></p><span style="font-family:FangSong_GB2312;font-size:14px;">2、抽象角色具体实现</span><br /><pre name="code" class="html" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;">public class RealComponent implements Component{

	@Override
	public void operation() {
		System.out.println("具体操作...");
	}
}
</pre><p style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><br /></span></p><span style="font-family:FangSong_GB2312;font-size:14px;">3、装饰角色</span><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><pre name="code" class="html" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;">public class Decorator implements Component {

	private Component component;

	public Decorator(Component c) {
		this.component = c;
	}

	@Override
	public void operation() {
		this.component.operation();
	}
}</pre><br /><span style="font-family:FangSong_GB2312;font-size:14px;">4、装饰角色具体实现</span><p></p><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><pre name="code" class="html" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;">public class RealDecoratorA extends Decorator {

	public RealDecoratorA(Component c) {
		super(c);
	}

	@Override
	public void operation() {
		super.operation();
		System.out.println("...自定义处理A...");
	}
}</pre><p></p><p style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;"><br /></p><span style="font-family:FangSong_GB2312;font-size:14px;">5、客户端Client测试</span><p><span style="color: rgb(51, 51, 51); text-indent: 28px;"></span></p><pre name="code" class="html" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;">public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Component c = new RealComponent();
		
		RealDecoratorA a = new RealDecoratorA(c);
		a.operation();
	}
}个</pre><p></p><p style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px;"><br /></span></p><span style="font-family:FangSong_GB2312;font-size:14px;">以上通过简单的装饰模式成功实现了把需要新增的具体功能RealDecoratorA</span><span style="background-color: rgb(240, 240, 240); color: rgb(51, 51, 51); text-indent: 28px;"><span style="font-family:FangSong_GB2312;font-size:14px;"> </span></span><p><span style="color: rgb(51, 51, 51);"><span style="font-family:FangSong_GB2312;font-size:14px;">附加到原来具体实现RealComponent上，运行之后输出</span></span></p><p><span style="color: rgb(51, 51, 51);"><span style="font-family: arial, 宋体, sans-serif; font-size: 14px;">具体操作...<br />...自定义处理A...</span><br /><br /><br /><strong><span style="font-family:FangSong_GB2312;font-size:18px;">优点：</span></strong></span></p><p><span style="color: rgb(51, 51, 51);"></span></p><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">1. Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</div><div class="para" label-module="para" style="font-family: arial, &#x5B8B;&#x4F53;, sans-serif; font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">2. 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</div><strong><span style="font-family:FangSong_GB2312;font-size:18px;">缺点：</span></strong><p></p><p><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px;"></span></p><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;">1. 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, &#x5B8B;&#x4F53;, sans-serif;">2. 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</div><p><span style="font-family:FangSong_GB2312;font-size:18px;"><strong>设计原则：</strong></span></p><p><span style="font-family:FangSong_GB2312;font-size:18px;"></span></p><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">1. 多用组合，少用继承。</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</div><div class="para" label-module="para" style="font-size: 14px; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">2. 类应设计的对扩展开放，对修改关闭。</div><br /><p><br /></p><br /><br /><p></p>   &#13;
