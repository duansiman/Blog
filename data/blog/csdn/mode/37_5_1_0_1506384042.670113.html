
<p><strong><span style="font-family:FangSong_GB2312;font-size:18px;">引用百科</span></strong></p><p></p><div class="lemma-summary" label-module="lemmaSummary" style="clear: both; word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><div class="para" label-module="para" style="word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">外观模式（<a target="_blank" href="https://baike.baidu.com/item/Facade/2954918" data-lemmaid="2954918" style="color: rgb(19, 110, 194); text-decoration-line: none;">Facade</a>），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。</span></div><div class="para" label-module="para" style="word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><a target="_blank" href="https://baike.baidu.com/item/Facade/2954918" data-lemmaid="2954918" style="color: rgb(19, 110, 194); text-decoration-line: none;"><span style="font-family:FangSong_GB2312;font-size:14px;">Facade</span></a></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">这个外观类为子系统提供一个共同的对外接口</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">Clients</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">客户对象通过一个外观接口读写子系统中各接口的数据资源。</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><div class="para-title level-2" label-module="para-title" style="clear: both; zoom: 1; overflow: hidden; border-left: 12px solid rgb(79, 156, 238); line-height: 24px; margin: 35px 0px 15px -30px; background-image: url(&quot;https://bkssl.bdimg.com/static/wiki-lemma/normal/resource/img/paraTitle-line_c5e6d61.png&quot;); background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; position: relative; color: rgb(51, 51, 51);"><h2 class="title-text" style="margin: 0px; padding: 0px 8px 0px 18px; color: rgb(0, 0, 0); float: left; line-height: 24px; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-family:FangSong_GB2312;font-size:18px;">适用场景</span></h2><br /></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">在以下情况下可以考虑使用外观模式：</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">(1)设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">(2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。</span></div><div class="para" label-module="para" style="word-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><span style="font-family:FangSong_GB2312;font-size:14px;">(3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。</span></div><span style="font-family:FangSong_GB2312;font-size:14px;">如：用户到银行进行存款，该业务其实负责对接用户需求的只是银行的柜台人员，具体银行的业务比如 验钞、入账、记录、、、等等一系列的模块处理都不需要用户去单独的操作，用户只需要与柜台人员对接即可，这就类似“外观模式”</span></div><span style="font-family:FangSong_GB2312;font-size:14px;">如下图：</span></div><div class="para" label-module="para" style="word-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;"><img src="http://img.blog.csdn.net/20170925150800836" alt="" /><br /></div></div><p></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">在以上图中，出现了两个角色：</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;"><br /></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">　　●　　<strong>门面(Facade)角色 ：</strong>客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;"><br /></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">　　●　　<strong>子系统(SubSystem)角色 ：</strong>可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;; font-size: 15px;"><br /></p><br /><strong><span style="font-family:FangSong_GB2312;font-size:18px;">具体代码：</span></strong><p><strong>1、定义业务模块处理类</strong></p><p></p><pre name="code" class="html">//验证
public class ModuleA {
	public void validate(long money) {
		System.out.println("验钞:" + money);
	}
}

//入账
public class ModuleB {
	public void account(String account, long money) {
		System.out.println("入账："+account+":" + money);
	}
}

//记录
public class ModuleC {
	public void record(String account, long money) {
		System.out.println("操作记录:"+account+"存入:" + money);
	}
}</pre><br /><p></p><p><br /></p><p><strong>2、外观门面角色</strong></p><p></p><pre name="code" class="html">//门面外观角色
public class ModuleFacade {
	//用户存款入口操作
	public void Save(String account,long money) {
		System.out.println("用户存钱开始...");
		ModuleA a = new ModuleA();
		ModuleB b = new ModuleB();
		ModuleC c = new ModuleC();
		
		a.validate(money);
		b.account(account,money);
		c.record(account,money);
	}
}
</pre><br /><br /><p></p><p><strong>3、客户端Client</strong></p><p></p><pre name="code" class="html">public class Client {
	public static void main(String[] args) {
		ModuleFacade facade = new ModuleFacade();
		facade.Save("张三",100000);
	}
}</pre><br /><br /><p></p><p>运行后执行，打印信息：</p><p><em>用户存钱开始...<br />验钞:100000<br />入账：张三:100000<br />操作记录:张三存入:100000</em><br /></p><p><br /></p><p><span style="font-family:FangSong_GB2312;font-size:14px;">通过以上代码可以简单实现外观模式，<span style="color: rgb(85, 85, 85);">使用外观模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了外观门面角色ModuleFacade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。</span></span></p><p><span style="font-size:14px;"><span style="color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;;"><br /></span></span></p><p><span style="font-size:14px;"><span style="color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;;"></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;;"><strong><span style="font-size:18px;">外观模式优点</span></strong><span style="font-size: 15px;">（</span><span style="color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;;"><u><span style="font-size:14px;">引用网上的说法</span></u></span><span style="font-size: 15px;">）：</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;; font-size: 15px;"><br /></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><strong><span style="font-family:FangSong_GB2312;font-size:14px;">　　●　　松散耦合</span></strong></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;"><strong>　　外观</strong>模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">　　<strong>●　　简单易用</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;"><strong>　　外观</strong>模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;">　　<strong>●　　更好的划分访问层次</strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; color: rgb(85, 85, 85);"><span style="font-family:FangSong_GB2312;font-size:14px;"><strong>　　</strong>通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。</span></p><br /><p><span style="font-size:14px;"><span style="color: rgb(85, 85, 85); font-family: &quot;microsoft yahei&quot;;"><br /></span></span></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>   &#13;
