\n\n<p><span style="font-size:18px"><span style="color:#000000"><span style="font-family:宋体">存储引擎是什么？</span><br />&#13;\n<br />&#13;\nMySQL<span style="font-family:宋体">中的数据用各种不同的技术存储在文件</span>(<span style="font-family:宋体">或者内存</span>)<span style="font-family:宋体">中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</span><br />&#13;\n<br />&#13;\n<span style="font-family:宋体">例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库</span>(<span style="font-family:宋体">以确保事务处理不成功时数据的回退能力</span>)<span style="font-family:宋体">。</span><br />&#13;\n<br />&#13;\n<span style="font-family:宋体">这</span> <span style="font-family:宋体">些不同的技术以及配套的相关功能在</span>MySQL<span style="font-family:宋体">中被称作存储引擎</span>(<span style="font-family:宋体">也称作表类型</span>)<span style="font-family:宋体">。</span>MySQL<span style="font-family:宋体">默认配置了许多不同的存储引擎，可以预先设置或者在</span>MySQL&#13;\n<span style="font-family:宋体">服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的</span>&#13;\n<span style="font-family:宋体">时候为你提供最大的灵活性。</span><br />&#13;\n<br />&#13;\n<span style="font-family:宋体">选择如何存储和检索你的数据的这种灵活性是</span>MySQL<span style="font-family:宋体">为什么如此受欢迎的主要原因。其它数据库系统</span>(<span style="font-family:宋体">包括大多</span>&#13;\n<span style="font-family:宋体">数商业选择</span>)<span style="font-family:宋体">仅支持一种类型的数据存储。遗憾的是，其它类型的数据库解决方案采取的</span>“<span style="font-family:宋体">一个尺码满足一切需求</span>”<span style="font-family:宋体">的方式意味着你要么就牺牲一些性能，要么你就</span>&#13;\n<span style="font-family:宋体">用几个小时甚至几天的时间详细调整你的数据库。使用</span>MySQL<span style="font-family:宋体">，我们仅需要修改我们使用的存储引擎就可以了。</span><br />&#13;\n<br />&#13;\n<span style="font-family:宋体">在这篇文章中，我们不准备集</span> <span style="font-family:宋体">中讨论不同的存储引擎的技术方面的问题</span>(<span style="font-family:宋体">尽管我们不可避免地要研究这些因素的某些方面</span>)<span style="font-family:宋体">，相反，我们将集中介绍这些不同的引擎分别最适应哪种需求和如何启</span>&#13;\n<span style="font-family:宋体">用不同的存储引擎。为了实现这个目的，在介绍每一个存储引擎的具体情况之前，我们必须要了解一些基本的问题。</span><br />&#13;\n<br />&#13;\nMySQL<span style="font-family:宋体">支持许多不同的存储引擎，有时候也称作表格类型。数据库每个表可以有不同的存储引擎，而且可以轻松地对它们进行转换。</span><br />&#13;\nCreate<span style="font-family:宋体">　</span>TABLE<span style="font-family:宋体">　</span>tablenameTYPE=typename<br />&#13;\n</span></span></p>&#13;\n<p><span style="font-size:18px; color:#000000"></span> </p>&#13;\n<p><span style="font-size:18px; color:#000000">MySQL5.5以后默认使用<strong>InnoDB</strong>存储引擎，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。<br />&#13;\n若要修改默认引擎，可以修改配置文件中的default-storage-engine。可以通过：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">show variables like 'default_storage_engine';</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">查看当前数据库到默认引擎。</span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000">命令：<em>show engines</em>和<em>show variables like 'have%'</em></span></span></p>&#13;\n<p><span style="font-size:18px; color:#000000">可以列出当前数据库所支持到引擎。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">其中Value显示为disabled的记录表示数据库支持此引擎，而在数据库启动时被禁用。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">在MySQL5.1以后，INFORMATION_SCHEMA数据库中存在一个ENGINES的表，它提供的信息与show engines;语句完全一样，可以使用下面语句来查询哪些存储引擎支持事物处理：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">select engine from information_chema.engines where transactions = 'yes';</span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px; color:#000000">可以通过engine关键字在创建或修改数据库时指定所使用到引擎。<br />&#13;\n主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍：<br />&#13;\n在创建表到时候通过<em>engine=...</em>或<em>type=...</em>来指定所要使用到引擎。</span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000"><em>show table status from DBname</em>来查看指定表到引擎。</span></span></p>&#13;\n<p><span style="font-size:18px; color:#000000"></span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000"><strong>(一)MyISAM<br />&#13;\n　　</strong>它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。<br />&#13;\n每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</span></span></p>&#13;\n<ul>&#13;\n<li><span style="font-size:18px; color:#000000">.frm(存储表定义)</span></li><li><span style="font-size:18px; color:#000000">MYD(MYData，存储数据)</span></li><li><span style="font-size:18px; color:#000000">MYI(MYIndex，存储索引)</span></li></ul>&#13;\n<p><span style="font-size:18px; color:#000000">　　数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。</span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px; color:#000000">　　每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可以在启动服务器时使用--myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处理。MyISAM类型的表可能会损坏，可以使用CHECK&#13;\n TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。</span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px; color:#000000">　　MyISAM的表还支持3种不同的存储格式：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"></span></p>&#13;\n<ul>&#13;\n<li><span style="font-size:18px; color:#000000">静态(固定长度)表</span></li><li><span style="font-size:18px; color:#000000">动态表</span></li><li><span style="font-size:18px; color:#000000">压缩表</span></li></ul>&#13;\n<p><span style="font-size:18px; color:#000000">　　其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。</span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px; color:#000000">　　动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。<br />&#13;\n压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。 </span></p>&#13;\n<p><span style="font-size:18px"><br />&#13;\n<span style="color:#000000"></span></span> </p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000"><strong>(二)InnoDB<br />&#13;\n　　</strong>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</span></span></p>&#13;\n<p><span style="font-size:18px"><br />&#13;\n<span style="color:#000000"></span></span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000"><em>1)自动增长列：<br />&#13;\n　　</em>InnoDB表的自动增长列可以手工插入，但是插入的如果是空或0，则实际插入到则是自动增长后到值。可以通过"ALTER TABLE...AUTO_INCREMENT=n;"语句强制设置自动增长值的起始值，默认为1，但是该强制到默认值是保存在内存中，数据库重启后该值将会丢失。可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长值。<br />&#13;\n对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。</span></span></p>&#13;\n<p><span style="font-size:18px"><br />&#13;\n<span style="color:#000000"></span></span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#000000"><em>2)外键约束：<br />&#13;\n　　</em>MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。<br />&#13;\n      在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。<br />&#13;\n　　当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。<br />&#13;\n　　可以使用set foreign_key_checks=0;临时关闭外键约束，set foreign_key_checks=1;打开约束。</span></span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px"><span style="color:#000000"><strong>(三)MEMORY<br />&#13;\n　　</strong>memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。<br />&#13;\n      默认情况下，memory数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在"="和"&lt;=&gt;"的操作符中，不适合使用在"&lt;"或"&gt;"操作符中，也同样不适合用在order by字句里。如果确实要使用"&lt;"或"&gt;"或betwen操作符，可以使用btree索引来加快速度。<br />&#13;\n　　存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。</span></span></p>&#13;\n<div class="cnblogs_Highlighter">&#13;\n<div>&#13;\n<div class="syntaxhighlighter nogutter csharp ie" id="highlighter_917919">&#13;\n<div class="toolbar"><span><span style="font-size:18px; color:#000000"></span></span> </div>&#13;\n<table border="0" cellspacing="0" cellpadding="0">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td class="code">&#13;\n<div class="container">&#13;\n<div class="line number1 index0 alt2"><span style="font-size:18px"><span style="color:#000000"><code class="csharp plain">create table tab_memory engine=memory&#13;\n</code><code class="csharp keyword">select</code> <code class="csharp plain">id,name,age,addr&#13;\n</code><code class="csharp keyword">from</code> <code class="csharp plain">man order&#13;\n</code><code class="csharp keyword">by</code> <code class="csharp plain">id;</code></span></span></div>&#13;\n</div>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n</div>&#13;\n</div>&#13;\n</div>&#13;\n<p><span style="font-size:18px; color:#000000">　　</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"></span> </p>&#13;\n<p><span style="font-size:18px; color:#000000">使用USING HASH/BTREE来指定特定到索引。</span></p>&#13;\n<div class="cnblogs_Highlighter">&#13;\n<div>&#13;\n<div class="syntaxhighlighter nogutter csharp ie" id="highlighter_774262">&#13;\n<div class="toolbar"><span><span style="font-size:18px; color:#000000"></span></span> </div>&#13;\n<table border="0" cellspacing="0" cellpadding="0">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td class="code">&#13;\n<div class="container">&#13;\n<div class="line number1 index0 alt2"><span style="font-size:18px"><span style="color:#000000"><code class="csharp plain">create index mem_hash&#13;\n</code><code class="csharp keyword">using</code> <code class="csharp plain">hash </code>&#13;\n<code class="csharp keyword">on</code> <code class="csharp plain">tab_memory(city_id);</code></span></span></div>&#13;\n</div>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n</div>&#13;\n</div>&#13;\n</div>&#13;\n<p><span style="font-size:18px; color:#000000">　</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">　在启动MySQL服务的时候使用--init-file选项，把insert into...select或load data infile 这样的语句放入到这个文件中，就可以在服务启动时从持久稳固的数据源中装载表。<br />&#13;\n　　服务器需要足够的内存来维持所在的在同一时间使用的MEMORY表，当不再使用MEMORY表时，要释放MEMORY表所占用的内存，应该执行DELETE FROM或truncate table或者删除整个表。<br />&#13;\n　　每个MEMORY表中放置到数据量的大小，受到max_heap_table_size系统变量的约束，这个系统变量的初始值是16M，同时在创建MEMORY表时可以使用MAX_ROWS子句来指定表中的最大行数。</span></p>&#13;\n<p><br />&#13;\n<span style="font-size:18px"><span style="color:#000000"><strong>(四)MERGE<br />&#13;\n　　</strong>merge存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT_METHOD子句定义的插入的表，可以有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过flush&#13;\n table刷新。</span></span></p>&#13;\n<div class="cnblogs_Highlighter">&#13;\n<div>&#13;\n<div class="syntaxhighlighter nogutter sql ie" id="highlighter_474004">&#13;\n<div class="toolbar"><span><span style="font-size:18px; color:#000000"></span></span> </div>&#13;\n<table border="0" cellspacing="0" cellpadding="0">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td class="code">&#13;\n<div class="container">&#13;\n<div class="line number1 index0 alt2"><span style="font-size:18px"><span style="color:#000000"><code class="sql keyword">create</code>&#13;\n<code class="sql keyword">table</code> <code class="sql plain">man_all(id </code>&#13;\n<code class="sql keyword">int</code><code class="sql plain">,</code><code class="sql keyword">name</code>&#13;\n<code class="sql keyword">varchar</code><code class="sql plain">(20))engine=merge&#13;\n</code><code class="sql keyword">union</code><code class="sql plain">=(man1,man2) insert_methos=</code><code class="sql keyword">last</code><code class="sql plain">;</code></span></span></div>&#13;\n</div>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n</div>&#13;\n</div>&#13;\n</div>&#13;\n<p><span style="color:#000000"></span> </p>&#13;\n<span style="font-size:18px"></span>&#13;\n<p><span style="color:#000000"> </span></p>&#13;\n<p><strong><span style="color:#000000">（五）Archive引擎</span></strong></p>&#13;\n<p><span style="color:#000000">Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。</span></p>&#13;\n<p><span style="color:#000000">Archive表适合日志和数据采集类应用。</span></p>&#13;\n<p><span style="color:#000000">Archive引擎支持行级锁和专用的缓存区，所以可以实现高并发的插入，但它不是一个事物型的引擎，而是一个针对高速插入和压缩做了优化的简单引擎。</span></p>&#13;\n<p><span style="color:#000000"> </span></p>&#13;\n<p><strong><span style="color:#000000">（六）Blackhole引擎</span></strong></p>&#13;\n<p><span style="color:#000000">Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</span></p>&#13;\n<p><span style="color:#000000"> </span></p>&#13;\n<p><strong><span style="color:#000000">（七）CSV引擎</span></strong></p>&#13;\n<p><span style="color:#000000">CSV引擎可以将普通的SCV文件作为MySQL的表来处理，但不支持索引。</span></p>&#13;\n<p><span style="color:#000000">CSV引擎可以作为一种数据交换的机制，非常有用。</span></p>&#13;\n<p><span style="color:#000000"> </span></p>&#13;\n<p><strong><span style="color:#000000">（八）Federated引擎</span></strong></p>&#13;\n<p><span style="color:#000000">Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</span></p>&#13;\n<p><span style="color:#000000"> </span></p>&#13;\n<p><span style="color:#000000"></span> </p>&#13;\n<p><span style="color:#000000"></span> </p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">二、选择合适的引擎</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000">大部分情况下，InnoDB都是正确的选择，可以简单地归纳为一句话“除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎”。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列负责的问题，以及一些潜在的bug和边界问题。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">如果应用需要不同的存储引擎，请先考虑以下几个因素：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">事务：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">    如果应用需要事务支持，那么InnoDB(或者XtraDB)是目前最稳定并且经过验证的选择。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">备份：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">    如果可以定期地关闭服务器来执行备份，那么备份的因素可以忽略。反之，如果需要在线热备份，那么选择InnoDB就是基本的要求。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">崩溃恢复</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">    MyISAM崩溃后发生损坏的概率比InnoDB要高很多，而且恢复速度也要慢。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">特有的特性</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">    如果一个存储引擎拥有一些关键的特性，同时却又缺乏一些必要的特性，那么有时候不得不做折中的考虑，或者在架构设计上做一些取舍。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><span style="font-size:18px; color:#000000">有些查询SQL在不同的引擎上表现不同。比较典型的是：</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">SELECT COUNT(*) FROM table;</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">对于MyISAM确实会很快，但其他的可能都不行。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">三、应用举例</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">1、日志型应用</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000">MyISAM或者Archive存储引擎对这类应用比较合适，因为他们开销低，而且插入速度非常快。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">如果需要对记录的日志做分析报表，生成报表的SQL很可能会导致插入效率明显降低，这时候该怎么办？</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">一种解决方法，是利用MySQL内置的复制方案将数据复制一份到备库，然后在备库上执行比较消耗时间和CPU的查询。当然也可以在系统负载较低的时候执行报表查询操作，但应用在不断变化，如果依赖这个策略可能以后会导致问题。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000">另一种方法，在日志记录表的名字中包含年和月的信息，这样可以在已经没有插入操作的历史表上做频繁的查询操作，而不会干扰到最新的当前表上的插入操作。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">2、只读或者大部分情况下只读的表</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000">有些表的数据用于编制类目或者分列清单（如工作岗位），这种应用场景是典型的读多写少的业务。如果不介意MyISAM的崩溃恢复问题，选用MyISAM引擎是合适的。（MyISAM只将数据写到内存中，然后等待操作系统定期将数据刷出到磁盘上）</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">3、订单处理</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000">涉及订单处理，支持事务是必要的，InnoDB是订单处理类应用的最佳选择。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"> </span></p>&#13;\n<p><strong><span style="font-size:18px; color:#000000">4、大数据量</span></strong></p>&#13;\n<p><span style="font-size:18px; color:#000000">如果数据增长到10TB以上的级别，可能需要建立数据仓库。Infobright是MySQL数据仓库最成功的方案。也有一些大数据库不适合Infobright，却可能适合TokuDB。</span></p>&#13;\n<p><span style="font-size:18px; color:#000000"></span> </p>&#13;\n<p><span style="font-size:18px; color:#000000"></span> </p>&#13;\n<p><span style="font-size:18px; color:#000000"></span> </p>&#13;\n &#13;\n
