\n <div class="markdown_views"><h2 id="数据分组">数据分组</h2>\n\n<p>根据上一篇博文中所看到的，SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。</p>\n\n<p>目前为止的所有计算都是在表的所有数据或匹配特定的where子句的数据上进行的。</p>\n\n<p>例如，在一门公共选修课中，我们需要统计来自每个班的人数各有多少个？应该怎么做呢？ <br />\n可能有的人像下面这样做：</p>\n\n<pre><code>select class,count(*) from student3 where class=1001;\n</code></pre>\n\n<p>但是，这样你只能够得到一个班级选择这门公选课的人数，并不能得到选择这门可选课其它班级的人数。</p>\n\n<p>因此，group by就排上用场了。</p>\n\n\n\n<h3 id="创建分组group-by">创建分组：group by</h3>\n\n<p>为更好的实践group by，建立了如下的student3表。 <br />\n<img src="http://7xknzt.com1.z0.glb.clouddn.com/MySQLstudent3.PNG" alt="" title="" /></p>\n\n<p>用group by分组如下：</p>\n\n<pre><code>select class ,count(*) from student3 group by class;//按照班级进行分组\n</code></pre>\n\n<p><img src="http://7xknzt.com1.z0.glb.clouddn.com/groupBy_MySQL.PNG" alt="" title="" /></p>\n\n<p><font color="red">注意：因为使用了group by，就不必指定要计算和估值的每个组了，系统会自动完成。group by子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</font></p>\n\n<p>使用group by子句前，需要注意如下的规定：</p>\n\n<blockquote>\n <ul>\n <li>group by 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li>\n <li>如果在group by子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算。</li>\n <li>group by子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在select中使用表达式，则必须在group by子句中指定相同的表达式。不能使用别名。</li>\n <li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多个NULL值，它们将会被分为一组。</li>\n <li>group by必须出现在where子句之后，在order by之前。</li>\n </ul>\n</blockquote>\n\n\n\n<h3 id="过滤分组having">过滤分组：HAVING</h3>\n\n<p>除了能用group by分组数据外，还可以用HAVING来过滤分组，即包括哪些分组，排除哪些分组。</p>\n\n<p><font color="red">HAVING非常类似于WHERE，HAVING支持所有WHERE操作符，它们唯一的区别为：WHERE过滤行，而HAVING是过滤分组。</font></p>\n\n<p>以一个例子来进行说明：找出在这门公选课中大于等于两个人的班级。</p>\n\n<pre><code>select class,count(*) from student3 group by class having count(*)&gt;=2;\n</code></pre>\n\n<p>上面这条语句的 having count(*)&gt;=2就过滤了人数在2个以上的结果出来。</p>\n\n<p><img src="http://7xknzt.com1.z0.glb.clouddn.com/MySQL_having.PNG" alt="" title="" /></p>\n\n<p><font color="red">HAVING 和WHERE差别理解的另一种方法：WHERE是在数据分组前进行过滤，而HAVING是在数据分组后进行过滤</font></p>\n\n<p>为更好的理解这句话，看如下的例子：</p>\n\n<pre><code>select class,count(*) from student3 where score&gt;60 group by class having count(*)&gt;=2;\n</code></pre>\n\n<p>上面的语句的含义就是：第一步先通过where score&gt;60来从表中过滤行数据，第二步就是group by对第一步处理后的数据进行分组，最后，having count(*)&gt;=2来过滤分组。</p>\n\n<p>实践结果如下：</p>\n\n<p><img src="http://7xknzt.com1.z0.glb.clouddn.com/MySQL_having_v3.PNG" alt="" title="" /></p>\n\n\n\n<h3 id="分组和排序">分组和排序</h3>\n\n<p>我们经常发现用group by分组的数据是以分组的顺序输出的，但是情况并不总是这样，它并不是SQL的规范。因此，但你想要对分组后的数据以某种方式排序，应该提供明确的order by语句，即使其效果等同于group by子句也如此。</p>\n\n<p><font color="red">千万不要忘记order by</font>:一般在使用group by子句时，应该也给出order by子句。这是保证数据正确排序的唯一方法，前往不要依赖group by排序数据。</p>\n\n<pre><code>select class,count(*) from student3 group by class order by class;//分组后用class来进行排序。\n</code></pre>\n\n<p><img src="http://7xknzt.com1.z0.glb.clouddn.com/MySQL_orderBy.PNG" alt="" title="" /></p>\n\n\n\n<h3 id="小结">小结</h3>\n\n<p>最后，对select语句中子句的顺序进行如下的截图记录：</p>\n\n<p><img src="http://7xknzt.com1.z0.glb.clouddn.com/MySQL_select.PNG" alt="" title="" /></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
