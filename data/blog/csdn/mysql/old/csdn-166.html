\n\n<p><span style="font-weight:bold">innodb_buffer_pool_size</span></p>&#13;\n<p>innodb_buffer_pool_size 参数用来设置Innodb 最主要的Buffer(Innodb_Buffer_Pool)的大小，也就是缓存用户表及索引数据的最主要缓存空间，对Innodb 整体性能影响也最大。<br />&#13;\n</p>&#13;\n<p>对于一台单独给MySQL 使用的主机，并假设只使用innodb引擎，一般建议该参数为物理内存的75%左右。</p>&#13;\n<p>当系统上线之后，我们可以通过Innodb 存储引擎提供给我们的关于Buffer Pool 的实时状态信息作出进一步分析，来确定系统中Innodb 的Buffer Pool 使用情况是否正常高效：<br />&#13;\n</p>&#13;\n<p></p>&#13;\n<pre name="code" class="sql">mysql&gt; show status like 'Innodb_buffer_pool_%';\n+-----------------------------------------+---------------+\n| Variable_name | Value |\n+-----------------------------------------+---------------+\n| Innodb_buffer_pool_pages_data | 999020 | \n| Innodb_buffer_pool_pages_dirty | 47643 | \n| Innodb_buffer_pool_pages_flushed | 474668167 | \n| Innodb_buffer_pool_pages_LRU_flushed | 365125 | \n| Innodb_buffer_pool_pages_free | 0 | \n| Innodb_buffer_pool_pages_made_not_young | 0 | \n| Innodb_buffer_pool_pages_made_young | 203410903 | \n| Innodb_buffer_pool_pages_misc | 49552 | \n| Innodb_buffer_pool_pages_old | 368697 | \n| Innodb_buffer_pool_pages_total | 1048572 | \n| Innodb_buffer_pool_read_ahead_rnd | 0 | \n| Innodb_buffer_pool_read_ahead | 66348855 | \n| Innodb_buffer_pool_read_ahead_evicted | 3716819 | \n| Innodb_buffer_pool_read_requests | 3215992991498 | \n| Innodb_buffer_pool_reads | 65634998 | \n| Innodb_buffer_pool_wait_free | 651 | \n| Innodb_buffer_pool_write_requests | 21900970785 | \n+-----------------------------------------+---------------+</pre>从上面的值我们可以看出总共1048572个 pages，其中放数据的有999020个 pages，且已没有free状态的page。<br />&#13;\nread 请求3215992991498次，其中有65634998次所请求的数据在buffer pool 中没有，也就是说有65634998 次是通过读取物理磁盘来读取数据的，所以很容易也就得出了Innodb Buffer Pool 的Read 命中率大概在为：(3215992991498- 65634998)/ 3215992991498* 100% = 99.998%。<br />&#13;\n<br />&#13;\n<p></p>&#13;\n<p><strong>innodb_buffer_pool_instances</strong><br />&#13;\n</p>&#13;\n<p>该参数将innodb_buffer_pool划分为不同的instance，每个instance独立的LRU、FLUSH、FREE、独立的mutex控制。</p>&#13;\n<p>对于比较大的innodb_buffer_pool_size，建议设置多个instances，避免内存锁的争用。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_log_file_size</strong><br />&#13;\n</p>&#13;\n<p>设置innodb redo log file的大小，从性能角度来看，日志文件越大越好，可以减少buffer pool checkpoint的频率，但是在MySQL的官方版本中，iinnodb_log_file_size*innodb_log_files_in_group不能超过4G。</p>&#13;\n<p>日志文件越大，也意味着MySQL实例crash之后恢复的时间越长，不过一般生成系统都会配置主从库，因此这个因素可以忽略不考虑。</p>&#13;\n<p>一般来说，在我个人维护的环境中，比较偏向于将事务日志设置为3 组，每个日志设置为256MB 大小，整体效果还算不错。<br />&#13;\n</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_log_buffer_size</strong><br />&#13;\n</p>&#13;\n<p>顾名思义，这个参数就是用来设置Innodb 的Log Buffer 大小的，系统默认值为1MB。Log Buffer的主要作用就是缓冲Log 数据，提高写Log 的IO 性能。一般来说，如果你的系统不是“写负载非常高且以大事务居多”的话，8MB 以内的大小就完全足够了。<br />&#13;\n</p>&#13;\n<p>我们也可以通过系统状态参数提供的性能统计数据来分析Log 的使用情况：<br />&#13;\n</p>&#13;\n<p></p>&#13;\n<pre name="code" class="sql">mysql&gt; show status like 'innodb_log%';\n+---------------------------+------------+\n| Variable_name | Value |\n+---------------------------+------------+\n| Innodb_log_waits | 0 | \n| Innodb_log_write_requests | 3486920147 | \n| Innodb_log_writes | 352577360 | \n+---------------------------+------------+</pre>如果Innodb_log_waits不等于0的话，表示出现过Log Buffer的写等待，表示innodb_log_buffer_size有可能过小。&#13;\n<p></p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_thread_concurrency</strong><br />&#13;\n</p>&#13;\n<p>该参数表示innodb最大线程并发量，官方推荐设为0，表示由innodb自己控制，但实践证明，当并发过大时，innodb自己会控制不当，可能导致MySQL hang死，所以一般建议为CPU核心数（不含超线程）</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_io_capacity</strong><br />&#13;\n</p>&#13;\n<p>表示每秒钟IO设备处理数据页的上限，如果硬盘性能比较好，可以设大一些（如1000）。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_max_dirty_pages_pct</strong><br />&#13;\n</p>&#13;\n<p>表示innodb从buffer中刷新脏页的比例不超过这个值，每次checkpoint的脏页刷新为：innodb_max_dirty_pages_pct*innodb_io_capacity</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>Innodb_flush_method</strong><br />&#13;\n</p>&#13;\n<p>用来设置Innodb 打开和同步数据文件以及日志文件的方式，不过只有在Linux &amp; Unix 系统上面有效。当我们设置为O_DSYNC，则系统以O_SYNC 方式打开和刷新日志文件， 通过fsync() 来打开和刷新数据文件。而设置为O_DIRECT 的时候， 则通过O_DIRECT（Solaris 上为directio()）打开数据文件，同时以fsync()来刷新数据和日志文件。<br />&#13;\n总的来说，innodb_flush_method 的不同设置主要影响的是Innodb 在不同运行平台下进行IO 操作的时候所调用的操作系统IO 借口的区别。而不同的IO 操作接口对数据的处理方式会有一定的区别，所以处理性能也会有一定的差异。一般来说，如果我们的磁盘是通过RAID 卡做了硬件级别的RAID，建议可以使用O_DIRECT，可以一定程度上提高IO 性能，但如果RAID Cache 不够的话，还是需要谨慎对待。<br />&#13;\n</p>&#13;\n<p><br />&#13;\n<strong>innodb_file_per_table</strong><br />&#13;\n</p>&#13;\n<p>一般建议开启，因为不同的表空间可以灵活设置数据目录的地址，避免共享表空间产生的IO竞争。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>innodb_flush_log_at_trx_commit</strong><br />&#13;\n</p>&#13;\n<p></p>&#13;\n<div>innodb_flush_log_at_trx_commit = 0，Innodb 中的Log Thread 每隔1 秒钟会将log buffer中的数据写入到文件，同时还会通知文件系统进行文件同步的flush 操作，保证数据确实已经写入到磁盘上面的物理文件。但是，每次事务的结束（commit 或者是rollback）并不会触发Log Thread 将log buffer 中的数据写入文件。所以，当设置为0 的时候，当MySQL Crash 和OS Crash 或者主机断电之后，最极端的情况是丢失1&#13;\n 秒时间的数据变更。<br />&#13;\n</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<div>innodb_flush_log_at_trx_commit = 1，这也是Innodb 的默认设置。我们每次事务的结束都会触发Log Thread 将log buffer 中的数据写入文件并通知文件系统同步文件。这个设置是最安全的设置，能够保证不论是MySQL Crash 还是OS Crash 或者是主机断电都不会丢失任何已经提交的数据。<br />&#13;\n</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<div>innodb_flush_log_at_trx_commit = 2，当我们设置为2 的时候，Log Thread 会在我们每次事务结束的时候将数据写入事务日志，但是这里的写入仅仅是调用了文件系统的文件写入操作。而我们的文件系统都是有缓存机制的，所以Log Thread 的这个写入并不能保证内容真的已经写入到物理磁盘上面完成持久化的动作。文件系统什么时候会将缓存中的这个数据同步到物理磁盘文件Log Thread 就完全不知道了。所以，当设置为2 的时候，MySQL Crash 并不会造成数据的丢失，但是OS&#13;\n Crash 或者是主机断电后可能丢失的数据量就完全控制在文件系统上了。<br />&#13;\n</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<div>从上面的分析我们可以看出，当innodb_flush_log_at_trx_commit 设置为1 的时候是最安全的，但是由于所做的IO 同步操作也最多，所以性能也是三种设置中最差的一种。如果设置为0，则每秒有一次同步，性能相对高一些。如果设置为2，可能性能是三这种最好的。但是也可能是出现Crash后丢失数据最多的。到底该如何设置设置，就要根据具体的场景来分析了。一般来说，如果完全不能接受数据的丢失，那么我们肯定会通过牺牲一定的性能来换取数据的安全性，选择设置为1。而如果我们可以丢失很少量的数据(比如说1&#13;\n 秒之内)，那么我们可以设置为0。当然，如果大家觉得我们的OS 足够稳定，主机硬件设备，而且主机的供电系统也足够安全，我们也可以将innodb_flush_log_at_trx_commit 设置为2 让系统的整体性能尽可能的高。<br />&#13;\n</div>&#13;\n<p></p>&#13;\n<p><strong>transaction-isolation</strong><br />&#13;\n</p>&#13;\n<p>对于高并发应用来说，为了尽可能保证数据的一致性，避免并发可能带来的数据不一致问题，自然是事务隔离级别越高越好。但是，对于Innodb 来说，所使用的事务隔离级别越高，实现复杂度自然就会更高，所需要做的事情也会更多，整体性能也就会更差。<br />&#13;\n</p>&#13;\n<p>所以，我们需要分析自己应用系统的逻辑，选择可以接受的最低事务隔离级别。以在保证数据安全一致性的同时达到最高的性能。<br />&#13;\n虽然Innodb 存储引擎默认的事务隔离级别是REPEATABLE READ，但实际上在我们大部分的应用场景下，都只需要READ COMMITED 的事务隔离级别就可以满足需求了。<br />&#13;\n</p>&#13;\n<p><strong>sync_binlog</strong></p>&#13;\n<p>表示每次刷新binlog到磁盘的数目。</p>&#13;\n<p>对于核心系统，我们需要采用双1模式，即：innodb_flush_log_at_trx_commit=1, sync_binlog=1，这样可以保证主备库数据一致，不会有数据丢失。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n &#13;\n
