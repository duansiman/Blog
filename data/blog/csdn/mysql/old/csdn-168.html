\n\n<p>MySQL权限表是指在mysql数据库下的5张表：user, db, tables_priv, columns_priv, procs_priv，这5张表记录了所有的用户及其权限信息，MySQL就是通过这5张表控制用户访问的。本文将探索这5张权限表。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<h2>MySQL权限表的结构和内容</h2>&#13;\n<p><strong>1、user</strong>：记录账号、密码、全局性权限信息等。</p>&#13;\n<p></p>&#13;\n<pre name="code" class="sql">mysql&gt; desc mysql.user;\n+------------------------+-----------------------------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+------------------------+-----------------------------------+------+-----+---------+-------+\n| Host | char(60) | NO | PRI | | | \n| User | char(16) | NO | PRI | | | \n| Password | char(41) | NO | | | | \n| Select_priv | enum('N','Y') | NO | | N | | \n| Insert_priv | enum('N','Y') | NO | | N | | \n| Update_priv | enum('N','Y') | NO | | N | | \n| Delete_priv | enum('N','Y') | NO | | N | | \n| Create_priv | enum('N','Y') | NO | | N | | \n| Drop_priv | enum('N','Y') | NO | | N | | \n| Reload_priv | enum('N','Y') | NO | | N | | \n| Shutdown_priv | enum('N','Y') | NO | | N | | \n| Process_priv | enum('N','Y') | NO | | N | | \n| File_priv | enum('N','Y') | NO | | N | | \n| Grant_priv | enum('N','Y') | NO | | N | | \n| References_priv | enum('N','Y') | NO | | N | | \n| Index_priv | enum('N','Y') | NO | | N | | \n| Alter_priv | enum('N','Y') | NO | | N | | \n| Show_db_priv | enum('N','Y') | NO | | N | | \n| Super_priv | enum('N','Y') | NO | | N | | \n| Create_tmp_table_priv | enum('N','Y') | NO | | N | | \n| Lock_tables_priv | enum('N','Y') | NO | | N | | \n| Execute_priv | enum('N','Y') | NO | | N | | \n| Repl_slave_priv | enum('N','Y') | NO | | N | | \n| Repl_client_priv | enum('N','Y') | NO | | N | | \n| Create_view_priv | enum('N','Y') | NO | | N | | \n| Show_view_priv | enum('N','Y') | NO | | N | | \n| Create_routine_priv | enum('N','Y') | NO | | N | | \n| Alter_routine_priv | enum('N','Y') | NO | | N | | \n| Create_user_priv | enum('N','Y') | NO | | N | | \n| Event_priv | enum('N','Y') | NO | | N | | \n| Trigger_priv | enum('N','Y') | NO | | N | | \n| Create_tablespace_priv | enum('N','Y') | NO | | N | | \n| ssl_type | enum('','ANY','X509','SPECIFIED') | NO | | | | \n| ssl_cipher | blob | NO | | NULL | | \n| x509_issuer | blob | NO | | NULL | | \n| x509_subject | blob | NO | | NULL | | \n| max_questions | int(11) unsigned | NO | | 0 | | \n| max_updates | int(11) unsigned | NO | | 0 | | \n| max_connections | int(11) unsigned | NO | | 0 | | \n| max_user_connections | int(11) unsigned | NO | | 0 | | \n| plugin | char(64) | YES | | | | \n| authentication_string | text | YES | | NULL | | \n+------------------------+-----------------------------------+------+-----+---------+-------+</pre>&#13;\n1）*_priv：适用MySQL服务器全局性的权限，假设某个账号拥有Delete_priv的全局性权限，则表示它可以对任何表进行删除数据的操作，这非常危险，所有一般只有超级用户root有这样的权限，其它普通用户没有。&#13;\n<p></p>&#13;\n<p>2）max_*：资源管理列，用于规定账号的资源使用上限，其中：</p>&#13;\n<p>    max_questions：每小时发出的语句数上限</p>&#13;\n<p>    max_updates：每小时发出的修改类语句数上限</p>&#13;\n<p>    max_connections：每小时连接数上限</p>&#13;\n<p>    max_user_connections：允许保有的连接数上限</p>&#13;\n<p>3）SSL相关列：</p>&#13;\n<p>    ssl_type，ssl_cipher，x509_isuser, x509_subject</p>&#13;\n<p><strong>2、db</strong>：记录数据库相关权限</p>&#13;\n<p></p>&#13;\n<pre name="code" class="plain">mysql&gt; desc mysql.db;\n+-----------------------+---------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+-----------------------+---------------+------+-----+---------+-------+\n| Host | char(60) | NO | PRI | | | \n| Db | char(64) | NO | PRI | | | \n| User | char(16) | NO | PRI | | | \n| Select_priv | enum('N','Y') | NO | | N | | \n| Insert_priv | enum('N','Y') | NO | | N | | \n| Update_priv | enum('N','Y') | NO | | N | | \n| Delete_priv | enum('N','Y') | NO | | N | | \n| Create_priv | enum('N','Y') | NO | | N | | \n| Drop_priv | enum('N','Y') | NO | | N | | \n| Grant_priv | enum('N','Y') | NO | | N | | \n| References_priv | enum('N','Y') | NO | | N | | \n| Index_priv | enum('N','Y') | NO | | N | | \n| Alter_priv | enum('N','Y') | NO | | N | | \n| Create_tmp_table_priv | enum('N','Y') | NO | | N | | \n| Lock_tables_priv | enum('N','Y') | NO | | N | | \n| Create_view_priv | enum('N','Y') | NO | | N | | \n| Show_view_priv | enum('N','Y') | NO | | N | | \n| Create_routine_priv | enum('N','Y') | NO | | N | | \n| Alter_routine_priv | enum('N','Y') | NO | | N | | \n| Execute_priv | enum('N','Y') | NO | | N | | \n| Event_priv | enum('N','Y') | NO | | N | | \n| Trigger_priv | enum('N','Y') | NO | | N | | \n+-----------------------+---------------+------+-----+---------+-------+</pre>&#13;\n1）*_priv：适用于某个数据库的权限<br />&#13;\n<strong>3、tables_priv</strong>：表级别的权限&#13;\n<p></p>&#13;\n<p></p>&#13;\n<pre name="code" class="plain">mysql&gt; desc mysql.tables_priv; \n+-------------+--------------------------------------------------------------------+------+-----+-------------------+-----------------------------+\n| Field | Type | Null | Key | Default | Extra |\n+-------------+--------------------------------------------------------------------+------+-----+-------------------+-----------------------------+\n| Host | char(60) | NO | PRI | | | \n| Db | char(64) | NO | PRI | | | \n| User | char(16) | NO | PRI | | | \n| Table_name | char(64) | NO | PRI | | | \n| Grantor | char(77) | NO | MUL | | | \n| Timestamp | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP | \n| Table_priv | set('Select','Insert','Update','Delete','Create','Drop','Grant',\n 'References','Index','Alter','Create View','Show view','Trigger') | NO | | | | \n| Column_priv | set('Select','Insert','Update','References') | NO | | | | \n+-------------+--------------------------------------------------------------------+------+-----+-------------------+-----------------------------+</pre>&#13;\n上面的Column_priv比较奇怪，因为照理说tables_priv只显示表级别的权限，列级别的权限应该在columns_priv里显示才对。后来查了资料才知道，原来这是为了提高权限检查时的性能，试想一下，权限检查时，如果发现tables_priv.Column_priv为空，就不需要再检查columns_priv表了，这种情况在现实中往往占大多数。&#13;\n<p></p>&#13;\n<p><strong>4、columns_priv</strong>：列级别的权限</p>&#13;\n<p></p>&#13;\n<pre name="code" class="sql">mysql&gt; desc mysql.columns_priv;\n+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+\n| Field | Type | Null | Key | Default | Extra |\n+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+\n| Host | char(60) | NO | PRI | | | \n| Db | char(64) | NO | PRI | | | \n| User | char(16) | NO | PRI | | | \n| Table_name | char(64) | NO | PRI | | | \n| Column_name | char(64) | NO | PRI | | | \n| Timestamp | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP | \n| Column_priv | set('Select','Insert','Update','References') | NO | | | | \n+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+</pre>&#13;\n<strong>5、procs_priv</strong>：存储过程和函数的权限<br />&#13;\n<pre name="code" class="sql">mysql&gt; desc mysql.procs_priv; \n+--------------+----------------------------------------+------+-----+-------------------+-----------------------------+\n| Field | Type | Null | Key | Default | Extra |\n+--------------+----------------------------------------+------+-----+-------------------+-----------------------------+\n| Host | char(60) | NO | PRI | | | \n| Db | char(64) | NO | PRI | | | \n| User | char(16) | NO | PRI | | | \n| Routine_name | char(64) | NO | PRI | | | \n| Routine_type | enum('FUNCTION','PROCEDURE') | NO | PRI | NULL | | \n| Grantor | char(77) | NO | MUL | | | \n| Proc_priv | set('Execute','Alter Routine','Grant') | NO | | | | \n| Timestamp | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP | \n+--------------+----------------------------------------+------+-----+-------------------+-----------------------------+</pre>&#13;\n<br />&#13;\n<h2>如何控制客户访问？</h2>&#13;\n<p></p>&#13;\n<p>下面讲讲MySQL服务器如何通过以上介绍的5张权限表控制客户访问。</p>&#13;\n<p><strong>1、用户连接时的检查</strong></p>&#13;\n<p>1）当用户连接时，MySQL服务器首先从user表里匹配host, user, password，匹配不到则拒绝该连接</p>&#13;\n<p>2）接着检查user表的max_connections和max_user_connections，如果超过上限则拒绝连接</p>&#13;\n<p>3）检查user表的SSL安全连接，如果有配置SSL，则需确认用户提供的证书是否合法</p>&#13;\n<p>只有上面3个检查都通过后，服务器才建立连接，连接建立后，当用户执行SQL语句时，需要如下检查。</p>&#13;\n<p><strong>2、执行SQL语句时的检查</strong></p>&#13;\n<p>1）从user表里检查max_questions和max_updates，如果超过上限则拒绝执行SQL</p>&#13;\n<p>下面几步是进行权限检查：</p>&#13;\n<p>2）首先检查user表，看是否具有相应的全局性权限，如果有，则执行，没有则继续下一步检查</p>&#13;\n<p>3）接着到db表，看是否具有数据库级别的权限，如果有，则执行，没有则继续下一步检查</p>&#13;\n<p>4）最后到tables_priv, columns_priv, procs_priv表里查看是否具有相应对象的权限</p>&#13;\n<p>从以上的过程我们可以知道，MySQL检查权限是一个比较复杂的过程，所以为了提高性能，MySQL的启动时就会把这5张权限表加载到内存。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<h2>注意事项</h2>&#13;\n<p>1、尽量使用create user, grant等语句，而不要直接修改权限表。</p>&#13;\n<p>虽然create user, grant等语句底层也是修改权限表，和直接修改权限表的效果是一样的，但是，对于非高手来说，采用封装好的语句肯定不会出错，而如果直接修改权限表，难免会漏掉某些表。而且，修改完权限表之后，还需要执行flush privileges重新加载到内存，否则不会生效。</p>&#13;\n<p>2、把匿名用户删除掉。</p>&#13;\n<p>匿名用户没有密码，不但不安全，还会产生一些莫名其妙的问题，强烈建议删除。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n &#13;\n
