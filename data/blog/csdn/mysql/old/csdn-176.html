\n\n<p>我们知道B树索引是有序的，那么可不可以通过只扫描索引就能完成order by操作呢？答案是肯定的，但条件也比较苛刻：只有当索引的列顺序和order by字句的列顺序完全一致，且order by字句中所有列的排序方式要么全部都是ASC，要么全部都是DESC，MySQL才能使用索引来对结果进行排序；如果查询需要关联多个表，则条件更苛刻，只有当order by字句中的列全部为驱动表（执行计划中）时，才能使用索引做排序。</p>&#13;\n<p>下面我们来看一些例子：假设users表上有索引(login_id,status）</p>&#13;\n<p></p><pre name="code" class="sql">root@test 05:03:12&gt;explain select id from users order by login_id,status\\G\n*************************** 1. row ***************************\n id: 1\n select_type: SIMPLE\n table: users\n type: index\npossible_keys: NULL\n key: login_id\n key_len: 387\n ref: NULL\n rows: 5894108\n Extra: Using index\n1 row in set (0.00 sec)\n\nroot@test 05:03:17&gt;explain select id from users order by status\\G\n*************************** 1. row ***************************\n id: 1\n select_type: SIMPLE\n table: users\n type: index\npossible_keys: NULL\n key: login_id\n key_len: 387\n ref: NULL\n rows: 5894108\n Extra: Using index; Using filesort\n1 row in set (0.00 sec)\n\nroot@test 05:03:26&gt;explain select id from users order by login_id desc,status\\G\n*************************** 1. row ***************************\n id: 1\n select_type: SIMPLE\n table: users\n type: index\npossible_keys: NULL\n key: login_id\n key_len: 387\n ref: NULL\n rows: 5894108\n Extra: Using index; Using filesort\n1 row in set (0.00 sec)\n\nroot@test 05:04:03&gt;explain select id from users order by login_id desc,status desc\\G\n*************************** 1. row ***************************\n id: 1\n select_type: SIMPLE\n table: users\n type: index\npossible_keys: NULL\n key: login_id\n key_len: 387\n ref: NULL\n rows: 5894108\n Extra: Using index\n1 row in set (0.00 sec)</pre>注：如果在Extra列出现using filesort，表示无法按索引顺序扫描。<br />&#13;\n<br />&#13;\n&#13;\n &#13;\n
