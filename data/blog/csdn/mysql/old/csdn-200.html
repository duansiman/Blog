\n\n<p><a target="_blank" href="http://blog.csdn.net/l1028386804/article/details/54657412">转载请注明出处：http://blog.csdn.net/l1028386804/article/details/54657412</a><br />&#13;\n</p>&#13;\n<p>假设有一个业务场景，需要查询用户登录记录信息，其中表结构如下：</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_1_528081" name="code" class="sql">CREATE TABLE `tb` (\n `id` int(11) NOT NULL AUTO_INCREMENT,\n `uid` int(11) NOT NULL,\n `ip` varchar(16) NOT NULL,\n `login_time` datetime,\n PRIMARY KEY (`id`),\n KEY (`uid`)\n);</pre>再来点测试数据：<br />&#13;\n<p></p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_2_5104967" name="code" class="sql">INSERT INTO tb SELECT null, 1001, '192.168.1.1', '2017-01-21 16:30:47';\nINSERT INTO tb SELECT null, 1003, '192.168.1.153', '2017-01-21 19:30:51';\nINSERT INTO tb SELECT null, 1001, '192.168.1.61', '2017-01-21 16:50:41';\nINSERT INTO tb SELECT null, 1002, '192.168.1.31', '2017-01-21 18:30:21';\nINSERT INTO tb SELECT null, 1002, '192.168.1.66', '2017-01-21 19:12:32';\nINSERT INTO tb SELECT null, 1001, '192.168.1.81', '2017-01-21 19:53:09';\nINSERT INTO tb SELECT null, 1001, '192.168.1.231', '2017-01-21 19:55:34';</pre>表数据情况：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_3_4537368" name="code" class="plain">+----+------+---------------+---------------------+\n| id | uid | ip | login_time |\n+----+------+---------------+---------------------+\n| 1 | 1001 | 192.168.1.1 | 2017-01-21 16:30:47 |\n| 2 | 1003 | 192.168.1.153 | 2017-01-21 19:30:51 |\n| 3 | 1001 | 192.168.1.61 | 2017-01-21 16:50:41 |\n| 4 | 1002 | 192.168.1.31 | 2017-01-21 18:30:21 |\n| 5 | 1002 | 192.168.1.66 | 2017-01-21 19:12:32 |\n| 6 | 1001 | 192.168.1.81 | 2017-01-21 19:53:09 |\n| 7 | 1001 | 192.168.1.231 | 2017-01-21 19:55:34 |\n+----+------+---------------+---------------------+</pre>如果只需要针对用户查出其最后登录的时间，可以简单写出：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_4_731168" name="code" class="html">SELECT uid, max(login_time)\nFROM tb\nGROUP BY uid;</pre><pre code_snippet_id="2144206" snippet_file_name="blog_20170122_5_4940099" name="code" class="plain">+------+---------------------+\n| uid | max(login_time) |\n+------+---------------------+\n| 1001 | 2017-01-21 19:55:34 |\n| 1002 | 2017-01-21 19:12:32 |\n| 1003 | 2017-01-21 19:30:51 |\n+------+---------------------+</pre>若还需要查询用户最后登录时的其他信息，就不能用这种sql写了：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_6_5004573" name="code" class="sql">-- 错误写法\nSELECT uid, ip, max(login_time)\nFROM tb\nGROUP BY uid;\n-- 错误写法</pre>这样的语句是非SQL标准的，虽然能够在MySQL数据库中执行成功，但返回的却是未知的<br />&#13;\n（如果sql_mode开启了only_full_group_by，则不会执行成功。）<br />&#13;\n可能ip字段会取uid分组前的第一个row的值，显然不是所需信息<br />&#13;\n写法1<br />&#13;\n写一个子查询：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_7_6705249" name="code" class="sql">SELECT a.uid, a.ip, a.login_time\nFROM tb a\nWHERE a.login_time in (\nSELECT max(login_time)\nFROM tb\nGROUP BY uid);</pre>写法2<br />&#13;\n再或者换一个写法：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_8_5058639" name="code" class="sql">SELECT a.uid, a.ip, a.login_time\nFROM tb a\nWHERE a.login_time = (\nSELECT max(login_time)\nFROM tb\nWHERE a.uid = uid);</pre>顺便测了一下<br />&#13;\n在5.6以前的版本中，写法②这条sql在大数据量的情况下，执行计划不理想，目测性能不佳。<br />&#13;\n在5.6及以后的版本中，写法②这条sql会快很多，执行计划也有了改变<br />&#13;\n5.5.50：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_9_7107979" name="code" class="plain">+----+--------------------+-------+------+---------------+------+---------+------+------+-------------+\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |\n+----+--------------------+-------+------+---------------+------+---------+------+------+-------------+\n| 1 | PRIMARY | a | ALL | NULL | NULL | NULL | NULL | 7 | Using where |\n| 2 | DEPENDENT SUBQUERY | tb | ALL | uid | NULL | NULL | NULL | 7 | Using where |\n+----+--------------------+-------+------+---------------+------+---------+------+------+-------------+</pre>5.6.30：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_10_826543" name="code" class="plain">+----+--------------------+-------+------+---------------+------+---------+------------+------+-------------+\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |\n+----+--------------------+-------+------+---------------+------+---------+------------+------+-------------+\n| 1 | PRIMARY | a | ALL | NULL | NULL | NULL | NULL | 7 | Using where |\n| 2 | DEPENDENT SUBQUERY | tb | ref | uid | uid | 4 | test.a.uid | 1 | NULL |\n+----+--------------------+-------+------+---------------+------+---------+------------+------+-------------+</pre>写法3<br />&#13;\n直接改成join性能会更加好：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_11_7892394" name="code" class="sql">SELECT a.uid, a.ip, a.login_time\nFROM (SELECT uid, max(login_time) login_time\nFROM tb\nGROUP BY uid\n) b JOIN tb a ON a.uid = b.uid AND a.login_time = b.login_time;</pre>当然，结果都相同：<br />&#13;\n<pre code_snippet_id="2144206" snippet_file_name="blog_20170122_12_8513275" name="code" class="plain">+------+---------------+---------------------+\n| uid | ip | login_time |\n+------+---------------+---------------------+\n| 1003 | 192.168.1.153 | 2017-01-21 19:30:51 |\n| 1002 | 192.168.1.66 | 2017-01-21 19:12:32 |\n| 1001 | 192.168.1.231 | 2017-01-21 19:55:34 |\n+------+---------------+---------------------+</pre><span style="font-size:14px"><strong><span style="color:#FF0000">注：如果要分组取最小值直接改对应函数和符号就行了。</span></strong></span><br />&#13;\n<br />&#13;\n<p></p>&#13;\n &#13;\n
