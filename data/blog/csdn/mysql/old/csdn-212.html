\n\n<p><a target="_blank" href="http://blog.csdn.net/l1028386804/article/details/54578320">转载请注明出处：http://blog.csdn.net/l1028386804/article/details/54578320</a><br />&#13;\n</p>&#13;\n<h3>一、问题描述</h3>&#13;\n最近在做一个Java Web项目，框架为Spring MVC+JPA，使用c3p0连接池，发布环境为Tomcat 7，项目运行一段时间（大概几个小时），之后访问时会出现第一次访问报错，再次访问正常的现象，且多次出现此问题。以下是报错日志：<br />&#13;\n<p></p>&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_1_4082415" name="code" class="plain">org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is javax.persistence.PersistenceException: org.hibernate.TransactionException: JDBC begin transaction failed: \n at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:428) \n at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:372) \n at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:417) \n at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:255) \n at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:94) \n at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172) \n at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:631) \n at com.appcarcare.cube.service.UserService\n EnhancerByCGLIB\n a4429cba.getUserDao(&lt;generated&gt;) \n \n at com.appcarcare.cube.servlet.DataCenterServlet$SqlTimer.connectSql(DataCenterServlet.java:76) \n at com.appcarcare.cube.servlet.DataCenterServlet$SqlTimer.run(DataCenterServlet.java:70) \n at java.util.TimerThread.mainLoop(Timer.java:555) \n at java.util.TimerThread.run(Timer.java:505) \n Caused by: javax.persistence.PersistenceException: org.hibernate.TransactionException: JDBC begin transaction failed: \n at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1387) \n at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1310) \n \n at org.hibernate.ejb.AbstractEntityManagerImpl.throwPersistenceException(AbstractEntityManagerImpl.java:1397) \n at org.hibernate.ejb.TransactionImpl.begin(TransactionImpl.java:62) \n at org.springframework.orm.jpa.DefaultJpaDialect.beginTransaction(DefaultJpaDialect.java:71) \n at org.springframework.orm.jpa.vendor.HibernateJpaDialect.beginTransaction(HibernateJpaDialect.java:60) \n at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:378) \n ... 11 more \n Caused by: org.hibernate.TransactionException: JDBC begin transaction failed: \n at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.doBegin(JdbcTransaction.java:76) \n at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.begin(AbstractTransactionImpl.java:160) \n \n at org.hibernate.internal.SessionImpl.beginTransaction(SessionImpl.java:1426) \n at org.hibernate.ejb.TransactionImpl.begin(TransactionImpl.java:59) \n ... 14 more \n Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure \n \n The last packet successfully received from the server was 1,836,166 milliseconds ago. The last packet sent successfully to the server was 29,134 milliseconds ago. \n at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) \n at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) \n at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) \n at java.lang.reflect.Constructor.newInstance(Constructor.java:526) \n at com.mysql.jdbc.Util.handleNewInstance(Util.java:411) \n at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1117) \n at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3567) \n at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3456) \n \n at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3997) \n at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2468) \n at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2629) \n at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2713) \n at com.mysql.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:5060) \n at com.mchange.v2.c3p0.impl.NewProxyConnection.setAutoCommit(NewProxyConnection.java:881) \n at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.doBegin(JdbcTransaction.java:72) \n \n ... 17 more \n Caused by: java.net.SocketException: Software caused connection abort: recv failed \n at java.net.SocketInputStream.socketRead0(Native Method) \n at java.net.SocketInputStream.read(SocketInputStream.java:150) \n at java.net.SocketInputStream.read(SocketInputStream.java:121) \n at com.mysql.jdbc.util.ReadAheadInputStream.fill(ReadAheadInputStream.java:114) \n at com.mysql.jdbc.util.ReadAheadInputStream.readFromUnderlyingStreamIfNecessary(ReadAheadInputStream.java:161) \n at com.mysql.jdbc.util.ReadAheadInputStream.read(ReadAheadInputStream.java:189) \n at com.mysql.jdbc.MysqlIO.readFully(MysqlIO.java:3014) \n at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3467) \n ... 25 more</pre>&#13;\n<p></p>&#13;\n<h3>二、原因分析</h3>&#13;\n<p>MySQL服务器默认的“wait_timeout”是28800秒即8小时，意味着如果一个连接的空闲时间超过8个小时，MySQL将自动断开该连接，而连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致上面的报错</p>&#13;\n<h3>三、解决方案</h3>&#13;\n<p>解决这个问题的办法有三种，推荐第二种：<br />&#13;\n</p>&#13;\n<h4>1. 增加 MySQL 的 wait_timeout 属性的值 </h4>&#13;\n<p>修改mysql安装目录下的配置文件 my.ini文件（如果没有此文件，复制“my-default.ini”文件，生成“复件 my-default.ini”文件。将“复件 my-default.ini”文件重命名成“my.ini” ），在文件中设置<br />&#13;\n<span style="white-space:pre"><span style="font-size:12px"><span style="white-space:pre"><span style="white-space:pre"><span style="font-size:12px"><span style="white-space:pre"></span></span></span></span></span></span></p>&#13;\n<p><span style="white-space:pre"><span style="font-size:12px"></span></span></p>&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_2_9545082" name="code" class="plain">wait_timeout=31536000 \ninteractive_timeout=31536000</pre>这两个参数的默认值是8小时(60*60*8=28800)。<br />&#13;\n注意： 1.wait_timeout的最大值只允许2147483 （24天左右）<br />&#13;\n2.修改配置文件为网上大部分文章所提供的方式，也可以使用mysql命令对这两个属性进行修改<br />&#13;\n<img src="http://img.blog.csdn.net/20170116232309772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbDEwMjgzODY4MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n<p></p>&#13;\n<h4><span style="white-space:pre"></span>2. 减少连接池内连接的生存周期</h4>&#13;\n<p>减少连接池内连接的生存周期，使之小于上一项中所设置的wait_timeout 的值。 <br />&#13;\n修改 c3p0 的配置文件，在 Spring 的配置文件中设置：</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_3_9326931" name="code" class="html">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; \n &lt;property name="maxIdleTime"value="1800"/&gt; \n &lt;!--other properties --&gt; \n&lt;/bean&gt; </pre>&#13;\n<p></p>&#13;\n<h4>3. 定期使用连接池内的连接</h4>&#13;\n<p>定期使用连接池内的连接，使得它们不会因为闲置超时而被 MySQL 断开。 <br />&#13;\n修改 c3p0 的配置文件,在 Spring 的配置文件中设置<br />&#13;\n</p>&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_4_8519353" name="code" class="html">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; \n &lt;property name="preferredTestQuery" value="SELECT 1"/&gt; \n &lt;property name="idleConnectionTestPeriod" value="18000"/&gt; \n &lt;property name="testConnectionOnCheckout" value="true"/&gt; \n&lt;/bean&gt; </pre>&#13;\n<p></p>&#13;\n<h3>四、扩展</h3>&#13;\n<p>C3P0<br />&#13;\nC3P0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 c3p0配置文件<br />&#13;\n</p>&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_5_8268182" name="code" class="html">&lt;default-config&gt; \n　　&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; \n　　&lt;property name="acquireIncrement"&gt;3&lt;/property&gt; \n　　&lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; \n　　&lt;property name="acquireRetryAttempts"&gt;30&lt;/property&gt; \n　　&lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt; \n　　&lt;property name="acquireRetryDelay"&gt;1000&lt;/property&gt; \n　　&lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; \n　　&lt;property name="autoCommitOnClose"&gt;false&lt;/property&gt; \n　　&lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么 \n　　属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试 \n　　使用。Default: null--&gt; \n　　&lt;property name="automaticTestTable"&gt;Test&lt;/property&gt; \n　　&lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效 \n　　保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 \n　　获取连接失败后该数据源将申明已断开并永久关闭。Default: false--&gt; \n　　&lt;property name="breakAfterAcquireFailure"&gt;false&lt;/property&gt; \n　　&lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出 \n　　SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; \n　　&lt;property name="checkoutTimeout"&gt;100&lt;/property&gt; \n　　&lt;!--通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。 \n　　Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester--&gt; \n　　&lt;property name="connectionTesterClassName"&gt;&lt;/property&gt; \n　　&lt;!--指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可 \n　　Default: null--&gt; \n　　&lt;property name="factoryClassLocation"&gt;null&lt;/property&gt; \n　　&lt;!--Strongly disrecommended. Setting this to true may lead to subtle and bizarre bugs. \n　　（文档原文）作者强烈建议不使用的一个属性--&gt; \n　　&lt;property name="forceIgnoreUnresolvedTransactions"&gt;false&lt;/property&gt; \n　　&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; \n　　&lt;property name="idleConnectionTestPeriod"&gt;60&lt;/property&gt; \n　　&lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; \n　　&lt;property name="initialPoolSize"&gt;3&lt;/property&gt; \n　　&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; \n　　&lt;property name="maxIdleTime"&gt;60&lt;/property&gt; \n　　&lt;!--连接池中保留的最大连接数。Default: 15 --&gt; \n　　&lt;property name="maxPoolSize"&gt;15&lt;/property&gt; \n　　&lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements \n　　属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 \n　　如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0--&gt; \n　　&lt;property name="maxStatements"&gt;100&lt;/property&gt; \n　　&lt;!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 --&gt; \n　　&lt;property name="maxStatementsPerConnection"&gt;&lt;/property&gt; \n　　&lt;!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 \n　　通过多线程实现多个操作同时被执行。Default: 3--&gt; \n　　&lt;property name="numHelperThreads"&gt;3&lt;/property&gt; \n　　&lt;!--当用户调用getConnection()时使root用户成为去获取连接的用户。主要用于连接池连接非c3p0 \n　　的数据源时。Default: null--&gt; \n　　&lt;property name="overrideDefaultUser"&gt;root&lt;/property&gt; \n　　&lt;!--与overrideDefaultUser参数对应使用的一个参数。Default: null--&gt; \n　　&lt;property name="overrideDefaultPassword"&gt;password&lt;/property&gt; \n　　&lt;!--密码。Default: null--&gt; \n　　&lt;property name="password"&gt;&lt;/property&gt; \n　　&lt;!--定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意： \n　　测试的表必须在初始数据源的时候就存在。Default: null--&gt; \n　　&lt;property name="preferredTestQuery"&gt;select id from test where id=1&lt;/property&gt; \n　　&lt;!--用户修改系统配置参数执行前最多等待300秒。Default: 300 --&gt; \n　　&lt;property name="propertyCycle"&gt;300&lt;/property&gt; \n　　&lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的 \n　　时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable \n　　等方法来提升连接测试的性能。Default: false --&gt; \n　　&lt;property name="testConnectionOnCheckout"&gt;false&lt;/property&gt; \n　　&lt;!--如果设为true那么在取得连接的同时将校验连接的有效性。Default: false --&gt; \n　　&lt;property name="testConnectionOnCheckin"&gt;true&lt;/property&gt; \n　　&lt;!--用户名。Default: null--&gt; \n　　&lt;property name="user"&gt;root&lt;/property&gt;</pre>在Hibernate（spring管理）中的配置：<br />&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_6_4080297" name="code" class="html">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; \n　　&lt;property name="driverClass"&gt;&lt;value&gt;oracle.jdbc.driver.OracleDriver&lt;/value&gt;&lt;/property&gt; \n　　&lt;property name="jdbcUrl"&gt;&lt;value&gt;jdbc:oracle:thin:@localhost:1521:Test&lt;/value&gt;&lt;/property&gt; \n　　&lt;property name="user"&gt;&lt;value&gt;Kay&lt;/value&gt;&lt;/property&gt; \n　　&lt;property name="password"&gt;&lt;value&gt;root&lt;/value&gt;&lt;/property&gt; \n　　&lt;!--连接池中保留的最小连接数。--&gt; \n　　&lt;property name="minPoolSize" value="10" /&gt; \n　　&lt;!--连接池中保留的最大连接数。Default: 15 --&gt; \n　　&lt;property name="maxPoolSize" value="100" /&gt; \n　　&lt;!--最大空闲时间,1800秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; \n　　&lt;property name="maxIdleTime" value="1800" /&gt; \n　　&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; \n　　&lt;property name="acquireIncrement" value="3" /&gt; \n　　&lt;property name="maxStatements" value="1000" /&gt; \n　　&lt;property name="initialPoolSize" value="10" /&gt; \n　　&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; \n　　&lt;property name="idleConnectionTestPeriod" value="60" /&gt; \n　　&lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; \n　　&lt;property name="acquireRetryAttempts" value="30" /&gt; \n　　&lt;property name="breakAfterAcquireFailure" value="true" /&gt; \n　　&lt;property name="testConnectionOnCheckout" value="false" /&gt; \n　　&lt;/bean&gt; \n　　########################### \n　　### C3P0 Connection Pool### \n　　########################### \n　　#hibernate.c3p0.max_size 2 \n　　#hibernate.c3p0.min_size 2 \n　　#hibernate.c3p0.timeout 5000 \n　　#hibernate.c3p0.max_statements 100 \n　　#hibernate.c3p0.idle_test_period 3000 \n　　#hibernate.c3p0.acquire_increment 2 \n　　#hibernate.c3p0.validate false \n　　在hibernate.cfg.xml文件里面加入如下的配置： \n　　&lt;!-- 最大连接数 --&gt; \n　　&lt;property name="hibernate.c3p0.max_size"&gt;20&lt;/property&gt; \n　　&lt;!-- 最小连接数 --&gt; \n　　&lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt; \n　　&lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt; \n　　&lt;property name="hibernate.c3p0.timeout"&gt;120&lt;/property&gt; \n　　&lt;!-- 最大的PreparedStatement的数量 --&gt; \n　　&lt;property name="hibernate.c3p0.max_statements"&gt;100&lt;/property&gt; \n　　&lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt; \n　　&lt;property name="hibernate.c3p0.idle_test_period"&gt;120&lt;/property&gt; \n　　&lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt; \n　　&lt;property name="hibernate.c3p0.acquire_increment"&gt;2&lt;/property&gt; \n　　&lt;!-- 每次都验证连接是否可用 --&gt; \n　　&lt;property name="hibernate.c3p0.validate"&gt;true&lt;/property&gt;</pre>使用DBCP连接池时出现MySql 8小时断开连接的解决方法<br />&#13;\n修改l配置文件：<br />&#13;\n修改如下：<br />&#13;\n<pre code_snippet_id="2132025" snippet_file_name="blog_20170116_7_8256209" name="code" class="html">&lt;data-sources&gt; \n &lt;data-source key="org.apache.struts.action.DATA_SOURCE" type="org.apache.commons.dbcp.BasicDataSource"&gt; \n &lt;set-property property="driverClassName" value="com.mysql.jdbc.Driver" /&gt; \n &lt;set-property property="description" value="wjjg" /&gt; \n &lt;set-property property="url" value="jdbc:mysql://localhost/wjjg?useUnicode=true&amp;characterEncoding=GB2312" /&gt; \n &lt;set-property property="password" value="12345678" /&gt; \n &lt;set-property property="username" value="wjjg" /&gt; \n &lt;set-property property="maxActive" value="10" /&gt; \n &lt;set-property property="maxIdle" value="60000" /&gt; \n &lt;set-property property="maxWait" value="60000" /&gt; \n &lt;set-property property="defaultAutoCommit" value="true" /&gt; \n &lt;set-property property="defaultReadOnly" value="false" /&gt; \n &lt;set-property property="testOnBorrow" value="true"/&gt; \n &lt;set-property property="validationQuery" value="select 1"/&gt; \n&lt;/data-source&gt;</pre>其中testOnBorrow 和 validationQuery 很重要。<br />&#13;\ntestOnBorrow的意思是从数据库连接池中取得连接时，对其的有效性进行检查。<br />&#13;\nvalidationQuery 是用来检查的SQL语句，“select 1”执行较快，是一个不错的检测语句。<br />&#13;\n<br />&#13;\n<br />&#13;\n<p></p>&#13;\n &#13;\n
