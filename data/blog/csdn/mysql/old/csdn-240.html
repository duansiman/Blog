\n\n<p><a target="_blank" href="http://blog.csdn.net/l1028386804/article/details/51489772">转载请注明出处:http://blog.csdn.net/l1028386804/article/details/51489772</a><br />&#13;\n</p>&#13;\n<p>数据库提供了四种事务隔离级别, 不同的隔离级别采用不同的锁类开来实现. </p>&#13;\n<br />&#13;\n在四种隔离级别中, Serializable的级别最高, Read Uncommited级别最低. <br />&#13;\n<br />&#13;\n大多数数据库的默认隔离级别为: Read Commited,如Sql Server , Oracle. <br />&#13;\n<br />&#13;\n少数数据库默认的隔离级别为Repeatable Read, 如MySQL InnoDB存储引擎 <br />&#13;\n<br />&#13;\n即使是最低的级别,也不会出现 第一类 丢失 更新问题 .  <br />&#13;\n<br />&#13;\n1. 脏读(事务没提交，提前读取)：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。<br />&#13;\n<br />&#13;\n2. 不可重复读(两次读的不一致) ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。<br />&#13;\n3. 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。<br />&#13;\n4.第一类更新丢失(回滚丢失)： <br />&#13;\n  当2个事务更新相同的数据源，如果第一个事务被提交，而另外一个事务却被撤销，那么会连同第一个事务所做的跟新也被撤销。也就是说第一个事务做的跟新丢失了。 <br />&#13;\n5.第二类更新丢失(覆盖丢失)： <br />&#13;\n  第二类更新丢失实在实际应用中经常遇到的并发问题，他和不可重复读本质上是同一类并发问题，通常他被看做不可重复读的特例：当2个或这个多个事务查询同样的记录然后各自基于最初的查询结果更新该行时，会造成第二类丢失更新。因为每个事务都不知道不知道其他事务的存在，最后一个事务对记录做的修改将覆盖其他事务对该记录做的已提交的跟新...<br />&#13;\n补充 : 基于元数据的 Spring 声明性事务 : <br />&#13;\n<br />&#13;\nIsolation 属性一共支持五种事务设置，具体介绍如下： <br />&#13;\n<br />&#13;\nl          DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 . <br />&#13;\n<br />&#13;\nl          READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 ) <br />&#13;\n<br />&#13;\nl          READ_COMMITTED  会出现不可重复读、幻读问题（锁定正在读取的行） <br />&#13;\n<br />&#13;\nl          REPEATABLE_READ 会出幻读（锁定所读取的所有行） <br />&#13;\n<br />&#13;\nl          SERIALIZABLE 保证所有的情况不会发生（锁表） <br />&#13;\n<br />&#13;\n不可重复读的重点是修改 : <br />&#13;\n同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了 <br />&#13;\n幻读的重点在于新增或者删除 <br />&#13;\n同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样<br />&#13;\n<br />&#13;\n----------------------------------------------------------<br />&#13;\n事务传播行为种类<br />&#13;\n<br />&#13;\nSpring在TransactionDefinition接口中规定了7种类型的事务传播行为，<br />&#13;\n<br />&#13;\n它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播：<br />&#13;\n<br />&#13;\n表1事务传播行为类型<br />&#13;\n<br />&#13;\n事务传播行为类型<br />&#13;\n 说明<br />&#13;\n <br />&#13;\nPROPAGATION_REQUIRED<br />&#13;\n 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。<br />&#13;\n <br />&#13;\nPROPAGATION_SUPPORTS<br />&#13;\n 支持当前事务，如果当前没有事务，就以非事务方式执行。<br />&#13;\n <br />&#13;\nPROPAGATION_MANDATORY<br />&#13;\n 使用当前的事务，如果当前没有事务，就抛出异常。<br />&#13;\n <br />&#13;\nPROPAGATION_REQUIRES_NEW<br />&#13;\n 新建事务，如果当前存在事务，把当前事务挂起。<br />&#13;\n <br />&#13;\nPROPAGATION_NOT_SUPPORTED<br />&#13;\n 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br />&#13;\n <br />&#13;\nPROPAGATION_NEVER<br />&#13;\n 以非事务方式执行，如果当前存在事务，则抛出异常。<br />&#13;\n <br />&#13;\nPROPAGATION_NESTED<br />&#13;\n 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。<br />&#13;\n <br />&#13;\n ---------------------------------------------------------<br />&#13;\n simple就是什么模板都不要，xhtml是默认的，带一些struts2提供的模块，<br />&#13;\n例如有可能在你的表单中加入&lt;form ...&gt;&lt;table class="wwFormTable"&gt;&lt;/table&gt;&lt;/form&gt;  <br />&#13;\n主要是方便界面警告和错误消息处理以及页面验证<br />&#13;\n查看一下struts.properties<br />&#13;\n或<br />&#13;\norg/apache/struts2/default.properties<br />&#13;\nstruts.ui.theme=xhtml  <br />&#13;\nstruts.ui.templateDir=template  <br />&#13;\nstruts.ui.templateSuffix=ftl  <br />&#13;\n你可以在struts.xml中添加<br />&#13;\n&lt;constant name="struts.ui.theme" value="simple" /&gt;来修改这个参数<br />&#13;\n最后一个顾名思义就是结合css来处理这些内容。如果你初学可以不考虑这些，如果不希望这些模板内容对你的开发有影响可以改为simple。<br />&#13;\n如果要如果你的页面用了css布局，又想用struts2的增强功能就用css_xhtml，可以得到较好的用户体验。<br />&#13;\n &#13;\n &#13;\n
