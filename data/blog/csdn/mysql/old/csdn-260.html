\n\n<p><span style="font-size:18px">        本篇主要讲解MySQL中的外键约束。</span></p>&#13;\n<h1><span style="font-size:18px">         <span style="color:#ff0000">一约束概述</span></span></h1>&#13;\n<p><span style="font-size:18px">        创建约束的目的就是保证数据的完整性和一致性。约束根据约束针对的字段的数目的多少划分为表级约束和列级</span></p>&#13;\n<p><span style="font-size:18px">约束。</span></p>&#13;\n<p><span style="font-size:18px">        如果约束按照功能来划分的话刻印划分为：NOT NULL(非空约束)、PRIMARY KEY(主键约束)、UNIQUE </span></p>&#13;\n<p><span style="font-size:18px">KEY(唯一约束)、DEFAULT(默认约束)和FOREIGN KEY(外键约束)。</span></p>&#13;\n<p><span style="font-size:18px">        在前面我们已经初步涉及到了除外键约束之外的四个约束，这一次我们来谈谈最复杂的外键约束。</span></p>&#13;\n<h1><span style="font-size:18px">        <span style="color:#ff0000">二外键约束的要求</span></span></h1>&#13;\n<p><span style="font-size:18px">        FOREIGN KEY(外键约束)</span></p>&#13;\n<p><span style="font-size:18px">       创建外键约束的目的是保持数据一致性，完整性；以及实现一对一或一对多关系。由于外键约束相较于其它四个</span></p>&#13;\n<p><span style="font-size:18px">约束复杂，因此外键约束的要求有以下：</span></p>&#13;\n<p><span style="font-size:18px">       1)父表和子表必须使用相同的存储引擎，而且禁止使用临时表。说到父表和子表，看看它们的定义：子表指的是</span></p>&#13;\n<p><span style="font-size:18px">具有外键列的表称为子表；父表指的是子表所参照的表称为父表。</span></p>&#13;\n<span style="font-size:18px">       2)数据表的存储引擎只能为InnoDB。<br />&#13;\n</span>&#13;\n<p><span style="font-size:18px">       3)外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不</span></p>&#13;\n<p><span style="font-size:18px">同。说到外键列和参照列，先来看看定义：外键列指的是列上加FOREIGN KEY关键字的列称为外键列；参照列指的</span></p>&#13;\n<p><span style="font-size:18px">是外键列所参照的列称为参照列。</span></p>&#13;\n<p><span style="font-size:18px">       4)外键列和参照列必须创建索引。如果外键不存在索引的话，MySQL将自动创建索引。如果参照列不存在索引的</span></p>&#13;\n<p><span style="font-size:18px">话，MySQL不会自动创建索引。</span></p>&#13;\n<h1><span style="font-size:18px">       <span style="color:#ff0000">三存储引擎</span></span></h1>&#13;\n<p><span style="font-size:18px">       由于创建外键约束需要了解存储引擎，这里只是简单说明一下。</span></p>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(1)什么是存储引擎</span></span></h2>&#13;\n<p><span style="font-size:18px">       存储引擎也叫表类型，指的是数据表的存储机制、索引方案等配套相关功能。不同引擎由于处理方式不同，会带</span></p>&#13;\n<p><span style="font-size:18px">来不同的功能或者功能的优化，根据实际需要选择合适的存储引擎。存储引擎类型分为MyISAM与InnoDB。</span></p>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(2)MyISAM与InnoDB区别</span></span></h2>&#13;\n<span style="font-size:18px">       1)InnoDB支持外键，MyISAM不支持。<br />&#13;\n</span>&#13;\n<p><span style="font-size:18px">       2)MyISAM每个表会生成3个文件: table.MYI(索引文件)、table.MYD(数据文件)、table.frm(表结构文件)</span></p>&#13;\n<p><span style="font-size:18px">       Innodb每个表只有一个table.frm文件，所有的Innodb引擎的表的数据将存放在ibdata*里面。</span></p>&#13;\n<p><span style="font-size:18px">       3)MyISAM支持表级锁，优势在于插入和检索，Innodb支持行级锁，优势在于更新和删除。</span></p>&#13;\n<p><span style="font-size:18px">       4)Innodb支持事务。</span></p>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(3)编辑数据表的默认存储引擎</span></span></h2>&#13;\n<p><span style="font-size:18px">       1)首先在MySQL安装目录中找到MySQL的配置文件MY.ini，双击打开；</span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509154604250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       2)查看是否有：default-storage-engine=INNODB</span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509154612729?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       3)修改后需要重新启动MySQL服务，否则不用重新启动。</span></p>&#13;\n<h1><span style="font-size:18px">       <span style="color:#ff0000">四创建外键约束</span></span></h1>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(1)创建一个省份数据表作为父表，然后查看数据表的创建信息确认是否引擎为InnoDB：</span></span></h2>&#13;\n<p><span style="font-size:18px">       <span style="color:#ff6600">CREATE TABLE provinces(</span></span></p>&#13;\n<p><span style="font-size:18px; color:#ff6600">          id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span></p>&#13;\n<p><span style="font-size:18px; color:#ff6600">          pname VARCHAR(20) NOT NULL</span></p>&#13;\n<p><span style="font-size:18px"><span style="color:#ff6600">       ); </span></span></p>&#13;\n<p><span style="font-size:18px; color:#ff6600">       SHOW CREATE TABLE provinces;</span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509154720870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       由此我们保证了创建数据表的时候保证了数据表使用的是默认引擎InnoDB。下面的users表同样也是InnoDB。</span></p>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(2)使用外键约束创建另一个相似的数据表作为子表。</span></span></h2>&#13;\n<p><span style="font-size:18px">       CREATE TABLE users(</span></p>&#13;\n<p><span style="font-size:18px">          id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span></p>&#13;\n<p><span style="font-size:18px">          username VARCHAR(10) NOT NULL,</span></p>&#13;\n<p><span style="font-size:18px">          <span style="color:#ff6600">pid BIGINT,</span></span></p>&#13;\n<p><span style="font-size:18px">          FOREIGN KEY (pid) REFERENCES provinces (id)</span></p>&#13;\n<p><span style="font-size:18px">        ); </span></p>&#13;\n<p><span style="font-size:18px">       以上创建数据表会有错误信息：需要保证数据类型一致。</span></p>&#13;\n<p><span style="font-size:18px">       修改为数据类型一致，默认为有符号位：</span></p>&#13;\n<p><span style="font-size:18px">       CREATE TABLE users(</span></p>&#13;\n<p><span style="font-size:18px">          id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span></p>&#13;\n<p><span style="font-size:18px">          username VARCHAR(10) NOT NULL,</span></p>&#13;\n<p><span style="font-size:18px">          <span style="color:#ff6600">pid SMALLINT,</span></span></p>&#13;\n<p><span style="font-size:18px">          FOREIGN KEY (pid) REFERENCES provinces (id)</span></p>&#13;\n<p><span style="font-size:18px">       ); </span></p>&#13;\n<p><span style="font-size:18px">      依然会有错误信息：这一次是是否保持相同的有无符号位。</span></p>&#13;\n<p><span style="font-size:18px">      修改为一致的数据类和是否有符号位：</span></p>&#13;\n<p><span style="font-size:18px">       CREATE TABLE users(</span></p>&#13;\n<p><span style="font-size:18px">           id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span></p>&#13;\n<p><span style="font-size:18px">           username VARCHAR(10) NOT NULL,</span></p>&#13;\n<p><span style="font-size:18px">           <span style="color:#ff6600">pid SMALLINT UNSIGNED,</span></span></p>&#13;\n<p><span style="font-size:18px">           FOREIGN KEY (pid) REFERENCES provinces (id)</span></p>&#13;\n<p><span style="font-size:18px">      ); </span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509154856457?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       创建数据表的过程我们知道了子表是users，父表是provinces；子表users中的pid是外键列，父表provinces中的</span></p>&#13;\n<p><span style="font-size:18px">id字段是参照列。由此我们保证了外键列和参照列必须</span><span style="font-size:18px">具有相似的数据类型。</span></p>&#13;\n<h2><span style="font-size:18px">       <span style="color:#000099">(3)查看外键列和参照列是否创建索引</span></span></h2>&#13;\n<h3><span style="font-size:18px">       <span style="color:#33cc00">1)查看父表provinces中的参照列id是否自动创建索引：</span></span></h3>&#13;\n<p><span style="font-size:18px">       <span style="color:#ff6600">SHOW INDEXES FROM provinces;</span></span></p>&#13;\n<p><span style="font-size:18px; color:#ff6600">       SHOW INDEXES FROM provinces\\G;</span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509155100747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       以上均表明参照列已经创建索引，我们更习惯看出索引列的是第二种命令，因此一般我们会使用后者。</span></p>&#13;\n<h3><span style="font-size:18px">       <span style="color:#33cc00">2)再来查看外键列是否创建索引</span></span></h3>&#13;\n<p><span style="font-size:18px">       <span style="color:#ff6600">SHOW INDEXES FROM users\\G;</span></span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509155115006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">       以上结果表明数据表users存在两个索引列，一个是users表的id字段，一个是外键列pid字段，它的参照列是父表</span></p>&#13;\n<p><span style="font-size:18px">provinces中</span><span style="font-size:18px">的参照列id字段。</span></p>&#13;\n<p><span style="font-size:18px">       我们也可以查看user表中的pid是不是外键列</span></p>&#13;\n<p><span style="font-size:18px">       <span style="color:#ff6600">SHOW CREATE TABLE users;</span></span></p>&#13;\n<p style="text-align:center"><span style="font-size:18px"><img src="http://img.blog.csdn.net/20160509155321291?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px">        由此证明users数据表中的pid字段的确是外键约束，经过以上步骤我们成功的使用了外键约束。还有许多关系与</span></p>&#13;\n<p><span style="font-size:18px">外键约束的操作，我们就不再过多的介绍。</span></p>&#13;\n<p><span style="font-size:18px"><br />&#13;\n</span></p>&#13;\n<p><span style="font-size:18px"><br />&#13;\n</span></p>&#13;\n<br />&#13;\n &#13;\n
