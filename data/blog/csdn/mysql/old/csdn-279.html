\n <div class="markdown_views"><h1 id="b-tree">B-tree</h1>\n\n<p>B-Tree又叫平衡多路查找树（并不是二叉的）使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。 <br />\n左子节点关键字值&lt;该关键字值&lt;右子节点关键字值 <br />\n在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。 <br />\n<img src="http://img.blog.csdn.net/20160802170440756" alt="这里写图片描述" title="" /> <br />\n（key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据）</p>\n\n\n\n<h1 id="btree">B+tree</h1>\n\n<p>B+Tree是一种改进后的B-tree。 <br />\n<img src="http://img.blog.csdn.net/20160802170534757" alt="这里写图片描述" title="" /> <br />\n（key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据）</p>\n\n<p>与B-Tree相比，B+Tree有以下不同点：</p>\n\n<ul>\n<li>每个节点的指针上限为2d而不是2d+1。</li>\n<li>内节点不存储data，只存储key；叶子节点不存储指针。</li>\n</ul>\n\n<h1 id="那数据库为什么使用b-tree">那数据库为什么使用B-tree</h1>\n\n<p>计算机的机械磁盘，为了摊还机械移动花费的等待时间，磁盘会一次存取多个数据项而不是一个，这样的一次读取的信息单元是page，我们可以用读或写的<strong>页数</strong>作为磁盘存取<strong>总时间</strong>的主要近似值，在任何时刻，B树算法都只需在内存中保持一定数量的页面。B树的设计考虑磁盘预读取这点，<strong>一个B树的节点通常和一个完整磁盘页（page）一样大</strong>，并且磁盘页的大小限制了一个B树节点可以含有的孩子个数（分支因子），当然这个具体也需要取决于一个关键字相对一页的大小。</p>\n\n<p>为了尽量减少I/O操作，磁盘读取每次都会预读，大小通常为页的整数倍。即使只需要读取一个字节，磁盘也会读取一页的数据(通常为4K)放入内存，内存与磁盘以页为单位交换数据。因为局部性原理认为，通常一个数据被用到，其附近的数据也会立马被用到。</p>\n\n<p>B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。<strong>数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了</strong>。</p>\n\n<p>B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，<strong>树更矮了，I/O操作更少了</strong>。所以B+Tree拥有更好的性能。</p>\n\n\n\n<h1 id="什么是索引">什么是索引</h1>\n\n<p>索引说白了就是一种数据结构。</p>\n\n\n\n<h1 id="索引的代价">索引的代价</h1>\n\n<p>索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引 <br />\n第一种情况是表记录比较少 <br />\n另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性(Selectivity)，是指不重复的索引值(也叫基数，Cardinality)与表记录数(#T)的比值</p>\n\n\n\n<h1 id="索引的类别">索引的类别</h1>\n\n<p>一、普通索引 <br />\n二、唯一索引 <br />\n三、主键索引 <br />\n四、组合索引</p>\n\n\n\n<h1 id="mysql中使用的索引">MySQL中使用的索引</h1>\n\n<p>MySQL中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同。</p>\n\n\n\n<h1 id="聚集索引与非聚集索引">聚集索引与非聚集索引</h1>\n\n<p>所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键。如下图： <br />\n<img src="http://img.blog.csdn.net/20160802144854176" alt="这里写图片描述" title="" /> <br />\n（t1表） <br />\n<img src="http://img.blog.csdn.net/20160802144946724" alt="这里写图片描述" title="" /> <br />\n（t2表） <br />\n<img src="http://img.blog.csdn.net/20160802144751690" alt="这里写图片描述" title="" /> <br />\n（数据库对应的文件） <br />\n因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>\n\n\n\n<h1 id="mysql数据库中myisam和innodb数据存储引擎">MySQL数据库中MyISAM和InnoDB数据存储引擎</h1>\n\n<p>主要区别： <br />\nMyISAM是非事务安全型的，而InnoDB是事务安全型的。 <br />\nMyISAM锁的粒度是表级，而InnoDB支持行级锁定。 <br />\nMyISAM支持全文类型索引，而InnoDB不支持全文索引。 <br />\nMyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。 <br />\nMyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。 <br />\nInnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。 <br />\n应用场景： <br />\nMyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。 <br />\nInnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p>\n\n\n\n<h1 id="补充">补充</h1>\n\n\n\n<h2 id="主存的存">主存的存</h2>\n\n<p>取过程 <br />\n当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。 <br />\n写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。 <br />\n这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的</p>\n\n\n\n<h2 id="磁盘存取原理">磁盘存取原理</h2>\n\n<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>\n\n<p>参考：<a href="http://blog.jobbole.com/24006/">http://blog.jobbole.com/24006/</a></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
