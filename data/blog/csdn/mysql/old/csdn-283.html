\n <div class="markdown_views"><h1 id="前言">前言</h1>\n\n<p>当对MySQL进行大量的增删改操作的时候，很容易产生一些碎片，这些碎片占据着空间，所以可能会出现删除很多数据后，数据文件大小变化不大的现象。当然新插入的数据仍然会利用这些碎片。但过多的碎片，对数据的插入操作是有一定影响的，此时，我们可以通过optimize来对表的优化。 <br />\n为了更加直观的看到数据碎片，Mysql可以使用如下命令查看 <br />\nshow table status [like table_name] <br />\n如下图 <br />\n<img src="http://img.blog.csdn.net/20160523214512718" alt="这里写图片描述" title="" /> <br />\ndata_free选项代表数据碎片。 <br />\n针对MySQL的不同数据库存储引擎，在optimize使用清除碎片，回收闲置的数据库空间，把分散存储（fragmented）的数据和索引重新挪到一起(defragmentation)，对I/O速度有好处。 <br />\n当然optimize在对表进行操作的时候，会加锁，所以不宜经常在程序中调用。</p>\n\n<h1 id="myisam存储引擎">MyISAM存储引擎</h1>\n\n<p>针对MyISAM表，直接使用如下命令进行优化 <br />\noptimize table table1[,table2][,table3] <br />\n 如果同时优化多个表可以使用逗号分隔。 <br />\n 下面优化dede_member_vhistory表，可以看出，优化后data_free值为0。 <br />\n <img src="http://img.blog.csdn.net/20160523215125048" alt="这里写图片描述" title="" /> <br />\n #InnoDB存储引擎 <br />\n InnoDB引擎的表分为独享表空间和同享表空间的表，我们可以通过show variables like ‘innodb_file_per_table’;来查看是否开启独享表空间。</p>\n\n<p>我本地是开启了独享表空间的。此时是无法对表进行optimize操作的，如果操作，会返回如图信息，最后的一条Table does not support optimize, doing recreate + analyze instead。因为该结构下删除了大量的行，此时索引会重组并且会释放相应的空间因此不必优化。 <br />\n<img src="http://img.blog.csdn.net/20160523220114038" alt="这里写图片描述" title="" /></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
