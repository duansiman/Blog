\n\n<p><a target="_blank" href="http://blog.csdn.net/l1028386804/article/details/50729565">转载请注明出处:http://blog.csdn.net/l1028386804/article/details/50729565</a><br />&#13;\n</p>&#13;\n<p>这篇文章主要介绍了Mysql数据表分区技术PARTITION浅析,分别介绍了 Mysql 中的分区技术 RANGE、LIST、 HASH,需要的朋友可以参考下。</p>&#13;\n<p></p>&#13;\n<p>在这一章节里， 我们来了解下 Mysql 中的分区技术 (RANGE, LIST, HASH)<br />&#13;\n <br />&#13;\nMysql 的分区技术与水平分表有点类似， 但是它是在逻辑层进行的水平分表， 对于应用而言它还是一张表， 换句话说: 分区不是实际真正的对一张表进行拆分，分区之后表还是一个表，它是把存储文件进行拆分。</p>&#13;\n<h3>在 Mysql 5.1(后) 有了几种分区类型:<br />&#13;\n</h3>&#13;\n<p></p>&#13;\n<p>RANGE分区: 基于属于一个给定连续区间的列值， 把多行分配给分区</p>&#13;\n<p>LIST分区: 类似于按 RANGE 分区， 区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择</p>&#13;\n<p>HASH分区: 基于用户定义的表达式的返回值来进行选择分区， 该表达式使用将要插入到表中的这些行的列值进行计算， 这个函数可以包含 Mysql 中有效的、产生非负整数值的任何表达式</p>&#13;\n<p>KEY分区: 累世于按 HASH 分区， 区别在于 KEY 分区只支持计算一列或多列， 且 Mysql 服务器提供其自身的哈希函数<br />&#13;\n</p>&#13;\n<h3>分区应该注意的事项：</h3>&#13;\n<p>1、 做分区时，要么不定义主键，要么把分区字段加入到主键中<br />&#13;\n2、 分区字段不能为NULL，要不然怎么确定分区范围呢，所以尽量 NOT NULL<br />&#13;\n <br />&#13;\n首先你可以查看下你的 Mysql 版本是否支持 PARTITION</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_1_9257494" name="code" class="plain">mysql&gt; show plugins;\n \n| partition | ACTIVE | STORAGE ENGINE | NULL | GPL |</pre>或者:&#13;\n<p></p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_2_1482342" name="code" class="plain">mysql&gt; show variables like "%part%";\n \n+-------------------+-------+\n| Variable_name | Value |\n+-------------------+-------+\n| have_partitioning | YES |\n+-------------------+-------+</pre>&#13;\n<p></p>&#13;\n<h3><strong>RANGE 分区</strong></h3>&#13;\n<p>假定你创建了一个如下的表， 该表保存有20家音像店的职员记录， 这20家音像店的编号从1到20。 如果你想将其分成4个小分区， 那么你可以采用RANGE分区， 创建的数据库表如下:</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_3_4720945" name="code" class="plain">mysql-&gt; CREATE TABLE employees (\n -&gt; id INT NOT NULL,\n -&gt; fname VARCHAR(30),\n -&gt; lname VARCHAR(30),\n -&gt; hired DATE NOT NULL DEFAULT '1970-01-01',\n -&gt; separated DATE NOT NULL DEFAULT '9999-12-31',\n -&gt; job_code INT NOT NULL,\n -&gt; store_id INT NOT NULL\n -&gt; ) ENGINE=Myisam DEFAULT CHARSET=utf8\n -&gt; PARTITION BY RANGE (store_id) (\n -&gt; PARTITION P0 VALUES LESS THAN (6),\n -&gt; PARTITION P1 VALUES LESS THAN (11),\n -&gt; PARTITION P2 VALUES LESS THAN (16),\n -&gt; PARTITION P3 VALUES LESS THAN (21)\n -&gt; );</pre>如果你想把不同时期离职的员工进行分别存储， 那么你可以将日期字段 separated (即离职时间) 作为一个 key, 创建的 SQL 语句如下:<br />&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_4_2386631" name="code" class="plain">mysql-&gt; CREATE TABLE employees (\n -&gt; id INT NOT NULL,\n -&gt; fname VARCHAR(30),\n -&gt; lname VARCHAR(30),\n -&gt; hired DATE NOT NULL DEFAULT '1970-01-01',\n -&gt; separated DATE NOT NULL DEFAULT '9999-12-31',\n -&gt; job_code INT NOT NULL,\n -&gt; store_id INT NOT NULL\n -&gt; ) ENGINE=Myisam DEFAULT CHARSET=utf8\n -&gt; PARTITION BY RANGE (YEAR(separated)) (\n -&gt; PARTITION P0 VALUES LESS THAN (2001),\n -&gt; PARTITION P1 VALUES LESS THAN (2011),\n -&gt; PARTITION P2 VALUES LESS THAN (2021),\n -&gt; PARTITION P3 VALUES LESS THAN MAXVALUE\n -&gt; );</pre>&#13;\n<p></p>&#13;\n<h3><strong>List 分区</strong></h3>&#13;\n<p>同样的例子， 如果这20家影像店分布在4个有经销权的地区，<br />&#13;\n</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_5_7228417" name="code" class="plain">+------------------+--------------------------------------+\n| 地区 | 音像店 ID 号 |\n+------------------+--------------------------------------+\n| 北区 | 3, 5, 6, 9, 17 |\n| 东区 | 1, 2, 10, 11, 19, 20 |\n| 西区 | 4, 12, 13, 14, 18 |\n| 中心区 | 7, 8, 15, 16 |\n+------------------+--------------------------------------+\n \nmysql-&gt; CREATE TABLE employees (\n -&gt; id INT NOT NULL,\n -&gt; fname VARCHAR(30),\n -&gt; lname VARCHAR(30),\n -&gt; hired DATE NOT NULL DEFAULT '1970-01-01',\n -&gt; separated DATE NOT NULL DEFAULT '9999-12-31',\n -&gt; job_code INT NOT NULL,\n -&gt; store_id INT NOT NULL\n -&gt; ) ENGINE=Myisam DEFAULT CHARSET=utf8\n -&gt; PARTITION BY LIST (store_id) (\n -&gt; PARTITION pNorth VALUES IN (3, 5, 6, 9, 17),\n -&gt; PARTITION pEast VALUES IN (1, 2, 10, 11, 19, 20),\n -&gt; PARTITION pWest VALUES IN (4, 12, 13, 14, 18),\n -&gt; PARTITION pCentral VALUES IN (7, 8, 15, 16)\n -&gt; );</pre>当你创建完之后， 你可以进入 Mysql 数据储存文件， 该文件夹位置定义在 Mysql 配置文件中<br />&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_6_8515173" name="code" class="plain">shawn@Shawn:~$ sudo vi /etc/mysql/my.cnf;\n \n[mysqld]\ndatadir = /var/lib/mysql\n \nshawn@Shawn:~$ cd /var/lib/mysql/dbName\nshawn@Shawn:/var/lib/mysql/dbName$ ll\n \n显示如下:\n8768 Jun 7 22:01 employees.frm\n 48 Jun 7 22:01 employees.par\n 0 Jun 7 22:01 employees#P#pCentral.MYD\n1024 Jun 7 22:01 employees#P#pCentral.MYI\n 0 Jun 7 22:01 employees#P#pEast.MYD\n1024 Jun 7 22:01 employees#P#pEast.MYI\n 0 Jun 7 22:01 employees#P#pNorth.MYD\n1024 Jun 7 22:01 employees#P#pNorth.MYI\n 0 Jun 7 22:01 employees#P#pWest.MYD\n1024 Jun 7 22:01 employees#P#pWest.MYI</pre>从这里可以看出， 它是把存储文件根据我们的定义进行了拆分<br />&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_7_2833572" name="code" class="plain">employees.frm = 表结构\nemployees.par = partition, 申明是一个分区表\n.MYD = 数据文件\n.MYI = 索引文件</pre>&#13;\n<p></p>&#13;\n<h3><strong>HASH 分区</strong></h3>&#13;\n<p>HASH 分区主要用来确保数据在预先确定数目的分区中平均分布<br />&#13;\n如果你想把不同时期加入的员工进行分别存储， 那么你可以将日期字段 hired 作为一个 key<br />&#13;\n</p>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_8_1263408" name="code" class="plain">mysql-&gt; CREATE TABLE employees (\n -&gt; id INT NOT NULL,\n -&gt; fname VARCHAR(30),\n -&gt; lname VARCHAR(30),\n -&gt; hired DATE NOT NULL DEFAULT '1970-01-01',\n -&gt; separated DATE NOT NULL DEFAULT '9999-12-31',\n -&gt; job_code INT NOT NULL,\n -&gt; store_id INT NOT NULL\n -&gt; ) ENGINE=Myisam DEFAULT CHARSET=utf8\n -&gt; PARTITION BY HASH (YEAR(hired)) (\n -&gt; PARTITIONS 4\n -&gt; );\n \n#这里注意的是 PARTITIONS， 多了一个 s</pre>这里要提一下的就是， 如上的例子都是使用的是 Myisam 存储引擎，它默认使用独立表空间， 所以你可以在上面的磁盘空间里看到不同的分区<br />&#13;\n而 InnoDB 引擎则默认使用共享表空间, 此时就算你对 InnoDB 表进行分区， 你查看下会发现， 它并没有像 Myisam 那么样进行物理上的分区， 所以你需要修改下 Mysql 配置文件:<br />&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_9_4153347" name="code" class="plain">shawn@Shawn:~$ sudo vi /etc/mysql/my.cnf;\n \n#添加:\ninnodb_file_per_table=1\n \n#重启 mysql\nshawn@Shawn:~$ sudo /etc/init.d/mysql restart</pre>此时你再对 InooDB 进行分区， 则会有如下效果:<br />&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_10_7358930" name="code" class="plain">8768 Jun 7 22:54 employees.frm\n 48 Jun 7 22:54 employees.par\n98304 Jun 7 22:54 employees#P#pCentral.ibd\n98304 Jun 7 22:54 employees#P#pEast.ibd\n98304 Jun 7 22:54 employees#P#pNorth.ibd\n98304 Jun 7 22:54 employees#P#pWest.ibd</pre>&#13;\n<p></p>&#13;\n<h3><strong>分区管理</strong></h3>&#13;\n<h4><strong>删除分区</strong><br />&#13;\n</h4>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_11_4708972" name="code" class="plain">mysql&gt; alter table employees drop partition pWest; </pre>&#13;\n<p></p>&#13;\n<h4><strong>新增分区</strong></h4>&#13;\n<p></p>&#13;\n<pre code_snippet_id="1586575" snippet_file_name="blog_20160224_12_1535625" name="code" class="plain">#range添加新分区 \nmysql&gt; alter table employees add partition ( partition p4 values less than (26) ); \n \n#list添加新分区 \nmysql&gt; alter table employees add partition( partition pSouth values in (21, 22, 23) ); \n \n#hash重新分区 \nmysql&gt; alter table employees add partition partitions 5; </pre><br />&#13;\n<p></p>&#13;\n &#13;\n
