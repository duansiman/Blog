\n\n<p>本文讨论MySQL支持的索引类型及其优缺点。要注意的是：在MySQL中，索引是在存储引擎层而不是服务器层实现，所以不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<h3>B+树索引</h3>&#13;\n<p>B+树是一种经典的数据结构，由平衡树和二叉查找树结合产生，它是为磁盘或其它直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有的记录节点都是按键值大小顺序存放在同一层的叶节点中，叶节点间用指针相连，构成双向循环链表，非叶节点（根节点、枝节点）只存放键值，不存放实际数据。下面看一个2层B+树的例子：</p>&#13;\n<p><img src="http://img.blog.csdn.net/20130613105420656" alt="" /><br />&#13;\n</p>&#13;\n<p>保持树平衡主要是为了提高查询性能，但为了维护树的平衡，成本也是巨大的，当有数据插入或删除时，需采用拆分节点、左旋、右旋等方法。B+树因为其高扇出性，所以具有高平衡性，通常其高度都在2~3层，查询时可以有效减少IO次数。</p>&#13;\n<p>对于B+树复合索引来说，索引列的顺序非常重要，如果不是按照索引的最左列开始查找，则无法使用索引，也不能跳过索引中的列。下面是一个复合索引的例子：</p>&#13;\n<div><pre name="code" class="sql">alter table t add key idx_a_b(a,b);</pre></div>&#13;\n<div>下图是它的结构图：</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<div><img src="http://img.blog.csdn.net/20130613113850421" alt="" /><br />&#13;\n</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<div>很显然，对于where a = xxx and b=xxx 这样的语句是可以使用这个复合索引的。现在看看对单个列的情况，where a = xxx也是可以使用该复合索引，因为a列在复合索引中也是有序的，但对于where b =xxx 这样的语句是无法使用该复合索引，因为它是无序的。</div>&#13;\n<br />&#13;\n<p></p>&#13;\n<h3>哈希索引</h3>&#13;\n<div>哈希索引基于哈希表，只有精确匹配索引所有列的查询才有效。在MySQL中，只有Memory引擎显示支持哈希索引。</div>&#13;\n<div>因为索引本身只需要存储对应的哈希值，所以索引的结构非常紧凑，这也让哈希索引的查找速度非常快，但它只支持等值比较，所以只适用于某些特定的场合。</div>&#13;\n<div>InnoDB有一个特殊的功能叫做“自适应哈希索引”，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”（详见《<a target="_blank" href="http://blog.csdn.net/dbanote/article/details/9074641">MySQL - 浅谈InnoDB体系架构</a>》中内存构造）建立哈希索引。之所以该技术称为“自适应”是因为完全由InnoDB自己决定，不需要DBA人为干预。它是通过缓冲池中的B+树构造而来，且不需要对整个表建立哈希索引，因此它的数据非常快。InnoDB官方文档显示，启用自适应哈希索引后，读和写性能可以提高2倍，对于辅助索引的连接操作，性能可以提高5被，因此默认情况下为开启，我们可以通过参数innodb_adaptive_hash_index来禁用此特性。</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<h3>空间数据索引（R-Tree）</h3>&#13;\n<div>MyISAM支持空间索引，可以用作地理数据存储，和B树索引不同的是，它从所有维度索引数据，无需前缀查询。查询时，可以有效地使用任意维度来组合查询。</div>&#13;\n<div><br />&#13;\n</div>&#13;\n<h3>全文索引</h3>&#13;\n<div>全文索引是一种特殊类型的索引，它查找的是文本中的关键字，而不是直接比较索引中的值。全文索引更类似于搜索引擎做的事情，而不是简单的where条件匹配。</div>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><br />&#13;\n</p>&#13;\n &#13;\n
