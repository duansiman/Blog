\n <div class="markdown_views"><h4 id="事务">事务</h4>\n\n\n\n<h5 id="什么是事务">什么是事务</h5>\n\n<p>一个事务由作为一个单独单元的一个或者多个sql语句组成。这个单元中的每个sql语句是互相依赖的， 而且单元作为一个整体是不可分割的。如果单元中的一个语句不能成功完成，整个单元都会回滚，所有影响到的数据将返回到 事务开始之前的状态。因而，只有事务中的所有语句都被成功的执行才能说这个事务被成功执行。</p>\n\n<p>事务的四个特性：</p>\n\n<p>原子性（Atomicity），每个事务都必须被认为是一个不可分割的单元。</p>\n\n<p>一致性（Consistency），不管事务是完全成功还是中途失败，当事务使系统处于一致的状态时存在一致性。</p>\n\n<p>隔离性（Isolation），每个事务在它自己的空间发生，和其他发生在系统中的事务隔离，而且事务的结果只有在它完全被执行时才能看到。</p>\n\n<p>持久性（Durability），即使系统崩溃，一个提交的事务扔在坚持。</p>\n\n\n\n<h5 id="生命周期">生命周期</h5>\n\n<p>为了初始化一个事务，并告诉MySQL所有随后的sql语句需要被认为是一个单元，MySQL提供了start transaction命令来标记 一个事务的开始。也可以使用begin或者begin work命令来初始化一个事务。通常情况下，start transction命令后跟随的 是组成事务的sql语句。</p>\n\n<p>一旦sql语句被执行，就可使用commit命令来把整个事务保存在磁盘上，或者使用rollback命令来撤销所有的变化。 如果事务包括事务表和非事务表的变化，非事务表的事务处理部分是不能使用rollback命令撤销的。在这种情况下， MySQL将会返回一个错误，通知出现一个不完全撤销。 <br />\ncommit命令标记了事务块的结束。</p>\n\n\n\n<h5 id="控制事务行为">控制事务行为</h5>\n\n<p>MySQL提供了两个变量来控制事务行为：autocommit变量和transaction isolation level变量。 <br />\n自动提交，默认情况下，MySQL的sql查询一旦被执行，就会自动向数据库提交结果。这种默认的行为可以通过特定的 autocommit变量来进行修改。设置set autocommit=0，随后表的更新将不会被保存，直到明确发出一个commit命令。</p>\n\n<p>事务隔离级，MySQL默认为repeatable read隔离级，可以使用set来修改。</p>\n\n\n\n<h4 id="事务和性能">事务和性能</h4>\n\n<p>因为支持事务的数据库在保持不同用户彼此隔离方面要比非事务数据库难，所以自然的反应了系统的性能。 <br />\n我们需要做一些事情来保证事务不会向系统添加不适当的负担。</p>\n\n<p>使用小事务，两个普遍的策略： <br />\n1：保证所有要求的用户输入在发出start transaction命令之前都是可行的 <br />\n2：尝试把大的事务分成小的事务然后分别执行。</p>\n\n<p>选择合适的隔离级，隔离级越高，性能越低，所以选择合适的孤立级，有助于性能优化</p>\n\n<p>避免死锁，在一个事务环境中，当两个或者多个处于不同序列的客户同时想要更新相同的数据时，就会发生死锁，我们应该 避免发生死锁。</p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
