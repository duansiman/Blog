\n<h1 style="text-align: center;"><strong>防御SQL注入的方法总结</strong></h1><p align="justify">      这篇文章主要讲解了防御SQL注入的方法，介绍了什么是注入，注入的原因是什么，以及如何防御,需要的朋友可以参考下。</p><p align="justify">      SQL注入是一类危害极大的攻击形式。虽然危害很大，但是防御却远远没有XSS那么困难。</p><p align="justify">     SQL注入可以参见：<a target="_blank" href="https://en.wikipedia.org/wiki/SQL_injection"><u><span style="color:rgb(0, 0, 255);">https://en.wikipedia.org/wiki/SQL_injection</span></u></a></p><p align="justify">     SQL注入漏洞存在的原因，就是拼接 SQL 参数。也就是将用于输入的查询参数，直接拼接在 SQL 语句中，导致了SQL 注入漏洞。</p><h2><strong>1.演示下经典的SQL注入</strong></h2><div style="text-align: center;"><strong><img src="http://img.blog.csdn.net/20160630210435150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></strong></div><p align="justify">      我们看到：select id,no from user where id=2;</p><p align="justify">      如果该语句是通过sql字符串拼接得到的，比如： String sql = "select id,no from user where id=" + id;</p><p align="justify">      其中的 id 是一个用户输入的参数，那么，如果用户输入的是 2， 那么上面看到查到了一条数据，如果用户输入的是 2 or 1=1 进行sql注入攻击。</p><p align="justify">      那么看到，上面的语句(select id,no from user where id=2 or 1=1;)将user表中的所有记录都查出来了。</p><p align="justify">     这就是典型的sql注入。</p><p align="justify">      再看一列：</p><p align="center"><strong><span style="color: rgb(255, 0, 0); text-align: -webkit-center;"></span><img src="http://img.blog.csdn.net/20160630210516603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></strong></p><p align="justify">     我们看到通过 sql 注入能够直接将表 sqlinject 删除掉！可见其危害！</p><h2><strong>2.sql注入的原因</strong></h2><p align="justify">      sql注入的原因，表面上说是因为拼接字符串，构成sql语句，没有使用sql语句预编译，绑定变量造成的。</p><p align="justify">      但是更深层次的原因是将用户输入的字符串，当成了“sql语句”来执行。</p><p align="justify">      比如上面的 String sql = "select id,no from user where id=" + id;</p><p align="justify">     我们希望用户输入的id的值，仅仅作为一个字符串字面值，传入数据库执行，但是当输入了：2 or 1=1 时，其中的 or 1=1 并没有作为 where id= 的字面值，而是作为了 sql语句 来执行的。所以其本质是将用户的输入的数据，作为了命令来执行。</p><h2><strong>3. sql注入的防御</strong></h2><p align="justify">      1&gt; 基本上大家都知道 采用sql语句预编译和绑定变量，是防御sql注入的最佳方法。但是其中的深层次原因就不见得都理解了。</p><p align="justify">      String sql = "select id, no from user where id=?";</p><p align="justify">         PreparedStatement ps = conn.prepareStatement(sql);</p><p align="justify">         ps.setInt(1, id);</p><p align="justify">         ps.executeQuery();</p><p align="justify">      如上所示，就是典型的采用sql语句预编译和绑定变量。为什么这样就可以防止sql 注入呢？</p><p align="justify">      其原因就是：采用了PreparedStatement，就会将sql语句："select id, no from user where id=?" 预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的语法结构了，因为语法分析已经完成了，而语法分析主要是分析sql命令，比如 select ,from ,where ,and, or ,order by 等等。所以即使你后面输入了这些sql命令，也不会被当成sql命令来执行了，因为这些sql命令的执行，必须先得通过语法分析，生成执行计划，既然语法分析已经完成，已经预编译过了，那么后面输入的参数，是绝对不可能作为sql命令来执行的，只会被当做字符串字面值参数。所以sql语句预编译可以防御sql注入。</p><p align="justify">      2&gt; 但是不是所有场景都能够采用 sql语句预编译，有一些场景必须的采用字符串拼接的方式，此时，我们严格检查参数的数据类型，还有可以使用一些安全函数，来方式sql注入。</p><p align="justify">      比如 String sql = "select id,no from user where id=" + id;</p><p align="justify">     在接收到用户输入的参数时，我们就严格检查 id，只能是int型。复杂情况可以使用正则表达式来判断。这样也是可以防止sql注入的。</p><p align="justify">      安全函数的使用，比如：  </p><p align="justify">      MySQLCodec codec = new MySQLCodec(Mode.STANDARD);</p><p align="justify">         name = ESAPI.encoder().encodeForSQL(codec, name);</p><p align="justify">        String sql = "select id,no from user where name=" + name;</p><p align="justify">      ESAPI.encoder().encodeForSQL(codec, name)</p><p align="justify">      该函数会将 name 中包含的一些特殊字符进行编码，这样 sql 引擎就不会将name中的字符串当成sql命令来进行语法分析了。</p><h2><strong>注</strong></h2><p align="justify">      实际项目中，一般我们都是采用各种的框架，比如ibatis,mybatis,hibernate等等。他们一般也默认就是sql预编译的。对于ibatis/mybatis，如果使用的是 #{name}形式的，那么就是sql预编译，使用 ${name} 就不是sql预编译的。</p><p align="justify">      以上就是SQL注入防御方法总结，希望对大家之后的学习有所帮助。</p><h2><strong>美文美图</strong></h2><p align="justify" style="text-align: center;"><strong><img src="http://img.blog.csdn.net/20160630210547066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><span style="color: rgb(255, 0, 0); text-align: -webkit-center;"></span></strong></p><p align="justify" style="text-align: center;"><strong><img src="http://img.blog.csdn.net/20160630210608369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></strong></p> &#13;\n
