\n<div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">1、使用union和union all合并两个查询结果：select 字段名 from tablename1 union select 字段名 from tablename2；</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233151645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/881c7b75b74f45f5993040953042f881/se1.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">注意这个操作必须保证两张表字段相同，字段数据类型也相同。另外，使用union的时候会去除重复（相同）的记录，而union all则不会。</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">注：下边的几个连接查询涉及到笛卡尔积的概念，即如果存在两张表，第一张记录数为n条，另一张表的记录数为m条，那么笛卡尔积得出的记录数就是n*m条；如果第一张表的字段数为a个，另一张的字段数为b个，则笛卡尔积得出的字段数就是a+b个。</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">2、使用natural join自然连接：前提是两张表有相同的字段：（这个操作会去掉重复的字段）</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233211010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/22f5f9d61a0c42ac8eeac22453fcd661/se2.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">对于这个查询，我的理解是：保留这两张表中关联字段（例如这里的depart_id）都存在的数据，去掉只有一个表中有的:</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233227885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/b533ffbfe8074373bc6475bf4558198f/se3.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">如上述内容中，company中有四条数据，而emp中有7条，结果不论哪个放前边都只出来六条，因为company中depart_id为4的，emp中没有，而emp中depart_id为5的，company中又没有。</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">3、inner join on等值连接查询：</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233239896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/80af151410764214bcd6663c9be7f256/se4.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">这个操作在我理解，和上边的自然连接区别就在于没有去掉重复的字段，还有更加的灵活，不需要有相同字段名的字段：</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233314949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/44da552a1b444783a1730c1244cc3faa/se5.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">4、inner join on不等值连接查询：</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233333334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/509f22d4da2243a69b39ed9dd6405f1a/se6.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">对于这个查询，我的理解就是，他是“=”查询的补集，即这个查询的结果集 = 笛卡尔积结果集  减去“=”查询的结果集；本例中，company有4条记录，emp有7条记录，笛卡尔积是4*7=28条记录；“=”查询的结果是6条记录，一次"!="查询就应该是其余的22条记录。</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">5、从上边的操作中可以拓展出另一种查询：字连接查询，即实际只有一张表，用重命名的方式当成两张来用：</div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img src="http://img.blog.csdn.net/20160621233346740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><img data-media-type="image" src="file:///H:/youdaobiji/qqA4925CA5EB6376EF1209D66BD4F52A29/fbd92bbd6b4742019cff74cd3780a917/se7.png" data-inited="true" style="cursor: default; display: inline-block; margin-top: 8px; max-width: 800px; background-color: inherit;" alt="" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;" /></div><div style="font-family: &#x5FAE;&#x8F6F;&#x96C5;&#x9ED1;; font-size: 14px; line-height: 21px;">可以看到，根据笛卡尔积，这里应该有4*4=16条结果，但是因为有了条件，就筛选出了四条。</div> &#13;\n
