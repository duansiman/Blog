\n\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体">首要步骤(一般可省略):<br style="margin:0px; padding:0px" />&#13;\n开启mysql服务(默认是开机时就自动运行了):<br style="margin:0px; padding:0px" />&#13;\n控制面板--&gt;管理工具--&gt;服务,在里面找到名称为mysql的项,双击就可看它的服务状态是启动还是停止,把它设为启动</span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体">连接mysql:<br style="margin:0px; padding:0px" />&#13;\n在命令行下输入 mysql -h localhost -u root -p回车,然后输入密码即可;或直接运行mysql自带的连接工具,然后输入密码即可.</span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体">1.编写sql脚本,假设内容如下:</span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体">  create database dearabao;<br style="margin:0px; padding:0px" />&#13;\n  use dearabao;<br style="margin:0px; padding:0px" />&#13;\n  create table niuzi (name varchar(20));</span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体">  保存脚本文件,假设我把它保存在F盘的hello world目录下,于是该文件的路径为:F:/hello world/niuzi.sql</span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<span style="margin:0px; padding:0px; line-height:1.5; font-family:宋体"></span></p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<br style="margin:0px; padding:0px" />&#13;\n2.执行sql脚本,可以有2种方法:<br style="margin:0px; padding:0px" />&#13;\n  第一种方法:<br style="margin:0px; padding:0px" />&#13;\n 在命令行下(未连接数据库),输入 mysql -h localhost -u root -p123456 &lt; F:/hello world/niuzi.sql (注意路径不用加引号的!!) 回车即可.<br style="margin:0px; padding:0px" />&#13;\n  第二种方法:<br style="margin:0px; padding:0px" />&#13;\n 在命令行下(已连接数据库,此时的提示符为 mysql&gt; ),输入 source F:/hello world/niuzi.sql (注意路径不用加引号的) 或者 /. F:/hello world/niuzi.sql (注意路径不用加引号的) 回车即可</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n </p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\nSQL编写规范</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n1.书写格式<br style="margin:0px; padding:0px" />&#13;\n示例代码：</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n存储过程SQL文书写格式例<br style="margin:0px; padding:0px" />&#13;\nselect <br style="margin:0px; padding:0px" />&#13;\n        c.dealerCode,<br style="margin:0px; padding:0px" />&#13;\n        round(sum(c.submitSubletAmountDLR + c.submitPartsAmountDLR + c.submitLaborAmountDLR) / count(*), 2) as avg, <br style="margin:0px; padding:0px" />&#13;\n        decode(null, 'x', 'xx', 'CNY') <br style="margin:0px; padding:0px" />&#13;\nfrom ( <br style="margin:0px; padding:0px" />&#13;\n        select <br style="margin:0px; padding:0px" />&#13;\n                a.dealerCode,<br style="margin:0px; padding:0px" />&#13;\n                a.submitSubletAmountDLR, <br style="margin:0px; padding:0px" />&#13;\n                a.submitPartsAmountDLR, <br style="margin:0px; padding:0px" />&#13;\n                a.submitLaborAmountDLR <br style="margin:0px; padding:0px" />&#13;\n        from SRV_TWC_F a<br style="margin:0px; padding:0px" />&#13;\n        where (to_char(a.ORIGSUBMITTIME, 'yyyy/mm/dd') &gt;= 'Date Range(start)' <br style="margin:0px; padding:0px" />&#13;\n        and to_char(a.ORIGSUBMITTIME, 'yyyy/mm/dd') &lt;= 'Date Range(end)'   <br style="margin:0px; padding:0px" />&#13;\n        and nvl(a.deleteflag, '0') &lt;&gt; '1') <br style="margin:0px; padding:0px" />&#13;\n        union all <br style="margin:0px; padding:0px" />&#13;\n        select <br style="margin:0px; padding:0px" />&#13;\n                b.dealerCode,<br style="margin:0px; padding:0px" />&#13;\n                b.submitSubletAmountDLR, <br style="margin:0px; padding:0px" />&#13;\n                b.submitPartsAmountDLR, <br style="margin:0px; padding:0px" />&#13;\n                b.submitLaborAmountDLR <br style="margin:0px; padding:0px" />&#13;\n        from SRV_TWCHistory_F b<br style="margin:0px; padding:0px" />&#13;\n        where (to_char(b.ORIGSUBMITTIME, 'yyyy/mm/dd') &gt;= 'Date Range(start)' <br style="margin:0px; padding:0px" />&#13;\n        and to_char(b.ORIGSUBMITTIME,'yyyy/mm/dd') &lt;= 'Date Range(end)'   <br style="margin:0px; padding:0px" />&#13;\n        and nvl(b.deleteflag,'0') &lt;&gt; '1')<br style="margin:0px; padding:0px" />&#13;\n) c<br style="margin:0px; padding:0px" />&#13;\ngroup by c.dealerCode <br style="margin:0px; padding:0px" />&#13;\norder by avg desc;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\nJava source里的SQL字符串书写格式例<br style="margin:0px; padding:0px" />&#13;\nstrSQL = "insert into Snd_FinanceHistory_Tb "<br style="margin:0px; padding:0px" />&#13;\n    + "(DEALERCODE, "<br style="margin:0px; padding:0px" />&#13;\n    + "REQUESTSEQUECE, "<br style="margin:0px; padding:0px" />&#13;\n    + "HANDLETIME, "<br style="margin:0px; padding:0px" />&#13;\n    + "JOBFLAG, "<br style="margin:0px; padding:0px" />&#13;\n    + "FRAMENO, "<br style="margin:0px; padding:0px" />&#13;\n    + "INMONEY, "<br style="margin:0px; padding:0px" />&#13;\n    + "REMAINMONEY, "<br style="margin:0px; padding:0px" />&#13;\n    + "DELETEFLAG, "<br style="margin:0px; padding:0px" />&#13;\n    + "UPDATECOUNT, "<br style="margin:0px; padding:0px" />&#13;\n    + "CREUSER, "<br style="margin:0px; padding:0px" />&#13;\n    + "CREDATE, "<br style="margin:0px; padding:0px" />&#13;\n    + "HONORCHECKNO, "<br style="margin:0px; padding:0px" />&#13;\n    + "SEQ) "<br style="margin:0px; padding:0px" />&#13;\n    + "values ('" + draftInputDetail.dealerCode + "', "<br style="margin:0px; padding:0px" />&#13;\n    + "'" + draftInputDetail.requestsequece + "', "<br style="margin:0px; padding:0px" />&#13;\n    + "sysdate, "<br style="margin:0px; padding:0px" />&#13;\n    + "'07', "<br style="margin:0px; padding:0px" />&#13;\n    + "'" + frameNO + "', "<br style="margin:0px; padding:0px" />&#13;\n    + requestMoney + ", "<br style="margin:0px; padding:0px" />&#13;\n    + remainMoney + ", "<br style="margin:0px; padding:0px" />&#13;\n    + "'0', "<br style="margin:0px; padding:0px" />&#13;\n    + "0, "<br style="margin:0px; padding:0px" />&#13;\n    + "'" + draftStruct.employeeCode + "', "<br style="margin:0px; padding:0px" />&#13;\n    + "sysdate, "<br style="margin:0px; padding:0px" />&#13;\n    + "'" + draftInputDetail.honorCheckNo + "', "<br style="margin:0px; padding:0px" />&#13;\n    + index + ")";</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  1).缩进<br style="margin:0px; padding:0px" />&#13;\n    对于存储过程文件，缩进为8个空格<br style="margin:0px; padding:0px" />&#13;\n    对于Java source里的SQL字符串，不可有缩进，即每一行字符串不可以空格开头</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  2).换行<br style="margin:0px; padding:0px" />&#13;\n    1&gt;.Select/From/Where/Order by/Group by等子句必须另其一行写<br style="margin:0px; padding:0px" />&#13;\n    2&gt;.Select子句内容如果只有一项，与Select同行写<br style="margin:0px; padding:0px" />&#13;\n    3&gt;.Select子句内容如果多于一项，每一项单独占一行，在对应Select的基础上向右缩进8个空格（Java source无缩进）<br style="margin:0px; padding:0px" />&#13;\n    4&gt;.From子句内容如果只有一项，与From同行写<br style="margin:0px; padding:0px" />&#13;\n    5&gt;.From子句内容如果多于一项，每一项单独占一行，在对应From的基础上向右缩进8个空格（Java source无缩进）<br style="margin:0px; padding:0px" />&#13;\n    6&gt;.Where子句的条件如果有多项，每一个条件占一行，以AND开头，且无缩进<br style="margin:0px; padding:0px" />&#13;\n    7&gt;.(Update)Set子句内容每一项单独占一行，无缩进<br style="margin:0px; padding:0px" />&#13;\n    8&gt;.Insert子句内容每个表字段单独占一行，无缩进；values每一项单独占一行，无缩进<br style="margin:0px; padding:0px" />&#13;\n    9&gt;.SQL文中间不允许出现空行<br style="margin:0px; padding:0px" />&#13;\n    10&gt;.Java source里单引号必须跟所属的SQL子句处在同一行，连接符（"+"）必须在行首</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  3).空格<br style="margin:0px; padding:0px" />&#13;\n    1&gt;.SQL内算数运算符、逻辑运算符连接的两个元素之间必须用空格分隔<br style="margin:0px; padding:0px" />&#13;\n    2&gt;.逗号之后必须接一个空格<br style="margin:0px; padding:0px" />&#13;\n    3&gt;.关键字、保留字和左括号之间必须有一个空格</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n2.不等于统一使用"&lt;&gt;"<br style="margin:0px; padding:0px" />&#13;\n  Oracle认为"!="和"&lt;&gt;"是等价的，都代表不等于的意义。为了统一，不等于一律使用"&lt;&gt;"表示</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n3.使用表的别名<br style="margin:0px; padding:0px" />&#13;\n  数据库查询，必须使用表的别名</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n4.SQL文对表字段扩展的兼容性<br style="margin:0px; padding:0px" />&#13;\n  在Java source里使用Select *时，严禁通过getString(1)的形式得到查询结果，必须使用getString("字段名")的形式<br style="margin:0px; padding:0px" />&#13;\n  使用Insert时，必须指定插入的字段名，严禁不指定字段名直接插入values</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n5.减少子查询的使用<br style="margin:0px; padding:0px" />&#13;\n  子查询除了可读性差之外，还在一定程度上影响了SQL运行效率<br style="margin:0px; padding:0px" />&#13;\n  请尽量减少使用子查询的使用，用其他效率更高、可读性更好的方式替代</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n6.适当添加索引以提高查询效率<br style="margin:0px; padding:0px" />&#13;\n  适当添加索引可以大幅度的提高检索速度<br style="margin:0px; padding:0px" />&#13;\n  请参看ORACLE SQL性能优化系列</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n7.对数据库表操作的特殊要求<br style="margin:0px; padding:0px" />&#13;\n  本项目对数据库表的操作还有以下特殊要求：</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  1).以逻辑删除替代物理删除<br style="margin:0px; padding:0px" />&#13;\n    注意：现在数据库表中数据没有物理删除，只有逻辑删除<br style="margin:0px; padding:0px" />&#13;\n    以deleteflag字段作为删除标志，deleteflag='1'代表此记录被逻辑删除，因此在查询数据时必须考虑deleteflag的因素<br style="margin:0px; padding:0px" />&#13;\n    deleteflag的标准查询条件：NVL(deleteflag, '0') &lt;&gt; '1'</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  2).增加记录状态字段<br style="margin:0px; padding:0px" />&#13;\n    数据库中的每张表基本都有以下字段：DELETEFLAG、UPDATECOUNT、CREDATE、CREUSER、UPDATETIME、UPDATEUSER<br style="margin:0px; padding:0px" />&#13;\n    要注意在对标进行操作时必须考虑以下字段</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    插入一条记录时要置DELETEFLAG='0', UPDATECOUNT=0, CREDATE=sysdate, CREUSER=登录User<br style="margin:0px; padding:0px" />&#13;\n    查询一条记录时要考虑DELETEFLAG，如果有可能对此记录作更新时还要取得UPDATECOUNT作同步检查<br style="margin:0px; padding:0px" />&#13;\n    修改一条记录时要置UPDATETIME=sysdate, UPDATEUSER=登录User, UPDATECOUNT=(UPDATECOUNT+1) mod 1000, <br style="margin:0px; padding:0px" />&#13;\n    删除一条记录时要置DELETEFLAG='1'</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  3).历史表<br style="margin:0px; padding:0px" />&#13;\n    数据库里部分表还存在相应的历史表，比如srv_twc_f和srv_twchistory_f<br style="margin:0px; padding:0px" />&#13;\n    在查询数据时除了检索所在表之外，还必须检索相应的历史表，对二者的结果做Union（或Union All）</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n8.用执行计划分析SQL性能<br style="margin:0px; padding:0px" />&#13;\n  EXPLAIN PLAN是一个很好的分析SQL语句的工具，它可以在不执行SQL的情况下分析语句<br style="margin:0px; padding:0px" />&#13;\n  通过分析，我们就可以知道ORACLE是怎样连接表，使用什么方式扫描表（索引扫描或全表扫描），以及使用到的索引名称</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  按照从里到外，从上到下的次序解读分析的结果<br style="margin:0px; padding:0px" />&#13;\n  EXPLAIN PLAN的分析结果是用缩进的格式排列的，最内部的操作将最先被解读，如果两个操作处于同一层中，带有最小操作号的将首先被执行</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  目前许多第三方的工具如PLSQL Developer和TOAD等都提供了极其方便的EXPLAIN PLAN工具<br style="margin:0px; padding:0px" />&#13;\n  PG需要将自己添加的查询SQL文记入log，然后在EXPLAIN PLAN中进行分析，尽量减少全表扫描</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<br style="margin:0px; padding:0px" />&#13;\nORACLE SQL性能优化系列</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n1.选择最有效率的表名顺序(只在基于规则的优化器中有效)<br style="margin:0px; padding:0px" />&#13;\n   ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表（基础表driving table）将被最先处理<br style="margin:0px; padding:0px" />&#13;\n   在FROM子句中包含多个表的情况下，必须选择记录条数最少的表作为基础表<br style="margin:0px; padding:0px" />&#13;\n   当ORACLE处理多个表时，会运用排序及合并的方式连接它们<br style="margin:0px; padding:0px" />&#13;\n   首先，扫描第一个表（FROM子句中最后的那个表)并对记录进行排序；<br style="margin:0px; padding:0px" />&#13;\n   然后扫描第二个表（FROM子句中最后第二个表)；<br style="margin:0px; padding:0px" />&#13;\n   最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并<br style="margin:0px; padding:0px" />&#13;\n   例如:<br style="margin:0px; padding:0px" />&#13;\n     表 TAB1 16,384 条记录<br style="margin:0px; padding:0px" />&#13;\n     表 TAB2 5 条记录<br style="margin:0px; padding:0px" />&#13;\n     选择TAB2作为基础表 (最好的方法)<br style="margin:0px; padding:0px" />&#13;\n     select count(*) from tab1,tab2 执行时间0.96秒 <br style="margin:0px; padding:0px" />&#13;\n     选择TAB2作为基础表 (不佳的方法)<br style="margin:0px; padding:0px" />&#13;\n     select count(*) from tab2,tab1 执行时间26.09秒</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n   如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表<br style="margin:0px; padding:0px" />&#13;\n   例如:<br style="margin:0px; padding:0px" />&#13;\n     EMP表描述了LOCATION表和CATEGORY表的交集<br style="margin:0px; padding:0px" />&#13;\n       SELECT * <br style="margin:0px; padding:0px" />&#13;\n       FROM LOCATION L,<br style="margin:0px; padding:0px" />&#13;\n       CATEGORY C,<br style="margin:0px; padding:0px" />&#13;\n       EMP E<br style="margin:0px; padding:0px" />&#13;\n       WHERE E.EMP_NO BETWEEN 1000 AND 2000<br style="margin:0px; padding:0px" />&#13;\n       AND E.CAT_NO = C.CAT_NO<br style="margin:0px; padding:0px" />&#13;\n       AND E.LOCN = L.LOCN</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n     将比下列SQL更有效率<br style="margin:0px; padding:0px" />&#13;\n       SELECT * <br style="margin:0px; padding:0px" />&#13;\n       FROM EMP E ,<br style="margin:0px; padding:0px" />&#13;\n       LOCATION L ,<br style="margin:0px; padding:0px" />&#13;\n       CATEGORY C<br style="margin:0px; padding:0px" />&#13;\n       WHERE E.CAT_NO = C.CAT_NO<br style="margin:0px; padding:0px" />&#13;\n       AND E.LOCN = L.LOCN<br style="margin:0px; padding:0px" />&#13;\n       AND E.EMP_NO BETWEEN 1000 AND 2000</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n2.WHERE子句中的连接顺序<br style="margin:0px; padding:0px" />&#13;\n  ORACLE采用自下而上的顺序解析WHERE子句<br style="margin:0px; padding:0px" />&#13;\n  根据这个原理，表之间的连接必须写在其他WHERE条件之前，那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n     (低效,执行时间156.3秒)<br style="margin:0px; padding:0px" />&#13;\n       SELECT *<br style="margin:0px; padding:0px" />&#13;\n       FROM EMP E<br style="margin:0px; padding:0px" />&#13;\n       WHERE SAL &gt; 50000<br style="margin:0px; padding:0px" />&#13;\n       AND JOB = 'MANAGER'<br style="margin:0px; padding:0px" />&#13;\n       AND 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO);</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n     (高效,执行时间10.6秒)<br style="margin:0px; padding:0px" />&#13;\n       SELECT *<br style="margin:0px; padding:0px" />&#13;\n       FROM EMP E<br style="margin:0px; padding:0px" />&#13;\n       WHERE 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO)<br style="margin:0px; padding:0px" />&#13;\n       AND SAL &gt; 50000<br style="margin:0px; padding:0px" />&#13;\n       AND JOB = 'MANAGER';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n3.SELECT子句中避免使用'*'<br style="margin:0px; padding:0px" />&#13;\n  当你想在SELECT子句中列出所有的COLUMN时，使用动态SQL列引用'*'是一个方便的方法，不幸的是，这是一个非常低效的方法<br style="margin:0px; padding:0px" />&#13;\n  实际上，ORACLE在解析的过程中，会将'*'依次转换成所有的列名<br style="margin:0px; padding:0px" />&#13;\n  这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n4.减少访问数据库的次数 <br style="margin:0px; padding:0px" />&#13;\n  当执行每条SQL语句时，ORACLE在内部执行了许多工作：解析SQL语句，估算索引的利用率，绑定变量，读数据块等等<br style="margin:0px; padding:0px" />&#13;\n  由此可见，减少访问数据库的次数，就能实际上减少ORACLE的工作量<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    以下有三种方法可以检索出雇员号等于0342或0291的职员<br style="margin:0px; padding:0px" />&#13;\n    方法1 (最低效)<br style="margin:0px; padding:0px" />&#13;\n      SELECT EMP_NAME, SALARY, GRADE<br style="margin:0px; padding:0px" />&#13;\n      FROM EMP<br style="margin:0px; padding:0px" />&#13;\n      WHERE EMP_NO = 342;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n      SELECT EMP_NAME, SALARY, GRADE<br style="margin:0px; padding:0px" />&#13;\n      FROM EMP<br style="margin:0px; padding:0px" />&#13;\n      WHERE EMP_NO = 291;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    方法2 (次低效)<br style="margin:0px; padding:0px" />&#13;\n      DECLARE<br style="margin:0px; padding:0px" />&#13;\n      CURSOR C1 (E_NO NUMBER) IS<br style="margin:0px; padding:0px" />&#13;\n      SELECT EMP_NAME,SALARY,GRADE<br style="margin:0px; padding:0px" />&#13;\n      FROM EMP<br style="margin:0px; padding:0px" />&#13;\n      WHERE EMP_NO = E_NO;<br style="margin:0px; padding:0px" />&#13;\n      BEGIN<br style="margin:0px; padding:0px" />&#13;\n      OPEN C1(342);<br style="margin:0px; padding:0px" />&#13;\n      FETCH C1 INTO …,…,…;<br style="margin:0px; padding:0px" />&#13;\n      …<br style="margin:0px; padding:0px" />&#13;\n      OPEN C1(291);<br style="margin:0px; padding:0px" />&#13;\n      FETCH C1 INTO …,…,…;<br style="margin:0px; padding:0px" />&#13;\n      …<br style="margin:0px; padding:0px" />&#13;\n      CLOSE C1;<br style="margin:0px; padding:0px" />&#13;\n      END;                                  </p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    方法2 (高效)<br style="margin:0px; padding:0px" />&#13;\n      SELECT A.EMP_NAME, A.SALARY, A.GRADE,<br style="margin:0px; padding:0px" />&#13;\n             B.EMP_NAME, B.SALARY, B.GRADE<br style="margin:0px; padding:0px" />&#13;\n      FROM EMP A, EMP B<br style="margin:0px; padding:0px" />&#13;\n      WHERE A.EMP_NO = 342<br style="margin:0px; padding:0px" />&#13;\n      AND B.EMP_NO = 291;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n5.使用DECODE函数来减少处理时间<br style="margin:0px; padding:0px" />&#13;\n  使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    SELECT COUNT(*), SUM(SAL)<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP<br style="margin:0px; padding:0px" />&#13;\n    WHERE DEPT_NO = '0020'<br style="margin:0px; padding:0px" />&#13;\n    AND ENAME LIKE 'SMITH%';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    SELECT COUNT(*), SUM(SAL)<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP<br style="margin:0px; padding:0px" />&#13;\n    WHERE DEPT_NO = '0030'<br style="margin:0px; padding:0px" />&#13;\n    AND ENAME LIKE 'SMITH%';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    你可以用DECODE函数高效地得到相同结果<br style="margin:0px; padding:0px" />&#13;\n    SELECT COUNT(DECODE(DEPT_NO, '0020', 'X', NULL)) D0020_COUNT,<br style="margin:0px; padding:0px" />&#13;\n    COUNT(DECODE(DEPT_NO, '0030', 'X', NULL)) D0030_COUNT,<br style="margin:0px; padding:0px" />&#13;\n    SUM(DECODE(DEPT_NO, '0020', SAL, NULL)) D0020_SAL, <br style="margin:0px; padding:0px" />&#13;\n    SUM(DECODE(DEPT_NO, 0030, SAL, NULL)) D0030_SAL<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP<br style="margin:0px; padding:0px" />&#13;\n    WHERE ENAME LIKE 'SMITH%';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  'X'表示任何一个字段<br style="margin:0px; padding:0px" />&#13;\n  类似的，DECODE函数也可以运用于GROUP BY和ORDER BY子句中</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n6.用Where子句替换HAVING子句<br style="margin:0px; padding:0px" />&#13;\n  避免使用HAVING子句，HAVING只会在检索出所有记录之后才对结果集进行过滤，这个处理需要排序、统计等操作<br style="margin:0px; padding:0px" />&#13;\n  如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    SELECT REGION, AVG(LOG_SIZE)<br style="margin:0px; padding:0px" />&#13;\n    FROM LOCATION<br style="margin:0px; padding:0px" />&#13;\n    GROUP BY REGION<br style="margin:0px; padding:0px" />&#13;\n    HAVING REGION REGION != 'SYDNEY'<br style="margin:0px; padding:0px" />&#13;\n    AND REGION != 'PERTH'</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT REGION, AVG(LOG_SIZE)<br style="margin:0px; padding:0px" />&#13;\n    FROM LOCATION<br style="margin:0px; padding:0px" />&#13;\n    WHERE REGION REGION != 'SYDNEY'<br style="margin:0px; padding:0px" />&#13;\n    AND REGION != 'PERTH'<br style="margin:0px; padding:0px" />&#13;\n    GROUP BY REGION</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n7.减少对表的查询<br style="margin:0px; padding:0px" />&#13;\n  在含有子查询的SQL语句中，要特别注意减少对表的查询<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    SELECT TAB_NAME<br style="margin:0px; padding:0px" />&#13;\n    FROM TABLES<br style="margin:0px; padding:0px" />&#13;\n    WHERE TAB_NAME = (SELECT TAB_NAME <br style="margin:0px; padding:0px" />&#13;\n                      FROM TAB_COLUMNS<br style="margin:0px; padding:0px" />&#13;\n                      WHERE VERSION = 604)<br style="margin:0px; padding:0px" />&#13;\n    AND DB_VER = (SELECT DB_VER<br style="margin:0px; padding:0px" />&#13;\n                  FROM TAB_COLUMNS<br style="margin:0px; padding:0px" />&#13;\n                  WHERE VERSION = 604)</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT TAB_NAME<br style="margin:0px; padding:0px" />&#13;\n    FROM TABLES<br style="margin:0px; padding:0px" />&#13;\n    WHERE (TAB_NAME, DB_VER) = (SELECT TAB_NAME, DB_VER<br style="margin:0px; padding:0px" />&#13;\n                                FROM TAB_COLUMNS<br style="margin:0px; padding:0px" />&#13;\n                                WHERE VERSION = 604)</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  Update多个Column例子：<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    UPDATE EMP<br style="margin:0px; padding:0px" />&#13;\n    SET EMP_CAT = (SELECT MAX(CATEGORY) <br style="margin:0px; padding:0px" />&#13;\n                   FROM EMP_CATEGORIES), <br style="margin:0px; padding:0px" />&#13;\n    SAL_RANGE = (SELECT MAX(SAL_RANGE) <br style="margin:0px; padding:0px" />&#13;\n                 FROM EMP_CATEGORIES)<br style="margin:0px; padding:0px" />&#13;\n    WHERE EMP_DEPT = 0020;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    UPDATE EMP<br style="margin:0px; padding:0px" />&#13;\n    SET (EMP_CAT, SAL_RANGE) = (SELECT MAX(CATEGORY), MAX(SAL_RANGE)<br style="margin:0px; padding:0px" />&#13;\n                                FROM EMP_CATEGORIES)<br style="margin:0px; padding:0px" />&#13;\n    WHERE EMP_DEPT = 0020;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n8.使用表的别名(Alias)<br style="margin:0px; padding:0px" />&#13;\n  当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上<br style="margin:0px; padding:0px" />&#13;\n  这样可以减少解析的时间并减少那些由Column歧义引起的语法错误</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n9.用EXISTS替代IN                                    <br style="margin:0px; padding:0px" />&#13;\n  在许多基于基础表的查询中，为了满足一个条件，往往需要对另一个表进行联接<br style="margin:0px; padding:0px" />&#13;\n  在这种情况下，使用EXISTS(或NOT EXISTS)通常将提高查询的效率<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    SELECT *<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP (基础表)<br style="margin:0px; padding:0px" />&#13;\n    WHERE EMPNO &gt; 0<br style="margin:0px; padding:0px" />&#13;\n    AND DEPTNO IN (SELECT DEPTNO<br style="margin:0px; padding:0px" />&#13;\n                   FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n                   WHERE LOC = 'MELB')</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT *<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP (基础表)<br style="margin:0px; padding:0px" />&#13;\n    WHERE EMPNO &gt; 0<br style="margin:0px; padding:0px" />&#13;\n    AND EXISTS (SELECT 'X'<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n    WHERE DEPT.DEPTNO = EMP.DEPTNO<br style="margin:0px; padding:0px" />&#13;\n    AND LOC = 'MELB')</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n10.用NOT EXISTS替代NOT IN<br style="margin:0px; padding:0px" />&#13;\n  在子查询中，NOT IN子句将执行一个内部的排序和合并<br style="margin:0px; padding:0px" />&#13;\n  无论在哪种情况下，NOT IN都是最低效的，因为它对子查询中的表执行了一个全表遍历<br style="margin:0px; padding:0px" />&#13;\n  为了避免使用NOT IN，我们可以把它改写成外连接(Outer Joins)或NOT EXISTS<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    SELECT …<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP<br style="margin:0px; padding:0px" />&#13;\n    WHERE DEPT_NO NOT IN (SELECT DEPT_NO<br style="margin:0px; padding:0px" />&#13;\n                          FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n                          WHERE DEPT_CAT = 'A');</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    为了提高效率改写为<br style="margin:0px; padding:0px" />&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT …<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP A, DEPT B<br style="margin:0px; padding:0px" />&#13;\n    WHERE A.DEPT_NO = B.DEPT(+)<br style="margin:0px; padding:0px" />&#13;\n    AND B.DEPT_NO IS NULL<br style="margin:0px; padding:0px" />&#13;\n    AND B.DEPT_CAT(+) = 'A'</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    最高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT …<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP E<br style="margin:0px; padding:0px" />&#13;\n    WHERE NOT EXISTS (SELECT 'X'<br style="margin:0px; padding:0px" />&#13;\n                      FROM DEPT D<br style="margin:0px; padding:0px" />&#13;\n                      WHERE D.DEPT_NO = E.DEPT_NO<br style="margin:0px; padding:0px" />&#13;\n                      AND DEPT_CAT = 'A');</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n11.用表连接替换EXISTS<br style="margin:0px; padding:0px" />&#13;\n  通常来说，采用表连接的方式比EXISTS更有效率<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    SELECT ENAME<br style="margin:0px; padding:0px" />&#13;\n    FROM EMP E<br style="margin:0px; padding:0px" />&#13;\n    WHERE EXISTS (SELECT 'X'<br style="margin:0px; padding:0px" />&#13;\n                  FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n                  WHERE DEPT_NO = E.DEPT_NO<br style="margin:0px; padding:0px" />&#13;\n                  AND DEPT_CAT = 'A');</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    更高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT ENAME<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT D, EMP E<br style="margin:0px; padding:0px" />&#13;\n    WHERE E.DEPT_NO = D.DEPT_NO<br style="margin:0px; padding:0px" />&#13;\n    AND DEPT_CAT = 'A';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n12.用EXISTS替换DISTINCT <br style="margin:0px; padding:0px" />&#13;\n  当提交一个包含多表信息（比如部门表和雇员表）的查询时，避免在SELECT子句中使用DISTINCT，一般可以考虑用EXIST替换<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    SELECT DISTINCT DEPT_NO, DEPT_NAME<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT D, EMP E<br style="margin:0px; padding:0px" />&#13;\n    WHERE D.DEPT_NO = E.DEPT_NO</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT DEPT_NO, DEPT_NAME<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT D<br style="margin:0px; padding:0px" />&#13;\n    WHERE EXISTS (SELECT 'X'<br style="margin:0px; padding:0px" />&#13;\n                  FROM EMP E<br style="margin:0px; padding:0px" />&#13;\n                  WHERE E.DEPT_NO = D.DEPT_NO);</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  EXISTS使查询更为迅速，因为RDBMS核心模块将在子查询的条件一旦满足后，立刻返回结果</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n13.用索引提高效率<br style="margin:0px; padding:0px" />&#13;\n  索引是表的一个概念部分，用来提高检索数据的效率。实际上，ORACLE使用了一个复杂的自平衡B-tree结构<br style="margin:0px; padding:0px" />&#13;\n  通常，通过索引查询数据比全表扫描要快。当ORACLE找出执行查询和Update语句的最佳路径时，ORACLE优化器将使用索引<br style="margin:0px; padding:0px" />&#13;\n  同样，在联结多个表时使用索引也可以提高效率。另一个使用索引的好处是，它提供了主键（primary key）的唯一性验证</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  除了那些LONG或LONG RAW数据类型，你可以索引几乎所有的列<br style="margin:0px; padding:0px" />&#13;\n  通常在大型表中使用索引特别有效，当然，在扫描小表时，使用索引同样能提高效率</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  虽然使用索引能得到查询效率的提高，但是我们也必须注意到它的代价<br style="margin:0px; padding:0px" />&#13;\n  索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改<br style="margin:0px; padding:0px" />&#13;\n  这意味着每条记录的INSERT、DELETE、UPDATE将为此多付出4、5次的磁盘I/O<br style="margin:0px; padding:0px" />&#13;\n  因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  ORACLE对索引有两种访问模式：<br style="margin:0px; padding:0px" />&#13;\n  1).索引唯一扫描（INDEX UNIQUE SCAN）<br style="margin:0px; padding:0px" />&#13;\n    大多数情况下, 优化器通过WHERE子句访问INDEX<br style="margin:0px; padding:0px" />&#13;\n    例如：<br style="margin:0px; padding:0px" />&#13;\n      表LODGING有两个索引：建立在LODGING列上的唯一性索引LODGING_PK和建立在MANAGER列上的非唯一性索引LODGING$MANAGER<br style="margin:0px; padding:0px" />&#13;\n      SELECT *<br style="margin:0px; padding:0px" />&#13;\n      FROM LODGING<br style="margin:0px; padding:0px" />&#13;\n      WHERE LODGING = 'ROSE HILL';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n      在内部，上述SQL将被分成两步执行：<br style="margin:0px; padding:0px" />&#13;\n      首先，LODGING_PK索引将通过索引唯一扫描的方式被访问，获得相对应的ROWID；然后通过ROWID访问表的方式执行下一步检索<br style="margin:0px; padding:0px" />&#13;\n      如果被检索返回的列包括在INDEX列中，ORACLE将不执行第二步的处理（通过ROWID访问表）<br style="margin:0px; padding:0px" />&#13;\n      因为检索数据保存在索引中，单单访问索引就可以完全满足查询结果</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  2).索引范围查询(INDEX RANGE SCAN)<br style="margin:0px; padding:0px" />&#13;\n    适用于两种情况: <br style="margin:0px; padding:0px" />&#13;\n    1&gt;.基于唯一性索引的一个范围的检索<br style="margin:0px; padding:0px" />&#13;\n    2&gt;.基于非唯一性索引的检索<br style="margin:0px; padding:0px" />&#13;\n    例1<br style="margin:0px; padding:0px" />&#13;\n      SELECT LODGING<br style="margin:0px; padding:0px" />&#13;\n      FROM LODGING<br style="margin:0px; padding:0px" />&#13;\n      WHERE LODGING LIKE 'M%';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n      WHERE子句条件包括一系列值，ORACLE将通过索引范围查询的方式查询LODGING_PK<br style="margin:0px; padding:0px" />&#13;\n      由于索引范围查询将返回一组值，它的效率就要比索引唯一扫描低一些</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    例2<br style="margin:0px; padding:0px" />&#13;\n      SELECT LODGING<br style="margin:0px; padding:0px" />&#13;\n      FROM LODGING<br style="margin:0px; padding:0px" />&#13;\n      WHERE MANAGER = 'BILL GATES';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n      这个SQL的执行分两步，LODGING<span class="MathJax_Preview" style="margin:0px; padding:0px; color:inherit; line-height:1.5"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="margin:0px; padding:0px; display:inline; line-height:1.5; word-spacing:normal; word-wrap:normal; white-space:nowrap; float:none; direction:ltr; max-width:none; max-height:none; min-width:0px; min-height:0px; border:0px; position:relative"><nobr style=""><span class="math" id="MathJax-Span-1" style=""><span style=""><span style=""><span class="mrow" id="MathJax-Span-2" style=""><span class="mi" id="MathJax-Span-3" style="">M<span style=""></span></span><span class="mi" id="MathJax-Span-4" style="">A</span><span class="mi" id="MathJax-Span-5" style="">N<span style=""></span></span><span class="mi" id="MathJax-Span-6" style="">A</span><span class="mi" id="MathJax-Span-7" style="">G</span><span class="mi" id="MathJax-Span-8" style="">E<span style=""></span></span><span class="mi" id="MathJax-Span-9" style="">R</span><span class="texatom" id="MathJax-Span-10" style=""><span class="mrow" id="MathJax-Span-11" style=""><span class="mo" id="MathJax-Span-12" style=""><span style="">的</span></span></span></span><span class="texatom" id="MathJax-Span-13" style=""><span class="mrow" id="MathJax-Span-14" style=""><span class="mo" id="MathJax-Span-15" style=""><span style="">索</span></span></span></span><span class="texatom" id="MathJax-Span-16" style=""><span class="mrow" id="MathJax-Span-17" style=""><span class="mo" id="MathJax-Span-18" style=""><span style="">引</span></span></span></span><span class="texatom" id="MathJax-Span-19" style=""><span class="mrow" id="MathJax-Span-20" style=""><span class="mo" id="MathJax-Span-21" style=""><span style="">范</span></span></span></span><span class="texatom" id="MathJax-Span-22" style=""><span class="mrow" id="MathJax-Span-23" style=""><span class="mo" id="MathJax-Span-24" style=""><span style="">围</span></span></span></span><span class="texatom" id="MathJax-Span-25" style=""><span class="mrow" id="MathJax-Span-26" style=""><span class="mo" id="MathJax-Span-27" style=""><span style="">查</span></span></span></span><span class="texatom" id="MathJax-Span-28" style=""><span class="mrow" id="MathJax-Span-29" style=""><span class="mo" id="MathJax-Span-30" style=""><span style="">询</span></span></span></span><span class="texatom" id="MathJax-Span-31" style=""><span class="mrow" id="MathJax-Span-32" style=""><span class="mo" id="MathJax-Span-33" style=""><span style="">（</span></span></span></span><span class="texatom" id="MathJax-Span-34" style=""><span class="mrow" id="MathJax-Span-35" style=""><span class="mo" id="MathJax-Span-36" style=""><span style="">得</span></span></span></span><span class="texatom" id="MathJax-Span-37" style=""><span class="mrow" id="MathJax-Span-38" style=""><span class="mo" id="MathJax-Span-39" style=""><span style="">到</span></span></span></span><span class="texatom" id="MathJax-Span-40" style=""><span class="mrow" id="MathJax-Span-41" style=""><span class="mo" id="MathJax-Span-42" style=""><span style="">所</span></span></span></span><span class="texatom" id="MathJax-Span-43" style=""><span class="mrow" id="MathJax-Span-44" style=""><span class="mo" id="MathJax-Span-45" style=""><span style="">有</span></span></span></span><span class="texatom" id="MathJax-Span-46" style=""><span class="mrow" id="MathJax-Span-47" style=""><span class="mo" id="MathJax-Span-48" style=""><span style="">符</span></span></span></span><span class="texatom" id="MathJax-Span-49" style=""><span class="mrow" id="MathJax-Span-50" style=""><span class="mo" id="MathJax-Span-51" style=""><span style="">合</span></span></span></span><span class="texatom" id="MathJax-Span-52" style=""><span class="mrow" id="MathJax-Span-53" style=""><span class="mo" id="MathJax-Span-54" style=""><span style="">条</span></span></span></span><span class="texatom" id="MathJax-Span-55" style=""><span class="mrow" id="MathJax-Span-56" style=""><span class="mo" id="MathJax-Span-57" style=""><span style="">件</span></span></span></span><span class="texatom" id="MathJax-Span-58" style=""><span class="mrow" id="MathJax-Span-59" style=""><span class="mo" id="MathJax-Span-60" style=""><span style="">记</span></span></span></span><span class="texatom" id="MathJax-Span-61" style=""><span class="mrow" id="MathJax-Span-62" style=""><span class="mo" id="MathJax-Span-63" style=""><span style="">录</span></span></span></span><span class="texatom" id="MathJax-Span-64" style=""><span class="mrow" id="MathJax-Span-65" style=""><span class="mo" id="MathJax-Span-66" style=""><span style="">的</span></span></span></span><span class="mi" id="MathJax-Span-67" style="">R</span><span class="mi" id="MathJax-Span-68" style="">O</span><span class="mi" id="MathJax-Span-69" style="">W<span style=""></span></span><span class="mi" id="MathJax-Span-70" style="">I<span style=""></span></span><span class="mi" id="MathJax-Span-71" style="">D</span><span class="texatom" id="MathJax-Span-72" style=""><span class="mrow" id="MathJax-Span-73" style=""><span class="mo" id="MathJax-Span-74" style=""><span style="">）</span></span></span></span><span class="texatom" id="MathJax-Span-75" style=""><span class="mrow" id="MathJax-Span-76" style=""><span class="mo" id="MathJax-Span-77" style=""><span style="">，</span></span></span></span><span class="texatom" id="MathJax-Span-78" style=""><span class="mrow" id="MathJax-Span-79" style=""><span class="mo" id="MathJax-Span-80" style=""><span style="">通</span></span></span></span><span class="texatom" id="MathJax-Span-81" style=""><span class="mrow" id="MathJax-Span-82" style=""><span class="mo" id="MathJax-Span-83" style=""><span style="">过</span></span></span></span><span class="mi" id="MathJax-Span-84" style="">R</span><span class="mi" id="MathJax-Span-85" style="">O</span><span class="mi" id="MathJax-Span-86" style="">W<span style=""></span></span><span class="mi" id="MathJax-Span-87" style="">I<span style=""></span></span><span class="mi" id="MathJax-Span-88" style="">D</span><span class="texatom" id="MathJax-Span-89" style=""><span class="mrow" id="MathJax-Span-90" style=""><span class="mo" id="MathJax-Span-91" style=""><span style="">访</span></span></span></span><span class="texatom" id="MathJax-Span-92" style=""><span class="mrow" id="MathJax-Span-93" style=""><span class="mo" id="MathJax-Span-94" style=""><span style="">问</span></span></span></span><span class="texatom" id="MathJax-Span-95" style=""><span class="mrow" id="MathJax-Span-96" style=""><span class="mo" id="MathJax-Span-97" style=""><span style="">表</span></span></span></span><span class="texatom" id="MathJax-Span-98" style=""><span class="mrow" id="MathJax-Span-99" style=""><span class="mo" id="MathJax-Span-100" style=""><span style="">得</span></span></span></span><span class="texatom" id="MathJax-Span-101" style=""><span class="mrow" id="MathJax-Span-102" style=""><span class="mo" id="MathJax-Span-103" style=""><span style="">到</span></span></span></span><span class="mi" id="MathJax-Span-104" style="">L</span><span class="mi" id="MathJax-Span-105" style="">O</span><span class="mi" id="MathJax-Span-106" style="">D</span><span class="mi" id="MathJax-Span-107" style="">G</span><span class="mi" id="MathJax-Span-108" style="">I<span style=""></span></span><span class="mi" id="MathJax-Span-109" style="">N<span style=""></span></span><span class="mi" id="MathJax-Span-110" style="">G</span><span class="texatom" id="MathJax-Span-111" style=""><span class="mrow" id="MathJax-Span-112" style=""><span class="mo" id="MathJax-Span-113" style=""><span style="">列</span></span></span></span><span class="texatom" id="MathJax-Span-114" style=""><span class="mrow" id="MathJax-Span-115" style=""><span class="mo" id="MathJax-Span-116" style=""><span style="">的</span></span></span></span><span class="texatom" id="MathJax-Span-117" style=""><span class="mrow" id="MathJax-Span-118" style=""><span class="mo" id="MathJax-Span-119" style=""><span style="">值</span></span></span></span><span class="texatom" id="MathJax-Span-120" style=""><span class="mrow" id="MathJax-Span-121" style=""><span class="mo" id="MathJax-Span-122" style=""><span style="">由</span></span></span></span><span class="texatom" id="MathJax-Span-123" style=""><span class="mrow" id="MathJax-Span-124" style=""><span class="mo" id="MathJax-Span-125" style=""><span style="">于</span></span></span></span><span class="mi" id="MathJax-Span-126" style="">L</span><span class="mi" id="MathJax-Span-127" style="">O</span><span class="mi" id="MathJax-Span-128" style="">D</span><span class="mi" id="MathJax-Span-129" style="">G</span><span class="mi" id="MathJax-Span-130" style="">I<span style=""></span></span><span class="mi" id="MathJax-Span-131" style="">N<span style=""></span></span><span class="mi" id="MathJax-Span-132" style="">G</span></span><span style=""></span></span></span><span style=""></span></span></nobr><span class="MJX_Assistive_MathML" style="">MANAGER的索引范围查询（得到所有符合条件记录的ROWID），通过ROWID访问表得到LODGING列的值由于LODGING</span></span>MANAGER是一个非唯一性的索引，数据库不能对它执行索引唯一扫描</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  WHERE子句中，如果索引列所对应的值的第一个字符由通配符（WILDCARD）开始，索引将不被采用<br style="margin:0px; padding:0px" />&#13;\n    SELECT LODGING<br style="margin:0px; padding:0px" />&#13;\n    FROM LODGING<br style="margin:0px; padding:0px" />&#13;\n    WHERE MANAGER LIKE '％HANMAN';</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  在这种情况下，ORACLE将使用全表扫描</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n14.避免在索引列上使用计算<br style="margin:0px; padding:0px" />&#13;\n  WHERE子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描<br style="margin:0px; padding:0px" />&#13;\n  例如：<br style="margin:0px; padding:0px" />&#13;\n    低效<br style="margin:0px; padding:0px" />&#13;\n    SELECT …<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n    WHERE SAL csdn-100.html csdn-101.html csdn-102.html csdn-103.html csdn-104.html csdn-105.html csdn-106.html csdn-107.html csdn-108.html csdn-109.html csdn-10.html csdn-110.html csdn-111.html csdn-112.html csdn-113.html csdn-114.html csdn-115.html csdn-116.html csdn-117.html csdn-118.html csdn-119.html csdn-11.html csdn-120.html csdn-121.html csdn-122.html csdn-123.html csdn-124.html csdn-125.html csdn-126.html csdn-127.html csdn-128.html csdn-129.html csdn-12.html csdn-130.html csdn-131.html csdn-132.html csdn-133.html csdn-134.html csdn-135.html csdn-136.html csdn-137.html csdn-138.html csdn-139.html csdn-13.html csdn-140.html csdn-141.html csdn-142.html csdn-143.html csdn-144.html csdn-145.html csdn-146.html csdn-147.html csdn-148.html csdn-149.html csdn-14.html csdn-150.html csdn-151.html csdn-152.html csdn-153.html csdn-154.html csdn-155.html csdn-156.html csdn-157.html csdn-158.html csdn-159.html csdn-15.html csdn-160.html csdn-161.html csdn-162.html csdn-163.html csdn-164.html csdn-165.html csdn-166.html csdn-167.html csdn-168.html csdn-169.html csdn-16.html csdn-170.html csdn-171.html csdn-172.html csdn-173.html csdn-174.html csdn-175.html csdn-176.html csdn-177.html csdn-178.html csdn-179.html csdn-17.html csdn-180.html csdn-181.html csdn-182.html csdn-183.html csdn-184.html csdn-185.html csdn-186.html csdn-187.html csdn-188.html csdn-189.html csdn-18.html csdn-190.html csdn-191.html csdn-192.html csdn-193.html csdn-194.html csdn-195.html csdn-196.html csdn-197.html csdn-198.html csdn-199.html csdn-19.html csdn-1.html csdn-200.html csdn-201.html csdn-202.html csdn-203.html csdn-204.html csdn-205.html csdn-206.html csdn-207.html csdn-208.html csdn-209.html csdn-20.html csdn-210.html csdn-211.html csdn-212.html csdn-213.html csdn-214.html csdn-215.html csdn-216.html csdn-217.html csdn-218.html csdn-219.html csdn-21.html csdn-220.html csdn-221.html csdn-222.html csdn-223.html csdn-224.html csdn-225.html csdn-226.html csdn-227.html csdn-228.html csdn-229.html csdn-22.html csdn-230.html csdn-231.html csdn-232.html csdn-233.html csdn-234.html csdn-235.html csdn-236.html csdn-237.html csdn-238.html csdn-239.html csdn-23.html csdn-240.html csdn-241.html csdn-242.html csdn-243.html csdn-244.html csdn-245.html csdn-246.html csdn-247.html csdn-248.html csdn-249.html csdn-24.html csdn-250.html csdn-251.html csdn-252.html csdn-253.html csdn-254.html csdn-255.html csdn-256.html csdn-257.html csdn-258.html csdn-259.html csdn-25.html csdn-260.html csdn-261.html csdn-262.html csdn-263.html csdn-264.html csdn-265.html csdn-266.html csdn-267.html csdn-268.html csdn-269.html csdn-26.html csdn-270.html csdn-271.html csdn-272.html csdn-273.html csdn-274.html csdn-275.html csdn-276.html csdn-277.html csdn-278.html csdn-279.html csdn-27.html csdn-280.html csdn-281.html csdn-282.html csdn-283.html csdn-284.html csdn-285.html csdn-286.html csdn-287.html csdn-288.html csdn-289.html csdn-28.html csdn-290.html csdn-291.html csdn-292.html csdn-293.html csdn-294.html csdn-295.html csdn-296.html csdn-297.html csdn-298.html csdn-299.html csdn-29.html csdn-2.html csdn-300.html csdn-301.html csdn-302.html csdn-303.html csdn-304.html csdn-305.html csdn-306.html csdn-307.html csdn-308.html csdn-309.html csdn-30.html csdn-310.html csdn-311.html csdn-312.html csdn-313.html csdn-314.html csdn-315.html csdn-316.html csdn-317.html csdn-318.html csdn-319.html csdn-31.html csdn-320.html csdn-321.html csdn-322.html csdn-323.html csdn-324.html csdn-325.html csdn-326.html csdn-327.html csdn-328.html csdn-329.html csdn-32.html csdn-330.html csdn-331.html csdn-332.html csdn-333.html csdn-334.html csdn-335.html csdn-336.html csdn-337.html csdn-338.html csdn-339.html csdn-33.html csdn-340.html csdn-341.html csdn-342.html csdn-343.html csdn-344.html csdn-345.html csdn-346.html csdn-347.html csdn-348.html csdn-349.html csdn-34.html csdn-350.html csdn-351.html csdn-352.html csdn-353.html csdn-354.html csdn-355.html csdn-356.html csdn-357.html csdn-358.html csdn-359.html csdn-35.html csdn-360.html csdn-361.html csdn-362.html csdn-363.html csdn-364.html csdn-365.html csdn-366.html csdn-367.html csdn-368.html csdn-369.html csdn-36.html csdn-370.html csdn-371.html csdn-372.html csdn-373.html csdn-374.html csdn-375.html csdn-376.html csdn-377.html csdn-378.html csdn-379.html csdn-37.html csdn-380.html csdn-381.html csdn-382.html csdn-383.html csdn-384.html csdn-385.html csdn-386.html csdn-387.html csdn-388.html csdn-389.html csdn-38.html csdn-390.html csdn-391.html csdn-392.html csdn-393.html csdn-394.html csdn-395.html csdn-396.html csdn-397.html csdn-398.html csdn-399.html csdn-39.html csdn-3.html csdn-400.html csdn-401.html csdn-402.html csdn-403.html csdn-404.html csdn-405.html csdn-406.html csdn-407.html csdn-408.html csdn-409.html csdn-40.html csdn-410.html csdn-411.html csdn-412.html csdn-413.html csdn-414.html csdn-415.html csdn-416.html csdn-417.html csdn-418.html csdn-419.html csdn-41.html csdn-420.html csdn-421.html csdn-422.html csdn-423.html csdn-424.html csdn-425.html csdn-426.html csdn-427.html csdn-428.html csdn-429.html csdn-42.html csdn-430.html csdn-431.html csdn-432.html csdn-433.html csdn-434.html csdn-435.html csdn-436.html csdn-437.html csdn-438.html csdn-439.html csdn-43.html csdn-440.html csdn-441.html csdn-442.html csdn-443.html csdn-444.html csdn-445.html csdn-446.html csdn-447.html csdn-448.html csdn-449.html csdn-44.html csdn-450.html csdn-451.html csdn-452.html csdn-453.html csdn-454.html csdn-455.html csdn-456.html csdn-457.html csdn-458.html csdn-459.html csdn-45.html csdn-460.html csdn-461.html csdn-462.html csdn-463.html csdn-464.html csdn-465.html csdn-466.html csdn-467.html csdn-468.html csdn-469.html csdn-46.html csdn-470.html csdn-471.html csdn-472.html csdn-473.html csdn-474.html csdn-475.html csdn-476.html csdn-477.html csdn-478.html csdn-479.html csdn-47.html csdn-480.html csdn-481.html csdn-482.html csdn-483.html csdn-484.html csdn-485.html csdn-486.html csdn-487.html csdn-488.html csdn-489.html csdn-48.html csdn-490.html csdn-491.html csdn-492.html csdn-493.html csdn-494.html csdn-495.html csdn-496.html csdn-497.html csdn-498.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-91.html csdn-92.html csdn-93.html csdn-94.html csdn-95.html csdn-96.html csdn-97.html csdn-98.html csdn-99.html csdn-9.html mysql.sh 12 &gt; 25000;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n    高效<br style="margin:0px; padding:0px" />&#13;\n    SELECT …<br style="margin:0px; padding:0px" />&#13;\n    FROM DEPT<br style="margin:0px; padding:0px" />&#13;\n    WHERE SAL &gt; 25000/12;</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  请务必注意，检索中不要对索引列进行处理，如：TRIM，TO_DATE，类型转换等操作，破坏索引，使用全表扫描，影响SQL执行效率</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n15.避免在索引列上使用IS NULL和IS NOT NULL<br style="margin:0px; padding:0px" />&#13;\n  避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引<br style="margin:0px; padding:0px" />&#13;\n  对于单列索引，如果列包含空值，索引中将不存在此记录；<br style="margin:0px; padding:0px" />&#13;\n  对于复合索引，如果每个列都为空，索引中同样不存在此记录。如果至少有一个列不为空，则记录存在于索引中</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  如果唯一性索引建立在表的A列和B列上，并且表中存在一条记录的A,B值为(123,null)，<br style="margin:0px; padding:0px" />&#13;\n  ORACLE将不接受下一条具有相同A,B值（123,null）的记录插入<br style="margin:0px; padding:0px" />&#13;\n  如果所有的索引列都为空，ORACLE将认为整个键值为空，而空不可能等于空，因此你可以插入1000条具有相同键值的记录，当然它们都是空！<br style="margin:0px; padding:0px" />&#13;\n  因为空值不存在于索引列中，所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  低效（索引失效）<br style="margin:0px; padding:0px" />&#13;\n  SELECT …<br style="margin:0px; padding:0px" />&#13;\n  FROM DEPARTMENT<br style="margin:0px; padding:0px" />&#13;\n  WHERE DEPT_CODE IS NOT NULL</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n16.使用UNION-ALL和UNION<br style="margin:0px; padding:0px" />&#13;\n  当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并，然后在输出最终结果前进行排序<br style="margin:0px; padding:0px" />&#13;\n  如果用UNION ALL替代UNION，这样排序就不是必要了，效率就会因此得到提高</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n  需要注意的是，UNION ALL将重复输出两个结果集合中相同记录，因此还是要从业务需求分析使用UNION ALL的可行性</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n<br style="margin:0px; padding:0px" />&#13;\n关于索引下列经验请参考: <br style="margin:0px; padding:0px" />&#13;\n1).如果检索数据量超过30%的表中记录数，使用索引将没有显著的效率提高<br style="margin:0px; padding:0px" />&#13;\n2).在特定情况下，使用索引也许会比全表扫描慢，但这是同一个数量级上的差距；而通常情况下，使用索引比全表扫描要快几倍乃至几千倍！</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n其他具体内容请参考《ORACLE SQL性能优化系列》</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n17.使用PrepareStatement<br style="margin:0px; padding:0px" />&#13;\n在同一个方法中，当循环使用SQL文时，为了提高性能，<br style="margin:0px; padding:0px" />&#13;\n请使用PreparedStatement。注意，<br style="margin:0px; padding:0px" />&#13;\n仅限使用于少数的模块。<br style="margin:0px; padding:0px" />&#13;\n方法如下：</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n? PreparedStatement stmt<br style="margin:0px; padding:0px" />&#13;\n　　　= conn.prepareStatement("select a from TABLE_A where b=? c=?");</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n　for(?? ){<br style="margin:0px; padding:0px" />&#13;\n???? stmt.setInt(1, varB);　　　　　<br style="margin:0px; padding:0px" />&#13;\n???? stmt.setString(2, varC);　　　 　<br style="margin:0px; padding:0px" />&#13;\n? 　 ResultSet rst = stmt.executeQuery();</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n　}</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n</p>&#13;\n<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; line-height:19.5px; font-size:13px; font-family:Verdana,Arial,Helvetica,sans-serif; background-color:rgb(254,254,242)">&#13;\n </p>&#13;\n &#13;\n
