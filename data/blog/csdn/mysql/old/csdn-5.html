\n\n<h1>事务</h1>&#13;\n<h2>基本概念：</h2>&#13;\n<p>       事务使指一组最小逻辑操作单元，里面有多个操作组成。组成事务的每一部分必须要同时提交成功，如果有一个操作失败，整个操作就回滚。</p>&#13;\n<p> </p>&#13;\n<p><strong>事务ACID特性</strong></p>&#13;\n<p><span style="white-space:pre"></span>原子性（Atomicity）<br />&#13;\n<span style="white-space:pre"></span>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>&#13;\n<p><span style="white-space:pre"></span>一致性（Consistency）<br />&#13;\n<span style="white-space:pre"></span>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>&#13;\n<p><span style="white-space:pre"></span>隔离性（Isolation）<br />&#13;\n<span style="white-space:pre"></span>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p>&#13;\n<p><span style="white-space:pre"></span>持久性（Durability）<br />&#13;\n<span style="white-space:pre"></span>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>&#13;\n<p><strong> </strong></p>&#13;\n<p><strong>事务的特性：</strong></p>&#13;\n<p>      原子性，是一个最小逻辑操作单元 !</p>&#13;\n<p>      持久性， 事务一旦提交成功，对数据的更改会反映到数据库中。</p>&#13;\n<p>      隔离性， 事务与事务之间是隔离的。</p>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><strong>API：</strong></p>&#13;\n<p>|-- Connection</p>&#13;\n<p>       void setAutoCommit(boolean autoCommit) ;  设置事务是否自动提交，如果设置为false，表示手动提交事务。</p>&#13;\n<p>       void commit() ();                                                       手动提交事务</p>&#13;\n<p>       void rollback() ;                                                          回滚（出现异常时候，所有已经执行成功的代码需要回退到事务开始前的状态。）</p>&#13;\n<p>       Savepoint setSavepoint()                                        设置回滚点</p>&#13;\n<p>       void rollback(Savepoint sp)                                     回滚到指定位</p>&#13;\n<p><strong><br />&#13;\n</strong></p>&#13;\n<p><strong>Demo如下：</strong></p>&#13;\n<p><strong></strong></p>&#13;\n<pre code_snippet_id="2278871" snippet_file_name="blog_20170320_1_8132287" name="code" class="java">package com.cn.trans;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.Savepoint;\n\nimport org.junit.Test;\n\nimport com.cn.Util.JdbcUtil;\n\npublic class AccountDao {\n\t\n\t//全局参数\n\tprivate Connection conn= null;\n\tprivate PreparedStatement pstmt = null;\n\n\t//使用事务控制转账业务\n\t@Test\n\tpublic void trans(){\n\t\t\n\t\ttry {\n\t\t\t//获取连接\n\t\t\tconn = JdbcUtil.getConnection(); //默认开启的隐式事务\n\t\t\t//设置事务为手动提交\n\t\t\tconn.setAutoCommit(false);\n\t\t\t\n\t\t\t//转账sql\n\t\t\tString sql1 = "UPDATE account SET money=money-1000 WHERE accountName = '木丁西'";\n\t\t\tString sql2 = "UPDATE account SET money=money+1000 WHERE accountName = '小刘'";\n\n\t\t\t//预编译sql1\n\t\t\tpstmt = conn.prepareStatement(sql1);\n\t\t\t//执行sql1\n\t\t\tpstmt.executeUpdate();\n\t\t\t\n\t\t\t//预编译sql2\n\t\t\tpstmt = conn.prepareStatement(sql2);\n\t\t\t//执行sql2\n\t\t\tpstmt.executeUpdate();\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\ttry {\n\t\t\t\tconn.rollback();// 出现异常回滚事务\n\t\t\t} catch (Exception e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tconn.commit();//所有的操作执行成功，则提交事务\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tJdbcUtil.close(conn, pstmt);\n\t\t}\n\t\t\n\t}\n\t\n\t//使用事务控制转账业务，回滚到指定的代码\n\t@Test\n\tpublic void trans2(){\n\t\tSavepoint sp = null;\n\t\ttry {\n\t\t\t//获取连接\n\t\t\tconn = JdbcUtil.getConnection(); //默认开启的隐式事务\n\t\t\t//设置事务为手动提交\n\t\t\tconn.setAutoCommit(false);\n\t\t\t/*************第一次转账****************/\n\t\t\t//转账sql\n\t\t\tString sql1 = "UPDATE account SET money=money-1000 WHERE accountName = '木丁西'";\n\t\t\tString sql2 = "UPDATE account SET money=money+1000 WHERE accountName = '小刘'";\n\t\t\t//预编译sql1\n\t\t\tpstmt = conn.prepareStatement(sql1);\n\t\t\t//执行sql1\n\t\t\tpstmt.executeUpdate();\t\t\t\n\t\t\t//预编译sql2\n\t\t\tpstmt = conn.prepareStatement(sql2);\n\t\t\t//执行sql2\n\t\t\tpstmt.executeUpdate();\n\t\t\t\n\t\t\t//回滚到这个位置\n\t\t\tsp = conn.setSavepoint();\n\n\t\t\t/*************第二次转账****************/\n\t\t\t//转账sql\n\t\t\tString sql3 = "UPDATE account SET money=money-50 WHERE accountName = '木丁西'";\n\t\t\tString sql4 = "UPDATE account SET money=money+50 WHERE accountName = '小刘'";\n\t\t\tpstmt = conn.prepareStatement(sql3);\n\t\t\tpstmt.executeUpdate();\t\t\t\n\t\t\tpstmt = conn.prepareStatement(sql4);\n\t\t\tpstmt.executeUpdate();\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\ttry {\n\t\t\t\tconn.rollback(sp);// 出现异常回滚事务,回滚到指定位置\n\t\t\t} catch (Exception e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tconn.commit();//所有的操作执行成功，则提交事务\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tJdbcUtil.close(conn, pstmt);\n\t\t}\n\t\t\n\t}\n}\n</pre><br />&#13;\nJdbcUtil.java&#13;\n<p></p>&#13;\n<p><strong></strong></p>&#13;\n<pre code_snippet_id="2278871" snippet_file_name="blog_20170320_2_18878" name="code" class="java">package com.cn.Util;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh jdbc的工具类\n csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh @author liuzhiyong\n *\n */\npublic class JdbcUtil {\n\tprivate static String url = null;\n\tprivate static String user = null;\n\tprivate static String password = null;\n\tprivate static String driverClass = null;\n\t\n\t/**\n\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 静态代码块（只调用一次）\n\t */\n\tstatic{\n\t\ttry {\n\t\t\t//读取db.properties文件\n\t\t\tProperties properties = new Properties();\n\t\t\t/**\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh \n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 加载文件\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh \n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh . 代表java的命令运行的目录\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 在java项目下， . java命令的运行目录从项目的根目录MyEclipse工作空间/bin 目录开始\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 在web项目下， . java命令的运行目录从tomact/bin 目录开始\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 所以不能用.\n\t\t\t */\n\t\t\t\n\t\t\t/**\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 使用类路径的读取方式\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh \t/ 斜杠表示classpath的根目录\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 在java项目下，classpath的根目录从bin目录开始\n\t\t\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 在web项目下，classpath的根目录从WEB-INF/classes目录开始\n\t\t\t */\n\t\t\tInputStream in = JdbcUtil.class.getResourceAsStream("/db.properties");\n\t\t\tproperties.load(in);\n\t\t\t//读取信息\n\t\t\turl = properties.getProperty("url");\n\t\t\tuser = properties.getProperty("user");\n\t\t\tpassword = properties.getProperty("password");\n\t\t\tdriverClass = properties.getProperty("driverClass");\n//\t\t\tSystem.out.println(url);\n//\t\t\tSystem.out.println(user);\n//\t\t\tSystem.out.println(password);\n//\t\t\tSystem.out.println(driverClass);\n\t\t\t//注册驱动程序\n\t\t\tClass.forName(driverClass);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tSystem.out.println("驱动程序注册出错！");\n\t\t}\n\t}\n\t\n\t/**\n\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 获取连接对象的方法\n\t */\n\tpublic static Connection getConnection(){\n\t\t\n\t\ttry {\n\t\t\tConnection conn = DriverManager.getConnection(url, user, password);\n\t\t\treturn conn;\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 释放资源的重载方法\n\t */\n\tpublic static void close(Connection conn, Statement stmt, ResultSet rs){\n\t\t\n\t\t//关闭资源（顺序：后打开，先关闭）\n\t\tif(rs != null){\n\t\t\ttry {\n\t\t\t\trs.close();\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println("ResultSet关闭失败！");\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}if(stmt != null){\n\t\t\ttry {\n\t\t\t\tstmt.close();\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println("Statement关闭失败！");\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tif(conn != null){\n\t\t\ttry {\n\t\t\t\tconn.close();\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println("Connection关闭失败！");\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t csdn-1.html csdn-2.html csdn-3.html csdn-4.html mysql.sh 释放资源的重载方法\n\t */\n\tpublic static void close(Connection conn, Statement stmt){\n\t\t\n\t\t//关闭资源（顺序：后打开，先关闭）\n\t\tif(stmt != null){\n\t\t\ttry {\n\t\t\t\tstmt.close();\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println("Statement关闭失败！");\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tif(conn != null){\n\t\t\ttry {\n\t\t\t\tconn.close();\n\t\t\t} catch (SQLException e) {\n\t\t\t\tSystem.out.println("Connection关闭失败！");\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n</pre><br />&#13;\n<br />&#13;\n<p></p>&#13;\n &#13;\n
