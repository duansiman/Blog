\n\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n索引是一种特殊的文件（InnoDB 数据表上的索引是<a target="_blank" href="http://baike.baidu.com/view/70152.htm" style="color:rgb(19,110,194); text-decoration:none">表空间</a>的一个组成部分），它们包含着对数据表里所有记录的引用指针。索引不是万能的，索引可以加快数据检索操作，但会使<a target="_blank" href="http://baike.baidu.com/view/702991.htm" style="color:rgb(19,110,194); text-decoration:none">数据修改</a>操作变慢。每修改数据记录，索引就必须刷新一次。为了在某种程度上弥补这一缺陷，许多&#13;\n SQL 命令都有一个 DELAY_KEY_WRITE 项。这个选项的作用是暂时制止 MySQL 在该命令每插入一条新记录和每修改一条现有之后立刻对索引进行刷新，对索引的刷新将等到全部记录插入/修改完毕之后再进行。在需要把许多新记录插入某个数据表的场合，DELAY_KEY_WRITE 选项的作用将非常明显。另外，索引还会在硬盘上占用相当大的空间。因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n从理论上讲，完全可以为数据表里的每个字段分别建一个索引，但 MySQL 把同一个数据表里的索引总数限制为16个。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n1．InnoDB 数据表的索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n与 <a target="_blank" href="http://baike.baidu.com/view/1238935.htm" style="color:rgb(19,110,194); text-decoration:none">InnoDB</a>数据表相比，在 InnoDB 数据表上，索引对 InnoDB 数据表的重要性要大得多。在 InnoDB 数据表上，索引不仅会在搜索数据记录时发挥作用，还是数据行级锁定机制的苊、基础。“数据行级锁定”的意思是指在事务操作的执行过程中锁定正在被处理的个别记录，不让其他用户进行访问。这种锁定将影响到（但不限于）SELECT、LOCKINSHAREMODE、SELECT、FORUPDATE&#13;\n 命令以及 INSERT、UPDATE 和 DELETE 命令。出于效率方面的考虑，InnoDB 数据表的数据行级锁定实际发生在它们的索引上，而不是数据表自身上。显然，数据行级锁定机制只有在有关的数据表有一个合适的索引可供锁定的时候才能发挥效力。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n2．限制</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n如果 WHERE 子句的查询条件里有不等号（WHERE coloum !=），MySQL 将无法使用索引。类似地，如果 WHERE 子句的查询条件里使用了函数（WHERE DAY（column）=），MySQL 也将无法使用索引。在 JOIN 操作中（需要从多个数据表提取数据时），MySQL 只有在主键和<a target="_blank" href="http://baike.baidu.com/view/68073.htm" style="color:rgb(19,110,194); text-decoration:none">外键</a>的数据类型相同时才能使用索引。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n如果 WHERE 子句的查询条件里使用比较操作符 LIKE 和 REGEXP，MySQL 只有在搜索模板的第一个字符不是<a target="_blank" href="http://baike.baidu.com/view/451.htm" style="color:rgb(19,110,194); text-decoration:none">通配符</a>的情况下才能使用索引。比如说，如果查询条件是 LIKE 'abc%‘，MySQL 将使用索引；如果查询条件是 LIKE&#13;\n '%abc’，MySQL 将不使用索引。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n在 ORDER BY 操作中，MySQL 只有在排序条件不是一个查询条件表达式的情况下才使用索引。（虽然如此，在涉及多个数据表查询里，即使有索引可用，那些索引在加快 ORDER BY 方面也没什么作用）。如果某个数据列里包含许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含的净是些诸如 “0/1” 或 “Y/N” 等值，就没有必要为它创建一个索引。</div>&#13;\n<div class="anchor-list" style="position:relative; color:rgb(51,51,51); font-family:arial,&#x5B8B;&#x4F53;,sans-serif; line-height:18px">&#13;\n<a target="_blank" name="5_1" class="lemma-anchor para-title " style="color:rgb(19,110,194); position:absolute; top:-50px" id="5_1"></a><a target="_blank" name="sub15308361_5_1" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="sub15308361_5_1"></a><a target="_blank" name="索引类别" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="索引类别"></a></div>&#13;\n<div class="para-title level-3" style="clear:both; zoom:1; margin:20px 0px 12px; line-height:20px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; color:rgb(51,51,51)">&#13;\n<h3 class="title-text" style="margin:0px; padding:0px; font-size:18px; font-weight:400">&#13;\n索引类别</h3>&#13;\n</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n1．普通索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column =）或排序条件（ORDER BY column）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n2．唯一索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE 把它定义为一个<a target="_blank" href="http://baike.baidu.com/view/709651.htm" style="color:rgb(19,110,194); text-decoration:none">唯一索引</a>。这么做的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL&#13;\n 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n3．主索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n在前面已经反复多次强调过：必须为主键字段创建一个索引，这个索引就是所谓的“<a target="_blank" href="http://baike.baidu.com/view/1862718.htm" style="color:rgb(19,110,194); text-decoration:none">主索引</a>”。主索引与<a target="_blank" href="http://baike.baidu.com/view/709651.htm" style="color:rgb(19,110,194); text-decoration:none">唯一索引</a>的唯一区别是：前者在定义时使用的<a target="_blank" href="http://baike.baidu.com/view/390935.htm" style="color:rgb(19,110,194); text-decoration:none">关键字</a>是&#13;\n PRIMARY 而不是 UNIQUE。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n4．外键索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n如果为某个<a target="_blank" href="http://baike.baidu.com/view/68073.htm" style="color:rgb(19,110,194); text-decoration:none">外键</a>字段定义了一个外键约束条件，MySQL 就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n5．复合索引</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n索引可以覆盖多个数据列，如像 INDEX (columnA, columnB) 索引。这种索引的特点是 MySQL 可以有选择地使用一个这样的索引。如果查询操作只需要用到 columnA 数据列上的一个索引，就可以使用复合索引 INDEX(columnA, columnB)。不过，这种用法仅适用于在复合索引中排列在前的数据列组合。比如说，INDEX (A，B，C) 可以当做 A 或 (A,B) 的索引来使用，但不能当做 B、C 或 (B,C) 的索引来使用。</div>&#13;\n<div class="anchor-list" style="position:relative; color:rgb(51,51,51); font-family:arial,&#x5B8B;&#x4F53;,sans-serif; line-height:18px">&#13;\n<a target="_blank" name="5_2" class="lemma-anchor para-title " style="color:rgb(19,110,194); position:absolute; top:-50px" id="5_2"></a><a target="_blank" name="sub15308361_5_2" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="sub15308361_5_2"></a><a target="_blank" name="索引长度" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="索引长度"></a></div>&#13;\n<div class="para-title level-3" style="clear:both; zoom:1; margin:20px 0px 12px; line-height:20px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; color:rgb(51,51,51)">&#13;\n<h3 class="title-text" style="margin:0px; padding:0px; font-size:18px; font-weight:400">&#13;\n索引长度</h3>&#13;\n</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n在为 CHAR 和 VARCHAR 类型的数据列定义索引时，可以把索引的长度限制为一个给定的<a target="_blank" href="http://baike.baidu.com/view/263416.htm" style="color:rgb(19,110,194); text-decoration:none">字符</a>个数（这个数字必须小于这个字段所允许的最大字符个数）。这么做的好处是可以生成一个尺寸比较小、检索速度却比较快的<a target="_blank" href="http://baike.baidu.com/view/2064014.htm" style="color:rgb(19,110,194); text-decoration:none">索引文件</a>。在绝大多数应用里，数据库中的字符串数据大都以各种各样的名字为主，把索引的长度设置为10~15&#13;\n 个字符已经足以把搜索范围缩小到很少的几条数据记录了。在为 BLOB 和 TEXT 类型的数据列创建索引时，必须对索引的长度做出限制；MySQL 所允许的最大索引<a target="_blank" href="http://baike.baidu.com/view/62889.htm" style="color:rgb(19,110,194); text-decoration:none">全文索引</a>文本字段上的普通索引只能加快对出现在字段内容最前面的字符串（也就是字段内容开头的字符）进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。这种检索往往以的形式出现，这对&#13;\n MySQL 来说很复杂，如果需要处理的数据量很大，响应时间就会很长。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n这类场合正是全文索引（full-textindex）可以大显身手的地方。在生成这种类型的索引时，MySQL 将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\nALTER TABLE tablename ADD FULLTEXT（column1，column2）有了全文索引，就可以用 SELECT 查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\nSELECT csdn-100.html csdn-101.html csdn-102.html csdn-103.html csdn-104.html csdn-105.html csdn-106.html csdn-107.html csdn-108.html csdn-109.html csdn-10.html csdn-110.html csdn-111.html csdn-112.html csdn-113.html csdn-114.html csdn-115.html csdn-116.html csdn-117.html csdn-118.html csdn-119.html csdn-11.html csdn-120.html csdn-121.html csdn-122.html csdn-123.html csdn-124.html csdn-125.html csdn-126.html csdn-127.html csdn-128.html csdn-129.html csdn-12.html csdn-130.html csdn-131.html csdn-132.html csdn-133.html csdn-134.html csdn-135.html csdn-136.html csdn-137.html csdn-138.html csdn-139.html csdn-13.html csdn-140.html csdn-141.html csdn-142.html csdn-143.html csdn-144.html csdn-145.html csdn-146.html csdn-147.html csdn-148.html csdn-149.html csdn-14.html csdn-150.html csdn-151.html csdn-152.html csdn-153.html csdn-154.html csdn-155.html csdn-156.html csdn-157.html csdn-158.html csdn-159.html csdn-15.html csdn-160.html csdn-161.html csdn-162.html csdn-163.html csdn-164.html csdn-165.html csdn-166.html csdn-167.html csdn-168.html csdn-169.html csdn-16.html csdn-170.html csdn-171.html csdn-172.html csdn-173.html csdn-174.html csdn-175.html csdn-176.html csdn-177.html csdn-178.html csdn-179.html csdn-17.html csdn-180.html csdn-181.html csdn-182.html csdn-183.html csdn-184.html csdn-185.html csdn-186.html csdn-187.html csdn-188.html csdn-189.html csdn-18.html csdn-190.html csdn-191.html csdn-192.html csdn-193.html csdn-194.html csdn-195.html csdn-196.html csdn-197.html csdn-198.html csdn-199.html csdn-19.html csdn-1.html csdn-200.html csdn-201.html csdn-202.html csdn-203.html csdn-204.html csdn-205.html csdn-206.html csdn-207.html csdn-208.html csdn-209.html csdn-20.html csdn-210.html csdn-211.html csdn-212.html csdn-213.html csdn-214.html csdn-215.html csdn-216.html csdn-217.html csdn-218.html csdn-219.html csdn-21.html csdn-220.html csdn-221.html csdn-222.html csdn-223.html csdn-224.html csdn-225.html csdn-226.html csdn-227.html csdn-228.html csdn-229.html csdn-22.html csdn-230.html csdn-231.html csdn-232.html csdn-233.html csdn-234.html csdn-235.html csdn-236.html csdn-237.html csdn-238.html csdn-239.html csdn-23.html csdn-240.html csdn-241.html csdn-242.html csdn-243.html csdn-244.html csdn-245.html csdn-246.html csdn-247.html csdn-248.html csdn-249.html csdn-24.html csdn-250.html csdn-251.html csdn-252.html csdn-253.html csdn-254.html csdn-255.html csdn-256.html csdn-257.html csdn-258.html csdn-259.html csdn-25.html csdn-260.html csdn-261.html csdn-262.html csdn-263.html csdn-264.html csdn-265.html csdn-266.html csdn-267.html csdn-268.html csdn-269.html csdn-26.html csdn-270.html csdn-271.html csdn-272.html csdn-273.html csdn-274.html csdn-275.html csdn-276.html csdn-277.html csdn-278.html csdn-279.html csdn-27.html csdn-280.html csdn-281.html csdn-282.html csdn-283.html csdn-284.html csdn-285.html csdn-286.html csdn-287.html csdn-288.html csdn-289.html csdn-28.html csdn-290.html csdn-291.html csdn-292.html csdn-293.html csdn-294.html csdn-295.html csdn-296.html csdn-297.html csdn-298.html csdn-299.html csdn-29.html csdn-2.html csdn-300.html csdn-301.html csdn-302.html csdn-303.html csdn-304.html csdn-305.html csdn-306.html csdn-307.html csdn-308.html csdn-309.html csdn-30.html csdn-310.html csdn-311.html csdn-312.html csdn-313.html csdn-314.html csdn-315.html csdn-316.html csdn-317.html csdn-318.html csdn-319.html csdn-31.html csdn-320.html csdn-321.html csdn-322.html csdn-323.html csdn-324.html csdn-325.html csdn-326.html csdn-327.html csdn-328.html csdn-329.html csdn-32.html csdn-330.html csdn-331.html csdn-332.html csdn-333.html csdn-334.html csdn-335.html csdn-336.html csdn-337.html csdn-338.html csdn-339.html csdn-33.html csdn-340.html csdn-341.html csdn-342.html csdn-343.html csdn-344.html csdn-345.html csdn-346.html csdn-347.html csdn-348.html csdn-349.html csdn-34.html csdn-350.html csdn-351.html csdn-352.html csdn-353.html csdn-354.html csdn-355.html csdn-356.html csdn-357.html csdn-358.html csdn-359.html csdn-35.html csdn-360.html csdn-361.html csdn-362.html csdn-363.html csdn-364.html csdn-365.html csdn-366.html csdn-367.html csdn-368.html csdn-369.html csdn-36.html csdn-370.html csdn-371.html csdn-372.html csdn-373.html csdn-374.html csdn-375.html csdn-376.html csdn-377.html csdn-378.html csdn-379.html csdn-37.html csdn-380.html csdn-381.html csdn-382.html csdn-383.html csdn-384.html csdn-385.html csdn-386.html csdn-387.html csdn-388.html csdn-389.html csdn-38.html csdn-390.html csdn-391.html csdn-392.html csdn-393.html csdn-394.html csdn-395.html csdn-396.html csdn-397.html csdn-398.html csdn-399.html csdn-39.html csdn-3.html csdn-400.html csdn-401.html csdn-402.html csdn-403.html csdn-404.html csdn-405.html csdn-406.html csdn-407.html csdn-408.html csdn-409.html csdn-40.html csdn-410.html csdn-411.html csdn-412.html csdn-413.html csdn-414.html csdn-415.html csdn-416.html csdn-417.html csdn-418.html csdn-419.html csdn-41.html csdn-420.html csdn-421.html csdn-422.html csdn-423.html csdn-424.html csdn-425.html csdn-426.html csdn-427.html csdn-428.html csdn-429.html csdn-42.html csdn-430.html csdn-431.html csdn-432.html csdn-433.html csdn-434.html csdn-435.html csdn-436.html csdn-437.html csdn-438.html csdn-439.html csdn-43.html csdn-440.html csdn-441.html csdn-442.html csdn-443.html csdn-444.html csdn-445.html csdn-446.html csdn-447.html csdn-448.html csdn-449.html csdn-44.html csdn-450.html csdn-451.html csdn-452.html csdn-453.html csdn-454.html csdn-455.html csdn-456.html csdn-457.html csdn-458.html csdn-459.html csdn-45.html csdn-460.html csdn-461.html csdn-462.html csdn-463.html csdn-464.html csdn-465.html csdn-466.html csdn-467.html csdn-468.html csdn-469.html csdn-46.html csdn-470.html csdn-471.html csdn-472.html csdn-473.html csdn-474.html csdn-475.html csdn-476.html csdn-477.html csdn-478.html csdn-479.html csdn-47.html csdn-480.html csdn-481.html csdn-482.html csdn-483.html csdn-484.html csdn-485.html csdn-486.html csdn-487.html csdn-488.html csdn-489.html csdn-48.html csdn-490.html csdn-491.html csdn-492.html csdn-493.html csdn-494.html csdn-495.html csdn-496.html csdn-497.html csdn-498.html csdn-499.html csdn-49.html csdn-4.html csdn-500.html csdn-501.html csdn-502.html csdn-503.html csdn-504.html csdn-505.html csdn-506.html csdn-507.html csdn-508.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-91.html csdn-92.html csdn-93.html csdn-94.html csdn-95.html csdn-96.html csdn-97.html csdn-98.html csdn-99.html csdn-9.html mysql.sh FROM tablename</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\nWHERE MATCH (column1,column2) AGAINST('word1','word2','word3')</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n上面这条命令将把 column1 和 column2 字段里有 word1、word2 和 word3 的数据记录全部查询出来。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n注解：InnoDB 数据表不支持全文索引。</div>&#13;\n<div class="anchor-list" style="position:relative; color:rgb(51,51,51); font-family:arial,&#x5B8B;&#x4F53;,sans-serif; line-height:18px">&#13;\n<a target="_blank" name="5_3" class="lemma-anchor para-title " style="color:rgb(19,110,194); position:absolute; top:-50px" id="5_3"></a><a target="_blank" name="sub15308361_5_3" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="sub15308361_5_3"></a><a target="_blank" name="查询和索引" class="lemma-anchor " style="color:rgb(19,110,194); position:absolute; top:-50px" id="查询和索引"></a></div>&#13;\n<div class="para-title level-3" style="clear:both; zoom:1; margin:20px 0px 12px; line-height:20px; font-size:18px; font-family:'Microsoft YaHei',SimHei,Verdana; color:rgb(51,51,51)">&#13;\n<h3 class="title-text" style="margin:0px; padding:0px; font-size:18px; font-weight:400">&#13;\n查询和索引</h3>&#13;\n</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快--不管有没有使用索引。只有当数据库里的记录超过了 1000 条、数据总量也超过了 MySQL 服务器上的内存总量时，数据库的性能测试结果才有意义。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n在不确定应该在哪些数据列上创建索引的时候，人们从 EXPLAIN SELECT 命令那里往往可以获得一些帮助。这其实只是简单地给一条普通的 SELECT 命令加一个 EXPLAIN 关键字作为前缀而已。有了这个关键字，MySQL 将不是去执行那条 SELECT 命令，而是去对它进行分析。MySQL 将以表格的形式把查询的执行过程和用到的索引等信息列出来。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n在 EXPLAIN 命令的输出结果里，第1列是从数据库读取的数据表的名字，它们按被读取的先后顺序排列。type列指定了本数据表与其它数据表之间的关联关系（JOIN）。在各种类型的关联关系当中，效率最高的是 system，然后依次是 const、eq_ref、ref、range、index 和 All（All 的意思是：对应于上一级数据表里的每一条记录，这个数据表里的所有记录都必须被读取一遍——这种情况往往可以用一索引来避免）。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\npossible_keys 数据列给出了 MySQL 在搜索数据记录时可选用的各个索引。key 数据列是 MySQL 实际选用的索引，这个索引按<a target="_blank" href="http://baike.baidu.com/view/60408.htm" style="color:rgb(19,110,194); text-decoration:none">字节</a>计算的长度在 key_len 数据列里给出。比如说，对于一个 INTEGER 数据列的索引，这个字节长度将是4。如果用到了复合索引，在&#13;\n key_len 数据列里还可以看到 MySQL 具体使用了它的哪些部分。作为一般规律，key_len 数据列里的值越小越好。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\nref 数据列给出了关联关系中另一个数据表里的数据列的名字。row 数据列是 MySQL 在执行这个查询时预计会从这个数据表里读出的数据行的个数。row 数据列里的所有数字的乘积可以大致了解这个查询需要处理多少组合。</div>&#13;\n<div class="para" style="font-size:14px; word-wrap:break-word; color:rgb(51,51,51); margin-bottom:15px; text-indent:2em; line-height:24px; zoom:1; font-family:arial,&#x5B8B;&#x4F53;,sans-serif">&#13;\n最后，extra 数据列提供了与 JOIN 操作有关的更多信息，比如说，如果 MySQL 在执行这个查询时必须创建一个临时数据表，就会在 extra 列看到 usingtemporary 字样。</div>&#13;\n &#13;\n
