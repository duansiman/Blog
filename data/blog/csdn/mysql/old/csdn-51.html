\n <div class="markdown_views"><blockquote>\n <p>摘自《高性能的MySQL》</p>\n</blockquote>\n\n<p>在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果–而不一定总要从MySQL获取一模一样的结果集。有时候可以查询转换一种写法让其返回一样的结果，但是性能更好。但也可以通过修改应用代码，用另一种方式完成查询，最终达到一样的目的。这里我们将介绍如何通过这种方式来重构查询，并展示何时需要使用这样的技巧。</p>\n\n<h1 id="用一个复杂的查询还是多个简单的查询">用一个复杂的查询还是多个简单的查询。</h1>\n\n<p>设计查询的时候一个需要考虑的重要问题是：是否需要将一个复杂的查询分成多个简单的查询。在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信，查询解析和优化是一件代价很高的事情。</p>\n\n<p>但是这样的想法对于MySQL并不适用，MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面效率很高效。现代的网络速度比之前的要快很多，无论是带宽还是延迟。在某些版本的MySQL上，即使在一个通用服务器上，也能够运行每秒超过10W的查询，即使是一个千兆网卡也能轻松满足每秒超过2000次的查询。所以运行多个小查询现在已经不是很大的问题了。</p>\n\n<p>MySQL内部每秒能够扫描内存中百万行的数据，相比之下，MySQL响应数据给客户端就要慢得多了。在其他条件都相同的时候，使用尽肯能少的查询当然是最好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。别害怕这样做，好好的衡量一下这样做是不是会减少工作量。</p>\n\n<h1 id="切分查询">切分查询</h1>\n\n<p>有时候对于一个大查询我们需要分而治之，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回以小部分结果。</p>\n\n<p>删除旧的数据就是一个很好的例子。定期的清理大量数据时，如果用一个大的语句一次性完成的话，则可能要一次锁住很多的数据，占满整个事务日志，耗尽系统资源，阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小的影响MySQL的性能，同时还可以减少MySQL复制的延迟。例如我们需要每个月运行一次下面的查询：</p>\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> message <span class="hljs-keyword">WHERE</span> created &lt; DATE_SUB(NOW(),<span class="hljs-keyword">INTERVAL</span> <span class="hljs-number">3</span> <span class="hljs-keyword">MONTH</span>);</span></code></pre>\n\n<p>那么可以用类似下面的办法来完成同样的工作：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs bash">rows_affected = <span class="hljs-number">0</span>\n\n　　<span class="hljs-keyword">do</span>{\n\n　　rows_affected = <span class="hljs-keyword">do</span>_query(<span class="hljs-string">"DELETE FROM message 　WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH)) LIMIT 10000"</span>}\n\n}<span class="hljs-keyword">while</span> rows_affected &gt; <span class="hljs-number">0</span></code></pre>\n\n<p>一次删除1W行数据一般来说是一个比较高效而且对服务器影响也最小的做法（如果是事务型引擎，很多时候小事务能够更高效）。同时需要注意的是，如果每次删除数据后，都暂停一会再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时的锁的持有时间。</p>\n\n<h1 id="分解关联查询">分解关联查询</h1>\n\n<p>很多高性能的应用都会对关联查询进行分解。简单的说，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如，下面的查询：</p>\n\n<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-subst">*</span> FROM <span class="hljs-built_in">tag</span> <span class="hljs-keyword">JOIN</span> tag_post <span class="hljs-keyword">on</span> tag_post<span class="hljs-built_in">.</span>tag_id <span class="hljs-subst">=</span> <span class="hljs-built_in">tag</span><span class="hljs-built_in">.</span>tag_id <span class="hljs-keyword">JOIN</span> post <span class="hljs-keyword">ON</span> tag_post<span class="hljs-built_in">.</span>post_id <span class="hljs-subst">=</span> post<span class="hljs-built_in">.</span>id <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">tag</span><span class="hljs-built_in">.</span><span class="hljs-built_in">tag</span> <span class="hljs-subst">=</span> <span class="hljs-string">'mysql'</span></code></pre>\n\n<p>可以分解成下面的这些查询来代替：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql">　　<span class="hljs-operator"><span class="hljs-keyword">SELECT</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-5.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">FROM</span> tag <span class="hljs-keyword">where</span> tag = <span class="hljs-string">'mysql'</span>;</span>\n\n　　<span class="hljs-operator"><span class="hljs-keyword">SELECT</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-5.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">FROM</span> tag_post <span class="hljs-keyword">WHERE</span> tagid=<span class="hljs-number">1234</span>;</span>\n\n　　<span class="hljs-operator"><span class="hljs-keyword">SELECT</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-5.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">FROM</span> post <span class="hljs-keyword">WHERE</span> post_id <span class="hljs-keyword">in</span> (<span class="hljs-number">123</span>,<span class="hljs-number">234</span>,<span class="hljs-number">435</span>,<span class="hljs-number">342</span>);</span></code></pre>\n\n<p>到底为什么要这么做？乍一看，这样做并没有什么好处，原本一条查询，这里却变成多条查询，返回的结果又是一模一样的的。事实上，用分解关联查询的方式重构查询，有如下的优势：</p>\n\n<ul>\n<li>让缓存的效率更高。许多应用程序可以方便的缓冲单表查询对应的结果对象。例如：啥忙查询的tag已经被缓存了，那么应用就已经跳过第一个查询。再例如，应用中已经缓存了id为123,234,345的内容，那么第三个查询的in（）中就可以少了几个id，另外对应MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</li>\n<li>将查询拆分后，执行单个查询可以减少锁的竞争。</li>\n<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能能和可扩展。</li>\n<li>查询本身效率也可能会有所提升。这个例子中使用in（）代替关联查询，可以让MySQL按照id顺序进行查询，这可比随机的关联要更高效。</li>\n<li>可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能重复的访问同一部分数据。从这点看，这样的重构可能会减少网络和内存的消耗。</li>\n<li>更进一步，这样做相当于在应用中实现了hash关联，而不是使用MySQL的嵌套循环关联。某些场景中hash的关联效率要高很多。</li>\n</ul>\n\n<p>在很多场景下，通过重构查询将关联查询放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便的缓冲单个查询的结果的时候，可以将数据分布到不同的MySQL服务器上的时候，当能够使用in（）的方式代替关联查询的时候，当查询中使用同一个数据表的时候。</p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
