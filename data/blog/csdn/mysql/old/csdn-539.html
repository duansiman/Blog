\n <div class="markdown_views"><h2 id="数据库连接池">数据库连接池</h2>\n\n<p>1、什么是数据库连接池？ <br />\n      数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。 <br />\n2、为什么要引入数据库连接池？出现的原因 <br />\n       用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。在多线程的环境下容易浪费资源 <br />\n       数据库连接池的出现就是为了减少服务器的负担，提高资源的利用效率。 <br />\n3、原理：数据库连接池的原理就是回收机制，也就是关闭的连接能及时在利用，避免浪费。</p>\n\n<p>下面是简单版的数据库连接池 <br />\nConnsUtils.javal类</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.hncu.pool;\n\n<span class="hljs-keyword">import</span> java.io.IOException;\n<span class="hljs-keyword">import</span> java.sql.Connection;\n<span class="hljs-keyword">import</span> java.sql.DriverManager;\n<span class="hljs-keyword">import</span> java.sql.SQLException;\n<span class="hljs-keyword">import</span> java.util.ArrayList;\n<span class="hljs-keyword">import</span> java.util.List;\n<span class="hljs-keyword">import</span> java.util.Properties;\n\n\n\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnsUtils</span> {</span>\n <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Connection&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;Connection&gt;();\n <span class="hljs-keyword">static</span>{\n Properties p=<span class="hljs-keyword">new</span> Properties();\n <span class="hljs-keyword">try</span> {\n p.load(ConnsUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">"jdbc.properities"</span>));\n String url = p.getProperty(<span class="hljs-string">"url"</span>);\n String user=p.getProperty(<span class="hljs-string">"user"</span>);String driver=p.getProperty(<span class="hljs-string">"driver"</span>);\n Class.forName(driver);<span class="hljs-comment">//如果是tomcat中，加载驱动不能少</span>\n String password=p.getProperty(<span class="hljs-string">"password"</span>);\n <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++){\n Connection con=DriverManager.getConnection(url, user, password);\n list.add(con);\n }\n } <span class="hljs-keyword">catch</span> (IOException e) {\n e.printStackTrace();\n } <span class="hljs-keyword">catch</span> (SQLException e) {\n e.printStackTrace();\n }\n }\n <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getCon</span>(){\n <span class="hljs-keyword">synchronized</span> (list) {\n <span class="hljs-keyword">if</span> (list.size()&lt;=<span class="hljs-number">0</span>) {\n <span class="hljs-keyword">try</span> {\n list.wait();\n } <span class="hljs-keyword">catch</span> (InterruptedException e) {\n e.printStackTrace();\n }\n } \n }\n\n <span class="hljs-keyword">return</span> list.remove(<span class="hljs-number">0</span>);\n }\n <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">back</span>(Connection con){\n <span class="hljs-keyword">synchronized</span> (list) {\n System.out.println(<span class="hljs-string">"还回来了一个连接...."</span>);\n list.notify();\n list.add(con);\n }\n }\n}\n</code></pre>\n\n<p>测试：PoolTest .java</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">package cn.hncu.pool;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport cn.hncu.utils.ConnectFactory;\n\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PoolTest {\n <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {\n Connection con=<span class="hljs-keyword">null</span>;\n <span class="hljs-keyword">try</span> {\n con = ConnsUtils.getCon();\n } <span class="hljs-keyword">catch</span> (Exception e) {\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"正在等待资源"</span>);\n }\n <span class="hljs-keyword">try</span> {\n con.setAutoCommit(<span class="hljs-keyword">false</span>);\n Statement st = con.createStatement();\n String sql = <span class="hljs-string">"insert into book(name) values('bb')"</span>;\n st.execute(sql);\n <span class="hljs-keyword">new</span> OneThread(<span class="hljs-number">1</span>).start();\n <span class="hljs-keyword">new</span> OneThread(<span class="hljs-number">2</span>).start();\n <span class="hljs-keyword">new</span> OneThread(<span class="hljs-number">3</span>).start();\n <span class="hljs-keyword">new</span> OneThread(<span class="hljs-number">4</span>).start();\n <span class="hljs-keyword">new</span> OneThread(<span class="hljs-number">5</span>).start();\n sql = <span class="hljs-string">"insert into book(name) values('bb2') "</span>;\n st.execute(sql);\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"主线程准备提交"</span>);\n con.commit();\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"主线程提交完毕"</span>);\n } <span class="hljs-keyword">catch</span> (Exception e) {\n <span class="hljs-keyword">try</span> {\n con.rollback();\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"主线程回滚了..."</span>);\n } <span class="hljs-keyword">catch</span> (SQLException e1) {\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"主线程回滚失败..."</span>);\n }\n\n }<span class="hljs-keyword">finally</span>{\n <span class="hljs-keyword">if</span>(con!=<span class="hljs-keyword">null</span>){\n <span class="hljs-keyword">try</span> {\n con.setAutoCommit(<span class="hljs-keyword">true</span>);\n ConnsUtils.back(con);<span class="hljs-comment">//还资源</span>\n<span class="hljs-comment">// con.close();</span>\n } <span class="hljs-keyword">catch</span> (SQLException e) {\n <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"连接关闭失败!"</span>, e);\n }\n }\n\n }\n }\n}\n\nclass OneThread extends Thread{\n <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;\n\n <span class="hljs-keyword">public</span> <span class="hljs-title">OneThread</span>(<span class="hljs-keyword">int</span> i) {\n <span class="hljs-keyword">this</span>.i = i;\n }\n\n @Override\n <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {\n Connection con=ConnsUtils.getCon();\n <span class="hljs-keyword">try</span> {\n con.setAutoCommit(<span class="hljs-keyword">false</span>);\n Statement st = con.createStatement();\n String sql = <span class="hljs-string">"insert into book(name) values('aa="</span>+i+<span class="hljs-string">"')"</span>;\n st.execute(sql);\n sql = <span class="hljs-string">"insert into book(name) values('aaa="</span>+i+<span class="hljs-string">"') "</span>;\n st.execute(sql);\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"线程准备提交"</span>);\n con.commit();\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"个线程提交完毕"</span>);\n } <span class="hljs-keyword">catch</span> (Exception e) {\n <span class="hljs-keyword">try</span> {\n con.rollback();\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"个线程回滚了..."</span>);\n } <span class="hljs-keyword">catch</span> (SQLException e1) {\n System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"第"</span>+i+<span class="hljs-string">"个线程回滚失败..."</span>);\n }\n\n }<span class="hljs-keyword">finally</span>{\n <span class="hljs-keyword">if</span>(con!=<span class="hljs-keyword">null</span>){\n <span class="hljs-keyword">try</span> {\n con.setAutoCommit(<span class="hljs-keyword">true</span>);\n ConnsUtils.back(con);<span class="hljs-comment">//还资源</span>\n<span class="hljs-comment">// con.close();</span>\n } <span class="hljs-keyword">catch</span> (SQLException e) {\n <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"连接关闭失败!"</span>, e);\n }\n }\n\n }\n }\n\n}\n</code></pre>\n\n<pre><code> 我们发现，con对象不能关闭，否则就会出现，拿不到Connection对象的情况，导致查询无法完成，所有必须引入动态代理来解决这个弱点。\n</code></pre>\n\n<hr />\n\n\n\n<h2 id="动态代理">动态代理</h2>\n\n<p>1、简介：Java动态代理类位于Java.lang.reflect包下，一般主要涉及到以下两个类：</p>\n\n<ul>\n<li>Interface InvocationHandler：该接口中仅定义了一个方法Object：invoke(Object obj,Method method,Object[] <br />\nargs）。在实际使用时，第一个参数obj一般是指代理类（要小心使用，不小心就是死循环），method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。</li>\n<li>Proxy：该类即为动态代理类，作用类似于上例中的ProxySubject，其中主要包含以下内容： Protected <br />\nProxy(InvocationHandler h）：构造函数，估计用于给内部的h赋值。 Static Class getProxyClass (ClassLoader loader,Class[] <br />\ninterfaces）：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。 <br />\n2、代理机制及特点</li>\n<li>通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 <br />\ninterface 来创建动态代理类；</li>\n<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>\n<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入</li>\n</ul>\n\n<p>3、核心代码：我通过图片来进行注解 <br />\n<img src="http://img.blog.csdn.net/20160810015339162" alt="这里写图片描述" title="" /></p>\n\n<p>下面演示详细代码，与数据库连接池联合使用 <br />\nConnsUtils.javal类</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.hncu.proxy;\n\n<span class="hljs-keyword">import</span> java.io.IOException;\n<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;\n<span class="hljs-keyword">import</span> java.lang.reflect.Method;\n<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;\n<span class="hljs-keyword">import</span> java.sql.Connection;\n<span class="hljs-keyword">import</span> java.sql.DriverManager;\n<span class="hljs-keyword">import</span> java.sql.SQLException;\n<span class="hljs-keyword">import</span> java.util.ArrayList;\n<span class="hljs-keyword">import</span> java.util.List;\n<span class="hljs-keyword">import</span> java.util.Properties;\n\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnsUtils</span> {</span>\n <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Connection&gt; pool=<span class="hljs-keyword">new</span> ArrayList&lt;Connection&gt;();<span class="hljs-comment">//创建一个pool池对象</span>\n <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM=<span class="hljs-number">3</span>;<span class="hljs-comment">//池中最大数</span>\n <span class="hljs-keyword">static</span>{\n Properties p=<span class="hljs-keyword">new</span> Properties();<span class="hljs-comment">//从配置文件读取</span>\n <span class="hljs-keyword">try</span> {\n<span class="hljs-comment">// p.load(ClassLoader.getSystemClassLoader().getResourceAsStream("jdbc.properities"));</span>\n p.load(ConnsUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">"jdbc.properities"</span>));\n String url = p.getProperty(<span class="hljs-string">"url"</span>);\n String user=p.getProperty(<span class="hljs-string">"user"</span>);\n String password=p.getProperty(<span class="hljs-string">"password"</span>);\n <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;NUM;i++){\n <span class="hljs-keyword">final</span> Connection con=DriverManager.getConnection(url, user, password);<span class="hljs-comment">//final必须设置，因为内部类访问</span>\n <span class="hljs-comment">//使用动态代理,代理conn对象，实现对close方法的拦截</span>\n Object obj=Proxy.newProxyInstance(ConnsUtils.class.getClassLoader(), \n <span class="hljs-keyword">new</span> Class[]{Connection.class},<span class="hljs-keyword">new</span> InvocationHandler() {\n <span class="hljs-comment">//proxy是代理后的对象(等价于返回的obj), method就是类反射中的方法对象, args是执行method方法所需的参数</span>\n <span class="hljs-annotation">@Override</span>\n <span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span>(Object proxy, Method method, Object[] args)\n <span class="hljs-keyword">throws</span> Throwable {\n\n <span class="hljs-keyword">if</span>(method.getName().equalsIgnoreCase(<span class="hljs-string">"close"</span>)&amp;&amp;(args==<span class="hljs-keyword">null</span>||args.length==<span class="hljs-number">0</span>)){\n <span class="hljs-keyword">synchronized</span> (pool) {\n pool.add((Connection) proxy);<span class="hljs-comment">//需要强转</span>\n pool.notify();<span class="hljs-comment">//唤醒等待的资源</span>\n }\n <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n }\n <span class="hljs-keyword">return</span> method.invoke(con, args);<span class="hljs-comment">//其他方法就行放行</span>\n }\n });\n pool.add((Connection)obj);<span class="hljs-comment">//把代理后的conn对象即obj</span>\n }\n } <span class="hljs-keyword">catch</span> (IOException e) {\n e.printStackTrace();\n } <span class="hljs-keyword">catch</span> (SQLException e) {\n e.printStackTrace();\n }\n }\n <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getCon</span>(){\n <span class="hljs-keyword">synchronized</span> (pool) {<span class="hljs-comment">//同步锁，一次只能一个进来拿，避免同时拿</span>\n <span class="hljs-keyword">if</span>(pool.size()&lt;=<span class="hljs-number">0</span>){\n <span class="hljs-keyword">try</span> {\n pool.wait();\n } <span class="hljs-keyword">catch</span> (InterruptedException e) {\n e.printStackTrace();\n }\n }\n <span class="hljs-keyword">return</span> pool.remove(<span class="hljs-number">0</span>);\n }\n\n }\n}\n</code></pre>\n\n<p>我们会发现，就算我们在PoolTest下调用了con.close()函数，我们也没有关闭Connection对象，因为我们在ConnsUtils中通过动态代理把con.close()进行了拦截并更改！</p>\n\n<hr />\n\n<p>有关DPCP和C3P0数据库连接池的使用，请参考<a href="http://blog.csdn.net/wangjian_an/article/details/52198974">开源数据库连接池DBCP和C3P0的使用 </a></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
