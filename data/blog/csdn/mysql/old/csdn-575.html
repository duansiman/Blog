\n\n<h1>1-JDBC概述</h1>&#13;\n<h2>序言：数据持久化</h2>&#13;\n<span style="white-space:pre"></span>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。<br />&#13;\n<span style="white-space:pre"></span>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 <br />&#13;\n<h2>Java 中的数据存储技术</h2>&#13;\n<span style="white-space:pre"></span>在Java中，数据库存取技术可分为如下几类：<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">JDBC直接访问数据库<br />&#13;\nJDO技术<br />&#13;\n第三方O/R工具，如Hibernate, ibatis 等</blockquote>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span>JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。<br />&#13;\n<h2>JDBC基础</h2>&#13;\n<span style="white-space:pre"></span>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库（java.sql,javax.sql）使用这个类库可以以一种标准的方法、方便地访问数据库资源JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。<br />&#13;\n<span style="white-space:pre"></span>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。<br />&#13;\n<h2>JDBC体系结构</h2>&#13;\n<span style="white-space:pre"></span>JDBC接口（API）包括两个层次： <br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 <br />&#13;\n面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。</blockquote>&#13;\n<span style="white-space:pre"></span><span style="color:#ff0000">JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。————面向接口编程</span><br />&#13;\n<h2>JDBC驱动程序分类。</h2>&#13;\n<span style="white-space:pre"></span>JDBC驱动程序：各个数据库厂商根据JDBC的规范制作的 JDBC 实现类的类库  <br />&#13;\n<span style="white-space:pre"></span>JDBC驱动程序总共有四种类型：<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">第一类：JDBC-ODBC桥。 <br />&#13;\n第二类：部分本地API部分Java的驱动程序。 <br />&#13;\n第三类：JDBC网络纯Java驱动程序。 <br />&#13;\n<span style="color:#3366ff">第四类：本地协议的纯 Java 驱动程序。</span> </blockquote>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span>第三、四两类都是纯Java的驱动程序，因此，对于Java开发者来说，它们在性能、可移植性、功能等方面都有优势。<br />&#13;\n<h3>第一类：ODBC<span style="white-space:pre"> </span> </h3>&#13;\n<span style="white-space:pre"></span>早期对数据库的访问，都是调用数据库厂商提供的专有的 API。为了在 Windows 平台下提供统一的访问方式，微软推出了 ODBC(Open Database Connectivity，开放式数据库连接)，并提供了 ODBC API，使用者在程序中只需要调用 ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求一个基于ODBC的应用程序对数据库的操作不依赖任何DBMS(database manager system)，不直接与DBMS打交道，所有的数据库操作由对应的DBMS的ODBC驱动程序完成。也就是说，不论是FoxPro、Access&#13;\n ,MYSQL还是Oracle数据库，均可用ODBC API进行访问。由此可见，ODBC的最大优点是能以统一的方式处理所有的数据库。<br />&#13;\n<strong><em>JDBC-ODBC桥 </em></strong><br />&#13;\n<span style="white-space:pre"></span>JDBC-ODBC 桥本身也是一个驱动，利用这个驱动，可以使用 JDBC-API 通过ODBC 去访问数据库。这种机制实际上是把标准的 JDBC 调用转换成相应的 ODBC 调用，并通过 ODBC 访问数据库因为需要通过多层调用，所以利用 JDBC-ODBC 桥访问数据库的效率较低在 JDK 中，提供了 JDBC-ODBC 桥的实现类(sun.jdbc.odbc.JdbcOdbcDriver)。<br />&#13;\n<h3>第二类：部分本地API部分Java的驱动程序</h3>&#13;\n<span style="white-space:pre"></span>这种类型的 JDBC 驱动程序使用 Java 编写，它调用数据库厂商提供的本地 API通过这种类型的 JDBC 驱动程序访问数据库减少了 ODBC 的调用环节，提高了数据库访问的效率在这种方式下需要在客户的机器上安装本地 JDBC 驱动程序和特定厂商的本地 API 。<br />&#13;\n<h3>第三类：JDBC网络纯Java驱动程序</h3>&#13;\n<span style="white-space:pre"></span>这种驱动利用中间件的应用服务器来访问数据库。应用服务器作为一个到多个数据库的网关，客户端通过它可以连接到不同的数据库服务器。<br />&#13;\n<span style="white-space:pre"></span>应用服务器通常有自己的网络协议，Java 用户程序通过 JDBC 驱动程序将 JDBC 调用发送给应用服务器，应用服务器使用本地程序驱动访问数据库，从而完成请求。<span style="white-space:pre"></span><br />&#13;\n<h3>第四类：本地协议的纯 Java 驱动程序</h3>&#13;\n<span style="white-space:pre"></span>多数数据库厂商已经支持允许客户程序通过网络直接与数据库通信的网络协议。<br />&#13;\n<span style="white-space:pre"></span>这种类型的驱动程序完全使用 Java 编写，通过与数据库建立的 Socket 连接，采用具体与厂商的网络协议把 JDBC 调用转换为直接连接的网络调用JDBC API。<br />&#13;\n<p><span style="white-space:pre"></span>JDBC API 是一系列的接口，它使得应用程序能够进行数据库联接，执行SQL语句，并且得到返回结果。</p>&#13;\n<p></p>&#13;\n<h1>2-获取数据库连接<span style="white-space:pre"> </span></h1>&#13;\n<h2>Driver 接口</h2>&#13;\n<span style="white-space:pre"></span>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">Oracle的驱动：oracle.jdbc.driver.OracleDriver<br />&#13;\nmySql的驱动： com.mysql.jdbc.Driver</blockquote>&#13;\n<span style="white-space:pre"></span>&#13;\n<h2>加载与注册 JDBC 驱动</h2>&#13;\n<span style="white-space:pre"></span>方式一：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">Class.forName(“com.mysql.jdbc.Driver”);</blockquote>&#13;\n<span style="white-space:pre"></span>方式二：DriverManager 类是驱动程序管理器类，负责管理驱动程序<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">DriverManager.registerDriver(com.mysql.jdbc.Driver);</blockquote>&#13;\n<span style="white-space:pre"></span>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。<br />&#13;\n<h2>建立连接(Connection)</h2>&#13;\n<span style="white-space:pre"></span>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接。<br />&#13;\n<span style="white-space:pre"></span>User,password可以用“属性名=属性值”方式告诉数据库；<br />&#13;\n<span style="white-space:pre"></span>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。<br />&#13;\n<span style="white-space:pre"></span>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 <br />&#13;\n<span style="white-space:pre"></span><strong>jdbc:子协议:子名称</strong><br />&#13;\n<span style="white-space:pre"></span>协议：JDBC URL中的协议总是jdbc 。<br />&#13;\n<span style="white-space:pre"></span>子协议：子协议用于标识一个数据库驱动程序。<br />&#13;\n<span style="white-space:pre"></span>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名。<br />&#13;\n<h2>几种常用数据库的JDBC URL</h2>&#13;\n<span style="white-space:pre"></span>jdbc:mysql://localhost:3306/test <br />&#13;\n<span style="white-space:pre"></span>协议 子协议       子名称<span style="white-space:pre"></span><br />&#13;\n<span style="white-space:pre"></span>对于 Oracle 数据库连接，采用如下形式： <br />&#13;\n<span style="white-space:pre"></span>jdbc:oracle:thin:@localhost:1521:atguigu<br />&#13;\n<span style="white-space:pre"></span>对于 SQLServer 数据库连接，采用如下形式：<br />&#13;\n<span style="white-space:pre"></span>jdbc:microsoft:sqlserver//localhost:1433; DatabaseName=sid<br />&#13;\n<span style="white-space:pre"></span>对于 MYSQL 数据库连接，采用如下形式：   <br />&#13;\n<span style="white-space:pre"></span>jdbc:mysql://localhost:3306/atguigu<br />&#13;\n<h2>Statement</h2>&#13;\n<span style="white-space:pre"></span>一旦获取了连接对象Connection, 还不可以执行SQL, 必须要从Connection连接对象获取执行体对象Statement才能执行SQL。<span style="white-space:pre"></span><pre code_snippet_id="1911661" snippet_file_name="blog_20161003_1_4123609" name="code" class="java">Connection connection = getConnection();\nStatement state = connection.createStatement();\nint n = state.executeUpdate(“insert,update,delete…”);</pre><span style="white-space:pre"></span>其中n是执行增删改后对表产生的影响的记录数如果执行一个查询则返回一个ResultSet结果集对象.<span style="white-space:pre"></span><br />&#13;\n<h2>SQL 注入攻击</h2>&#13;\n<span style="white-space:pre"></span>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='a' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来)&#13;\n 就可以了取代 Statement 。<br />&#13;\n<p></p>&#13;\n<p></p>&#13;\n<h1>3-使用PreparedStatement</h1>&#13;\n<span style="white-space:pre"></span><em>数据类型转换表</em>&#13;\n<p></p>&#13;\n<p><strong><img src="http://img.blog.csdn.net/20161003215637379?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br />&#13;\n</strong><span style="white-space:pre"></span><br />&#13;\n<span style="white-space:pre"></span>可以通过调用 Connection 对象的 preparedStatement() 方法获取 PreparedStatement 对象。<br />&#13;\n<span style="white-space:pre"></span>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句。<br />&#13;\n<span style="white-space:pre"></span>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值。<br />&#13;\n<span style="color:#ff0000"><strong>PreparedStatement vs Statement</strong></span><br />&#13;\n<span style="white-space:pre"></span><em><strong>代码的可读性和可维护性.</strong></em><br />&#13;\n<span style="white-space:pre"></span>PreparedStatement 能最大可能提高性能：<br />&#13;\n<span style="white-space:pre"></span>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。<br />&#13;\n<span style="white-space:pre"></span>在statement语句中，即使是相同操作但因为数据内容不一样，所以整个语句本身不能匹配，没有缓存语句的意义。事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执行一次都要对传入的语句编译一次。  (语法检查，语义检查，翻译成二进制命令，缓存)。<br />&#13;\n<span style="white-space:pre"></span>PreparedStatement<span style="color:#ff0000"> 可以防止 SQL 注入 </span><br />&#13;\n</p>&#13;\n<h2>连接数据库、操作表的步骤：</h2>&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote>&#13;\n注册驱动 (只做一次)<br />&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote>&#13;\n建立连接(Connection) <br />&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote>&#13;\n创建执行SQL的语句(PreparedStatement )<br />&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote>&#13;\n执行语句处<br />&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote>&#13;\n理执行结果(ResultSet)<br />&#13;\n<p>释放资源</p>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span>&#13;\n<p></p><pre code_snippet_id="1911661" snippet_file_name="blog_20161012_2_7970480" name="code" class="java">Connection conn = null;\n\t\tPreparedStatement st=null;\n\t\tResultSet rs = null;\n\t\ttry { \n\t\t\t//获得Connection \n\t\t\t//创建PreparedStatement \n\t\t\t//处理查询结果ResultSet\n\t\t}catch(Exception e){\n\t\t \te.printStackTrance();\n\t\t} finally { \n\t\t\t//释放资源ResultSet, \n\t\t\t// PreparedStatement , \n\t\t\t//Connection\n\t\t</pre>&#13;\n<br />&#13;\n<span style="white-space:pre"></span>释放ResultSet, PreparedStatement ,Connection。<br />&#13;\n<span style="white-space:pre"></span>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。<span style="color:rgb(255,0,0)">Connection的使用原则是尽量晚创建，尽量早的释放。</span><br />&#13;\n<p></p>&#13;\n<p></p>&#13;\n<h1>4-使用ResultSet、ResultSetMetaData操作数据表：SELECT</h1>&#13;\n<span style="white-space:pre"></span>ORM:Object Relation Mapping<br />&#13;\n<span style="white-space:pre"></span>表 与 类 对应<br />&#13;\n<span style="white-space:pre"></span>表的一行数据 与 类的一个对象对应<br />&#13;\n<span style="white-space:pre"></span>表的一列 与类的一个属性对应<br />&#13;\n<h2>ResultSet</h2>&#13;\n<span style="white-space:pre"></span>通过调用 PreparedStatement 对象的 excuteQuery() 方法创建该对象。<br />&#13;\n<span style="white-space:pre"></span>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现。<br />&#13;\n<span style="white-space:pre"></span>ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。<br />&#13;\n<span style="white-space:pre"></span>ResultSet 接口的常用方法：<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">boolean next()<br />&#13;\ngetString()<br />&#13;\n…</blockquote>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span>处理执行结果(ResultSet)<br />&#13;\n<span style="white-space:pre"></span>读取（查询）对应SQL的SELECT，返回查询结果<pre code_snippet_id="1911661" snippet_file_name="blog_20161003_3_8660158" name="code" class="java">st = conn.createStatement();\nString sql = "select id, name, age,birth from user";\nrs = st.executeQuery(sql);\nwhile (rs.next()) {\t\t\n\tSystem.out.print(rs.getInt("id") + " \\t ");\t\t\n\tSystem.out.print(rs.getString("name") + " \\t");\t\t\n\tSystem.out.print(rs.getInt("age") + " \\t");\t\t\n\tSystem.out.print(rs.getDate(“birth") + " \\t ");\t\t\n\tSystem.out.println();}\n｝</pre><br />&#13;\n<strong>关于Result的说明</strong><br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="background-color:rgb(204,204,204)">1. 查询需要调用 Statement 的 executeQuery(sql) 方法，查询结果是一个 ResultSet 对象<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">2. 关于 ResultSet：代表结果集<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">ResultSet: 结果集. 封装了使用 JDBC 进行查询的结果. 调用 Statement 对象的 executeQuery(sql) 可以得到结果集.<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">ResultSet 返回的实际上就是一张数据表. 有一个指针指向数据表的第一条记录的前面.<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">3.可以调用 next() 方法检测下一行是否有效. 若有效该方法返回 true, 且指针下移. 相当于Iterator 对象的 hasNext() 和 next() 方法的结合体<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">4.当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值. <br />&#13;\n</span><span style="background-color:rgb(204,204,204)">例如: getInt(1), getString("name")<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">5.ResultSet 当然也需要进行关闭. </span></blockquote>&#13;\n<h2>MySQL BLOB 类型 </h2>&#13;\n<span style="white-space:pre"></span>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。<br />&#13;\n<span style="white-space:pre"></span>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)。<br />&#13;\n<span style="white-space:pre"><img src="http://img.blog.csdn.net/20161003220308026" alt="" /></span><br />&#13;\n<span style="white-space:pre"></span>实际使用中根据需要存入的数据大小定义不同的BLOB类型。<br />&#13;\n<span style="white-space:pre"></span>需要注意的是：如果存储的文件过大，数据库的性能会下降。<br />&#13;\n<h2>ResultSetMetaData 类</h2>&#13;\n<span style="white-space:pre"></span>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象。<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">ResultSetMetaData meta = rs.getMetaData();<br />&#13;\ngetColumnName(int column)：获取指定列的名称<br />&#13;\ngetColumnLabel(int column)：获取指定列的别名<br />&#13;\ngetColumnCount()：返回当前 ResultSet 对象中的列数。 <br />&#13;\ngetColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 <br />&#13;\ngetColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 <br />&#13;\nisNullable(int column)：指示指定列中的值是否可以为 null。  <br />&#13;\nisAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </blockquote>&#13;\n<span style="white-space:pre"></span>&#13;\n<h2>JDBC API 小结</h2>&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">java.sql.DriverManager用来装载驱动程序，获取数据库连接。<br />&#13;\njava.sql.Connection完成对某一指定数据库的连接。<br />&#13;\njava.sql.Statement在一个给定的连接中作为SQL执行声明的容器，他包含了两个重要的子类型。<br />&#13;\nJava.sql.PreparedSatement 用于执行预编译的sql声明。<br />&#13;\nJava.sql.CallableStatement用于执行数据库中存储过程的调用。<br />&#13;\njava.sql.ResultSet对于给定声明取得结果的途径。</blockquote>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span><strong><em>两种思想</em></strong>&#13;\n<p></p>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<p>面向接口编程的思想；</p>&#13;\n<p>ORM思想：sql是需要结合列名和表的属性名来写，注意起别名。</p>&#13;\n</blockquote>&#13;\n<p><span style="white-space:pre"></span><span style="white-space:pre"></span><strong><em>两种技术</em></strong><br />&#13;\n<span style="white-space:pre"></span></p>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<p>JDBC元数据：ResultSetMetaData；</p>&#13;\n<p>PropertyUtils：通过Class.newInstance()创建一个对象，通过此类将查询到的列值装配给创建的对象。</p>&#13;\n</blockquote>&#13;\n<p><span style="white-space:pre"></span></p>&#13;\n<p></p>&#13;\n<h1>5-批量处理</h1>&#13;\n<em><strong>批量处理JDBC语句提高处理速度 。</strong></em><br />&#13;\n<span style="white-space:pre"></span>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率<br />&#13;\n<span style="white-space:pre"></span>JDBC的批量处理语句包括下面两个方法：<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">addBatch(String)：添加需要批量处理的SQL语句或是参数；<br />&#13;\nexecuteBatch()：执行批量处理语句；clearBatch():清空缓存的数据；</blockquote>&#13;\n<span style="white-space:pre"></span><span style="white-space:pre"></span>通常我们会遇到两种批量执行SQL语句的情况：<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">多条SQL语句的批量处理；<br />&#13;\n一个SQL语句的批量传参；</blockquote>&#13;\n<span style="white-space:pre"></span>&#13;\n<p></p>&#13;\n<p></p>&#13;\n<h1>6-数据库连接池</h1>&#13;\n<strong><em>JDBC数据库连接池的必要性 </em></strong><br />&#13;\n<span style="white-space:pre"></span>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　<br />&#13;\n<span style="white-space:pre"></span>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="background-color:rgb(204,204,204)">在主程序（如servlet、beans）中建立数据库连接<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">进行sql操作<br />&#13;\n</span><span style="background-color:rgb(204,204,204)">断开数据库连接</span></blockquote>&#13;\n<span style="white-space:pre"></span><em><strong>这种模式开发，存在的问题:</strong></em><br />&#13;\n<span style="white-space:pre"></span>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 <br />&#13;\n<strong><em>数据库连接池（connection pool） </em></strong><br />&#13;\n<span style="white-space:pre"></span>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。<br />&#13;\n<span style="white-space:pre"></span>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。<br />&#13;\n<span style="white-space:pre"></span>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。<br />&#13;\n<span style="white-space:pre"></span>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。<br />&#13;\n<h2>数据库连接池的工作原理</h2>&#13;\n<div><img src="http://img.blog.csdn.net/20161003220710254" alt="" /><br />&#13;\n</div>&#13;\n<div>&#13;\n<h2>数据库连接池技术的优点</h2>&#13;\n<span style="white-space:pre"></span><em><strong>资源重用</strong></em><br />&#13;\n<span style="white-space:pre"></span>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。<br />&#13;\n<span style="white-space:pre"></span><em><strong>更快的系统反应速度</strong></em><br />&#13;\n<span style="white-space:pre"></span>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。<br />&#13;\n<span style="white-space:pre"></span><em><strong>新的资源分配手段</strong></em><br />&#13;\n<span style="white-space:pre"></span>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。<br />&#13;\n<span style="white-space:pre"></span><em><strong>统一的连接管理，避免数据库连接泄露</strong></em><br />&#13;\n<span style="white-space:pre"></span>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。<br />&#13;\n两种开源的数据库连接池<span style="white-space:pre"> ：</span><br />&#13;\n<span style="white-space:pre"></span>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织<br />&#13;\n提供实现：<br />&#13;\n<span style="white-space:pre"></span></div>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<div><span style="background-color:rgb(204,204,204)">DBCP 数据库连接池</span></div>&#13;\n<div><span style="background-color:rgb(204,204,204)">C3P0 数据库连接池</span></div>&#13;\n</blockquote>&#13;\n<div><span style="white-space:pre"></span>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。<br />&#13;\n<span style="white-space:pre"></span>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。<br />&#13;\n<strong>DBCP 数据源 </strong><br />&#13;\n<span style="white-space:pre"></span>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool. 如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<br />&#13;\n<span style="white-space:pre"></span></div>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<div>Commons-dbcp.jar：连接池的实现</div>&#13;\n<div>Commons-pool.jar：连接池实现的依赖库</div>&#13;\n</blockquote>&#13;\n<div><span style="white-space:pre"></span><span style="white-space:pre"></span>Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。<br />&#13;\n<strong>DBCP 数据源使用范例</strong><br />&#13;\n<span style="white-space:pre"></span>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。<br />&#13;\n<span style="white-space:pre"></span>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。<br />&#13;\n</div>&#13;\n<div>&#13;\n<h1>7-数据库事务</h1>&#13;\n<span style="white-space:pre"></span>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。<br />&#13;\n<span style="white-space:pre"></span>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。<br />&#13;\n<span style="white-space:pre"></span>为确保数据库中数据的一致性,数据的操纵应当是离散的成组的逻辑单元:当它全部完成时,数据的一致性可以保持,而当这个单元中的一部分操作失败,整个事务应全部视为错误,所有从起始点以后的操作应全部回退到开始状态。<br />&#13;\n<br />&#13;\n<span style="white-space:pre"></span><strong><em>事务的ACID(acid)属性  </em>  </strong><br />&#13;\n<span style="white-space:pre"></span>1. 原子性（Atomicity）<br />&#13;\n<span style="white-space:pre"></span>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 <br />&#13;\n<span style="white-space:pre"></span>2. 一致性（Consistency）<br />&#13;\n<span style="white-space:pre"></span>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br />&#13;\n<span style="white-space:pre"></span>3. 隔离性（Isolation）<br />&#13;\n<span style="white-space:pre"></span>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br />&#13;\n<span style="white-space:pre"></span>4. 持久性（Durability）</div>&#13;\n<div>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响<br />&#13;\n<span style="white-space:pre"></span><em><strong>JDBC 事务处理</strong></em><br />&#13;\n<span style="white-space:pre"></span>当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。<br />&#13;\n<span style="white-space:pre"></span>为了让多个 SQL 语句作为一个事务执行：<br />&#13;\n<span style="white-space:pre"></span></div>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<div><span style="background-color:rgb(204,204,204)">调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</span></div>&#13;\n<div><span style="background-color:rgb(204,204,204)">在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</span></div>&#13;\n<div><span style="background-color:rgb(204,204,204)">在出现异常时，调用 rollback(); 方法回滚事务</span></div>&#13;\n<div><span style="background-color:rgb(204,204,204)">若此时 Connection 没有被关闭, 则需要恢复其自动提交状态</span></div>&#13;\n</blockquote>&#13;\n<div><strong><span style="white-space:pre"></span><em>提交后的数据状态</em></strong><br />&#13;\n<span style="white-space:pre"></span></div>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<div>数据的改变已经被保存到数据库中。</div>&#13;\n<div>改变前的数据已经丢失。</div>&#13;\n<div>所有用户可以看到结果。</div>&#13;\n<div>锁被释放， 其他用户可以操作涉及到的数据。</div>&#13;\n</blockquote>&#13;\n<div><span style="white-space:pre"></span>&#13;\n<h1>8-DBUtils工具类</h1>&#13;\n<span style="white-space:pre"></span>将常用的操作数据库的JDBC的类和方法集合在一起，就是DBUtils.<br />&#13;\n<span style="white-space:pre"></span></div>&#13;\n<blockquote style="margin:0 0 0 40px; border:none; padding:0px">&#13;\n<div>BeanHandler:把结果集转为一个 JavaBean</div>&#13;\n<div>BeanBeanListHandler:把结果集转为一个 Bean 的集合</div>&#13;\n<div>MapHandler:把结果集转为一个 Map</div>&#13;\n<div>MapMapListHandler:把结果集转为一个 Map 的 List</div>&#13;\n<div>ScalarHandler:把结果集转为一个类型的数据返回, 该类型通常指 String 或其它 8 种基本数据类型.</div>&#13;\n</blockquote>&#13;\n<div><span style="white-space:pre"></span></div>&#13;\n<p></p>&#13;\n &#13;\n
