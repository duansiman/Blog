\n <div class="markdown_views"><p>注：在执行SQL语句前加上explain可以查看MySQL的执行计划 <br />\n数据库：MySQL官方提供的sakila数据库</p>\n\n<h2 id="max优化">Max优化：</h2>\n\n<p>例如：查询最后支付时间</p>\n\n\n\n<pre class="prettyprint"><code class="language-sql hljs "> explain <span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-aggregate">max</span>(payment_date) <span class="hljs-keyword">from</span> payment \\G;</span></code></pre>\n\n<p><img title="" alt="执行结果" src="http://img.blog.csdn.net/20160806221256474" /></p>\n\n<p>查询的类型为simple，没有用到任何索引，扫描行数为1万多行，用时0.02sec</p>\n\n<p>优化方法：<br /> <br />\n在payment_date列建立索引</p>\n\n<pre class="prettyprint"><code class="language-sql hljs "><span class="hljs-operator"><span class="hljs-keyword">create</span> index idx_paydate <span class="hljs-keyword">on</span> payment(payment_date);</span></code></pre>\n\n<p>然后在执行此sql语句，发现：</p>\n\n<p><img title="" alt="执行结果" src="http://img.blog.csdn.net/20160806221337699" /></p>\n\n<p>此执行结果的原因为：因为索引是顺序排列的，通过索引，就可以马上知道最后一个是什么</p>\n\n<h2 id="count优化">Count优化</h2>\n\n<p>例如：在一条SQL语句中同时查出2006年和2007年的电影数量分别是多少 <br />\n错误方式：</p>\n\n\n\n<pre class="prettyprint"><code class="language-sql hljs "><span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-aggregate">count</span>(release_year = <span class="hljs-string">'2006'</span> <span class="hljs-keyword">OR</span> release_year = <span class="hljs-string">'2007'</span>) <span class="hljs-keyword">from</span> film;</span></code></pre>\n\n<p>无法分开计算2006年和2007年的电影数量</p>\n\n\n\n<pre class="prettyprint"><code class="language-sql hljs "><span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> release_year = <span class="hljs-string">'2006'</span> <span class="hljs-keyword">and</span> release_year = <span class="hljs-string">'2007'</span></span></code></pre>\n\n<p>release_year不能同时为2006和2007，因此逻辑上有误<br /></p>\n\n<p>查询优化如下：</p>\n\n\n\n<pre class="prettyprint"><code class="language-sql hljs "><span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-aggregate">count</span>(release_year=<span class="hljs-string">'2006'</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">null</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">'2006年的电影数量'</span>,<span class="hljs-aggregate">count</span>(release_year=<span class="hljs-string">'2007'</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">null</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">'2007年的电影数量'</span> <span class="hljs-keyword">from</span> film;</span></code></pre>\n\n<p>说明，在sql中，<code>count(*)</code>和<code>count(某列)</code>,执行结果有时候会是不一样的，因为，<code>count(*)</code>包含为null的，而另个如果为null的话，则不计数在内。 <br />\n利用这个特性，将为不是2006年的记为null，执行结果如下图所示 <br />\n<img title="" alt="执行结果" src="http://img.blog.csdn.net/20160806221430778" /></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
