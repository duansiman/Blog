\n <div class="markdown_views"><h2 id="复制管理">复制管理</h2>\n\n\n\n<h3 id="监控">监控</h3>\n\n<p>SHOW MASTER LOGS; <br />\n查看主库当前有哪些二级制日志，其logname是其他命令的入参， file_size是偏移量也是入参。</p>\n\n<p>假设我们知道日志的偏移量(来源于上面的命令)使用： <br />\nSHOW BINLOG EVENTS IN ‘mysql-bin.0000023’ FROM 13634; <br />\n能查看最后执行的sql语句。</p>\n\n\n\n<h3 id="测量备库延迟">测量备库延迟</h3>\n\n<p>SHOW SLAVE STATUS命令，但是会有问题：</p>\n\n<ul>\n<li>使用服务器当前日期，与二进制文件中的时间时间戳进行对别的</li>\n<li>大事件会导致延迟波动 <br />\n更好的解决办法是使用heart record.这是一个主库上会每秒更新一次的时间戳。</li>\n</ul>\n\n\n\n<h3 id="确认主备是否一致">确认主备是否一致</h3>\n\n<p>pt-table-checksum检查主备是否一致的工具</p>\n\n\n\n<h3 id="从主库重新同步备库">从主库重新同步备库</h3>\n\n<p>移除备库，重新同步一个出来 <br />\n使用mysqldump命令。 这个命令需要锁住表之后再操作 <br />\npt-table-sync工具</p>\n\n\n\n<h3 id="改变主库">改变主库</h3>\n\n<p>计划内</p>\n\n<ol>\n<li>停止写入 read only</li>\n<li>停止客户端写入</li>\n<li>等待备库赶上主库</li>\n<li>将备库配置为主库</li>\n<li>给新主库配置备库</li>\n<li>向新主库开放访问权限</li>\n</ol>\n\n<p>计划外 <br />\n这种会面临，主库数据丢失， 不同步。 备库间也不同步</p>\n\n<ol>\n<li>首先要确定使用那台备库，使用最新的。 SHOW SLAVE STATUS 看 Master_Log_File的值</li>\n<li>让备库完成中继日志</li>\n<li>导出主库的bin-log。建立空主库运行</li>\n<li>使用SHOW MASTER STATUS查看日志位移</li>\n<li>备库连接到临时主库继续执行位移的日志</li>\n<li>提升备库为主库</li>\n</ol>\n\n\n\n<h2 id="复制问题">复制问题</h2>\n\n\n\n<h3 id="数据损坏或者丢失">数据损坏或者丢失</h3>\n\n<p><strong>主库意外宕机</strong> <br />\n 如果没有设置sync_binlog，那么有一定的可能崩溃前几个二进制日志没有刷进磁盘。 重启之后备库线程再次连上来。主库会告诉他偏移量不存在。 <br />\n 解决方式是，让备库从下一个二进制日志的开头读，然后用工具查看主备一致性。 或者开启sync_binlog避免丢失，但是会带来性能损失 <br />\n。。。 还有很多，具体的不赘述了</p>\n\n\n\n<h3 id="使用非事务型表">使用非事务型表</h3>\n\n<p>要保证主库重启前，运行了STOP SLAVE否则有可能数据不一致。</p>\n\n\n\n<h3 id="不确定语句">不确定语句</h3>\n\n<p>主要是基于语句的复制，这个开发的时候就要注意。考虑到有可能产生这种现象的原因。</p>\n\n\n\n<h3 id="使用唯一的服务器id">使用唯一的服务器ID</h3>\n\n\n\n<h3 id="innodb加锁读引起的锁争用">InnoDB加锁读引起的锁争用</h3>\n\n<p>INSERT… SELECT操作会引起读锁，会使串行化。 <br />\n可以拆分成小命令 <br />\n使用SELECT INTO OUTFILE,, LOAD DATA INFILE代替INSERT..SELECT.更快，不加锁。</p>\n\n\n\n<h3 id="过大的复制延迟">过大的复制延迟</h3>\n\n<p>注意，应用设计上要允许出现延迟 <br />\n延迟一般都是突然出现的很不好监测</p>\n\n<p>可以用些手段来提升备库的性能：</p>\n\n<ul>\n<li>发现延迟之后如果打开了log_slows_slave_statements可以查看问题</li>\n<li>关闭备库二进制日志</li>\n<li>设置刷新磁盘的点innodb_flush_log_at_trx_commit</li>\n<li>不重复写操作中代价较高的部分 <br />\n 比如一个更新统计表的操作，可以优化为。在主库中新建一个库。统计结构更新这个库。然后用SELECT INTO OUTFILE和LOAD DATA INFILE来写回主库。这样就不会再备库同步执行这个操作 <br />\n 基于同样的思想，还可以把这部分操作放到应用层面来做统计，然后应用层显示调用更新数据库操作。</li>\n<li>在复制之外进行操作 主要是解决了备库是串行的问题 <br />\n常见的有两种，一种是归档型数据库。归档操作进制归档操作记录到二进制文件中，然后在主库和备库上单独执行这些归档查询 <br />\n还可以对一些特殊的表单独处理。 使用应用程序手工的方式来处理这些标的同步。这样可能会带来数据性能的提升。</li>\n</ul>\n\n\n\n<h3 id="主备库-包大小配置不一致">主备库 包大小配置不一致</h3>\n\n<p>如果主备的 max_allowed_packet 不匹配，有可能主库传来过大的包。 可能造成报错或者日志损坏等等。</p>\n\n\n\n<h3 id="带宽不足">带宽不足</h3>\n\n<p>可以通过开启备库的 slave_compressed_protocol选项，来让传输时对数据进行压缩及解压。</p>\n\n\n\n<h2 id="复制速度">复制速度</h2>\n\n<p>测试：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> lag_test(now_usec) <span class="hljs-keyword">VALUES</span> (NOW_USEC())\n//要保证主从库时间同步\n// 注意库必须是<span class="hljs-keyword">varchar</span>列，因为时间列的精确度可能是到秒</span></code></pre>\n\n<p>然后使用TIMESTAMPDIFF方法来查询时间差异 <br />\n可以插入1000比输入，然后根据数量级进行分组，或者求下平均值。看下一般的延迟是多久 <br />\n一般情况下都是在0.几毫秒以内</p>\n\n\n\n<h2 id="一些高级特性">一些高级特性</h2>\n\n<ul>\n<li>5.1引入了行复制</li>\n<li>5.5引入了半同步。 <br />\n在提交食物后，返回给客户端结果前保证二进制日志传输到了至少一台备库上，这样就能更好的保证主从同步。但是会给客户端事务提交的时间延迟一点点。半同步还会有一点点性能改善，因为有半同步，可以更大胆的关闭bin-log。本地写磁盘转化为远程写内存。事实证明远程写内存更快。</li>\n<li>5.5还增加了复制心跳监测</li>\n<li>5.6引入了并行复制，对部分并行处理</li>\n</ul>\n\n\n\n<h2 id="其他复制行为">其他复制行为</h2>\n\n<p>Percona Toolkit和Percona Xtrabackup都提供了基于复制或者帮助复制的功能 <br />\nTungsten Java的开源中间件复制产品。提供了自动数据分片，并发执行，数据复制，款平台复制，多源复制等功能。 他很实用，一些优点： <br />\n - 内建一致性检查 <br />\n - 插件特性 <br />\n - 全局事务ID，不用再去匹配日致命和偏移量了 <br />\n - 能快速的将备库提升为主库 <br />\n - 异构复制 比如Mysql到PostgreSQL <br />\n - 不同版本之间 <br />\n - 并行 <br />\n缺点则是要学习，更复杂，效率稍低。</p>\n\n<p>总结一下：</p>\n\n<ul>\n<li>显著增加了Mysql的功能和可用性</li>\n<li>不提供监控，配置，管理等功能，可以使用其他管局优化，比如：Percona Toolkit和XtraBackup</li>\n<li>复制配置前需要用上面的工具来进行对比，确认是考虑</li>\n<li>监控不会落后于主库</li>\n<li>应用设计要避免主备延迟的脏数据情况</li>\n<li>备库制度并且增加权限，不要多处写。</li>\n</ul></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
