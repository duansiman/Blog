\n <div class="markdown_views"><p>列属性：</p>\n\n<blockquote>\n <p>真正的约束字段的是数据类型，但是数据类型的约束很单一，需要有一些额外的约束，来保证数据的合法性。</p>\n</blockquote>\n\n<p>列属性有很多：NULL / NOT NULL，default，primary key，unique key，auto_increment，comment</p>\n\n\n\n<h2 id="空属性">空属性</h2>\n\n<p>虽然数据库基本都是字段为空，但是开发的时候，尽量保证所有的数据都不应该为空，空数据没有意义，空数据也没有办法参与运算。</p>\n\n<p>创建一个实际案例表：班级表（名字，教室） <br />\n<img src="http://img.blog.csdn.net/20160822224430469" alt="这里写图片描述" title="" /></p>\n\n\n\n<h2 id="列描述">列描述</h2>\n\n<p>列描述：comment，没有实际含义，专门用来描述字段，会根据表创建语句保存。用来给数据管理员来进行了解的。 <br />\n<img src="http://img.blog.csdn.net/20160822224527453" alt="这里写图片描述" title="" /></p>\n\n\n\n<h2 id="默认值">默认值</h2>\n\n<p>默认值：某一种数据会经常性的出现某个具体的值。可以在一开始就制定好，在需要的时候，用户可以选择性的使用。 <br />\n<img src="http://img.blog.csdn.net/20160822224617386" alt="这里写图片描述" title="" /> <br />\n默认值的生效：在数据进行插入的时候，不给数据赋值就是默认值。 </p>\n\n\n\n<h2 id="主键">主键</h2>\n\n<p>主键：primary key，一张表中只能有一个字段可以使用对应的键，用来唯一的约束该字段里面的数据。不能重复。这种称之为主键。</p>\n\n<p>一张表中只能有最多一个主键。</p>\n\n\n\n<h3 id="增加主键">增加主键：</h3>\n\n<p>SQL操作中有多种方式可以给表增加主键，大体分为三种： <br />\n方案1. 在创建表的时候，直接字段之后跟primary key 关键字（主键本身不能为空） <br />\n<img src="http://img.blog.csdn.net/20160822224647907" alt="这里写图片描述" title="" /> <br />\n优点：非常直接 <br />\n缺点：只能使用一个字段作为主键</p>\n\n<p>方案2. 在创建表的时候，在所有的字段之后，使用primary key（主键字段列表）来创建主键 <br />\n如果有多个字段作为主键，可以是复合主键 <br />\n<img src="http://img.blog.csdn.net/20160822224720622" alt="这里写图片描述" title="" /></p>\n\n<p>方案3：当表已经创建好之后，再次追加主键，可以通过修改表字段属性，也可以直接追加 <br />\nAlter table 表名 add primary key(字段列表); <br />\n<img src="http://img.blog.csdn.net/20160822224757623" alt="这里写图片描述" title="" /> <br />\n 前提：表中字段对应的数据本身是独立的（不是重复的）</p>\n\n\n\n<h3 id="主键约束">主键约束</h3>\n\n<p>主键对应的字段中的数据不允许重复。 <br />\n<img src="http://img.blog.csdn.net/20160822224833296" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="更新主键-删除主键">更新主键 &amp; 删除主键</h3>\n\n<p>没有办法更新主键，主键必须先删除，才能增加 <br />\nalter table 表名 drop primary key; <br />\n<img src="http://img.blog.csdn.net/20160822224912172" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="主键分类">主键分类</h3>\n\n<p>在实际创建表的过程中，很少使用真实业务数据作为主键字段（业务主键，如学号，课程号），大部分的时候是使用逻辑性的字段（字段没有业务含义，值是什么都没有关系）</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> my_student(\nid <span class="hljs-keyword">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment comment <span class="hljs-string">'逻辑主键'</span>,\n<span class="hljs-keyword">number</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> comment <span class="hljs-string">'学号'</span>\nname <span class="hljs-keyword">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">'姓名'</span>,\n)charset utf8;</span></code></pre>\n\n\n\n<h2 id="自动增长">自动增长</h2>\n\n<p>自增长：当对应的字段，不给值或者给默认值，或自动被系统触发，系统会从当前字段中已有的最大值再进行 +1操作，得到一个新的在不同的字段。 <br />\n自增长通常是跟主键搭配。</p>\n\n\n\n<h3 id="新增自增长">新增自增长</h3>\n\n<p>自增长的特点： <br />\n1. 任何一个字段要做自增长，必须前提是本身是一个索引（key 一栏有值） <br />\n<img src="http://img.blog.csdn.net/20160822225001940" alt="这里写图片描述" title="" /> <br />\n2. 自增长字段必须是数字（整型） <br />\n<img src="http://img.blog.csdn.net/20160822225025080" alt="这里写图片描述" title="" /> <br />\n3. 一张表最多只能有一个自增长 <br />\n<img src="http://img.blog.csdn.net/20160822225047096" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="自增长的使用">自增长的使用</h3>\n\n<p>当自动增长被给定的值为NULL，或者默认值，会触发自增长 <br />\n<img src="http://img.blog.csdn.net/20160822225139973" alt="这里写图片描述" title="" /> <br />\n自增长如果对应的字段输入了值，那么自增长失效，但是下一次还是能正确的自增长（最大值+1） <br />\n<img src="http://img.blog.csdn.net/20160822225205565" alt="这里写图片描述" title="" /> <br />\n如何确定下一次是什么自增长呢？可以通过查看表创建语句。 <br />\n<img src="http://img.blog.csdn.net/20160822225231865" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="修改自增长">修改自增长</h3>\n\n<p>自增长如果涉及到字段改变，必须先删除自增长，后增加。</p>\n\n<p>修改当前自增长已经存在的值。（只能比当前已有的自增长的最大值大） <br />\nalter table 表名 auto_increment = 值; <br />\n<img src="http://img.blog.csdn.net/20160822225301738" alt="这里写图片描述" title="" /></p>\n\n<p>思考：为什么自增长是从1开始？为什么每次都是自增1呢？ <br />\n所有系统的表现 （字符集、校对集…）都是由系统内部的变量进行控制的 <br />\n<img src="http://img.blog.csdn.net/20160822225327085" alt="这里写图片描述" title="" /> <br />\n 可以修改变量实现不同的效果：修改是对整个数据库修改，而不是单张表，（修改是会话级别） <br />\nset auto_increment_increment = 5; – 一次自增5 <br />\n<img src="http://img.blog.csdn.net/20160822225348226" alt="这里写图片描述" title="" /> <br />\n<img src="http://img.blog.csdn.net/20160822225408992" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="删除自增长">删除自增长</h3>\n\n<p>自增长是字段的一个属性，可以通过modify来进行修改（保证字段没有auto_increment即可） <br />\nalter table 表名 modify 字段 类型; <br />\n<img src="http://img.blog.csdn.net/20160822225434489" alt="这里写图片描述" title="" /> <br />\n<img src="http://img.blog.csdn.net/20160822225503728" alt="这里写图片描述" title="" /></p>\n\n\n\n<h2 id="唯一键">唯一键</h2>\n\n<p>一张表汪汪有很多字段需要具有唯一性。唯一键（unique key）就可以解决该问题</p>\n\n<p>唯一键的本质与主键差不多，唯一键默认的允许自动为空，而且可以多个为空。</p>\n\n\n\n<h3 id="增加唯一键">增加唯一键</h3>\n\n<p>与主键差不多，三种方案 <br />\n方案1：在创建表的时候，字段之后直接跟unique 或unique key。 <br />\n<img src="http://img.blog.csdn.net/20160822225540526" alt="这里写图片描述" title="" /></p>\n\n<p>方案2：在所有的字段之后增加unique。– 复合唯一键 <br />\n<img src="http://img.blog.csdn.net/20160822225606308" alt="这里写图片描述" title="" /></p>\n\n<p>方案3：在创建表之后，增加唯一键 <br />\n<img src="http://img.blog.csdn.net/20160822225624996" alt="这里写图片描述" title="" /></p>\n\n\n\n<h3 id="唯一键约束">唯一键约束</h3>\n\n<p><img src="http://img.blog.csdn.net/20160822225648834" alt="这里写图片描述" title="" /> <br />\n 如果唯一键也不允许为空，与主键的约束作用是一样的</p>\n\n\n\n<h3 id="更新唯一键-删除唯一键">更新唯一键 &amp; 删除唯一键</h3>\n\n<p>更新唯一键：先删除后新增（可以不删除，唯一键可以有多个）</p>\n\n<p>删除唯一键 <br />\nalter table 表名 drop unique key; – 错误 <br />\nalter table 表名 drop index 索引名字; – 唯一键默认使用字段名作为索引 <br />\n<img src="http://img.blog.csdn.net/20160822225731435" alt="这里写图片描述" title="" /></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
