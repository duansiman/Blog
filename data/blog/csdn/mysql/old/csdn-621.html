\n <div class="markdown_views"><p>对mysql的锁这块真的不是特别了解，学习完这一部分，有种豁然开朗的感觉。当然还是有待进一步提高。更加深入的学习。</p>\n\n<h3 id="锁问题">锁问题　</h3>\n\n<p>mysql锁的分类</p>\n\n<pre><code> 1 表锁，开销小，加锁快，不会出现死锁，锁定粒度大\n 2 行锁，开销大，加锁慢，会出现死锁，锁粒度小\n 3 页面锁，介于两者之间，会出现死锁\n\nmyisam 表锁，适合读多的程序\ninnodb 行锁，适合写多和并发高的程序\n</code></pre>\n\n<p>查看表锁的状况</p>\n\n<pre><code>show status like 'table%';\n</code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs 1c"><span class="hljs-string">| Table_locks_immediate | 504 |</span>\n<span class="hljs-string">| Table_locks_waited | 0 锁等待状态 |</span>\n<span class="hljs-string">| Table_open_cache_hits | 0 |</span>\n<span class="hljs-string">| Table_open_cache_misses | 0 |</span>\n<span class="hljs-string">| Table_open_cache_overflows | 0 </span></code></pre>\n\n<p>表锁又分为：表共享读锁，表独占写锁。</p>\n\n<p>加表锁语法：lock table xxx read；lock table xxx write；</p>\n\n<p>解除表锁：unlock tables;</p>\n\n<p>并发插入</p>\n\n<pre><code>myisam的表读写都是串行的。其实也支持并发插入\n通过concurent_insert 0 不允许 1 有空洞允许在表尾插入 2 允许表尾插入\n</code></pre>\n\n<p>myisam锁调度</p>\n\n<pre><code>读锁写锁是互斥的，读写操作是串行的。myisam的锁是写先行。\n当然也可以调整myisam的锁的行为\n</code></pre>\n\n<p>innodb和myisam的最大的不同</p>\n\n<pre><code>1 innodb支持事务\n2 采用了行锁\n</code></pre>\n\n<p>事务和acid属性</p>\n\n<pre><code>原子性。要么全部执行，要么全部不执行。\n一致性。事务开始和完成时数据保持一致性。\n隔离性。事务不受外部并发操作影响。\n持久性。当事务完成后，数据的修改是永久性的\n</code></pre>\n\n<p>并发事务带来的问题</p>\n\n<pre><code>更新丢失。多事务操作同一条记录。可以采用锁定。\n脏读。\n不可重复读。\n幻读。\n</code></pre>\n\n<p>事务隔离级别</p>\n\n<pre><code>实现方式\n 1 加锁\n 2 快照实现多版本控制\n\n未提交读\n已提交读\n可重复读\n可序列化\n</code></pre>\n\n<p>查看innodb事务状态</p>\n\n<pre><code>show status like '%innodb%';\n</code></pre>\n\n<p>innodb的行锁模式以及加锁方式</p>\n\n<pre><code>行锁\n 共享锁S，允许一个事务去读一行，阻止其他事务获取相同数据集的排它S锁\n 排他锁X，允许获得排它锁的事务更新数据，阻止其他事务获取相同的共享锁和排它锁\n表锁\n 意向共享锁IS\n 意向排它锁IX\n</code></pre>\n\n<p>innodb锁的特别注意的</p>\n\n<pre><code>1 在不通过索引条件查询的时候，innodb确实用的是表锁，不是行锁。\n2 mysql的行锁是针对索引加的锁，而不是针对记录，使用相同的索引键可能出现冲突。\n3 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引，唯一索引，普通索引，innodb都是采用行锁来对数据加锁\n4 即使创建了索引，能偶否使用索引还是由mysql判断，如果代价高，innodb可能采用表锁。\n</code></pre>\n\n<p>间隙锁-范围加锁</p>\n\n<p>恢复机制对innodb锁的影响</p>\n\n<pre><code>myslql是通过binlog记录执行增删改查操作的。\n 1 mysql恢复的是sql语句的集合\n 2 通过binglog先后顺序恢复\n</code></pre>\n\n<p>innodb什么时候使用表锁</p>\n\n<pre><code>1 事务需要更新大部分或者全部数据，表又打的时候\n2 实际多表，业务复杂，容易造成死锁，造成大量事务回滚的情况。\n</code></pre>\n\n<p>在使用mysql中如何尽量减少死锁的概率</p>\n\n<pre><code>尽量使用较低级别的隔离级别\n精心设计索引，并尽量使用索引反问数据，使加锁更加精确\n合理选择事务大小\n申请合适的事务级别\n如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表。\n批量处理数据时，先对数据排序，保证每个线程以固定的顺序来访问记录\n更新记录直接使用排它锁\n更新同一条记录可以采用READ COMMITED级别\n</code></pre></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
