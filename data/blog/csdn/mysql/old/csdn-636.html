\n <div class="markdown_views"><p><strong>通过Explain分析低效率sql的执行计划</strong> <br />\n用explain解释sql会有如下几列 <br />\n<img src="http://img.blog.csdn.net/20150918111224909" alt="这里写图片描述" title="" /> <br />\n<strong>select_type</strong> <br />\nselect类型 <br />\n1、SIMPLE:简单的select语句，不包括union操作或子查询，例如： <br />\n<img src="http://img.blog.csdn.net/20150918111253274" alt="这里写图片描述" title="" /> <br />\n2、PRIMARY/UNION <br />\nPRIMARY:查询中最外层的select，如两表做union或者存在子查询的外层表的操作为PRIMARY,内层的操作为UNION，例如： <br />\n<img src="http://img.blog.csdn.net/20150918111322218" alt="这里写图片描述" title="" /> <br />\nUNION:union操作中，查询中处于内层的select，内层的select语句与外层的select语句没有依赖关系 <br />\n3、DEPENDENT UNION/UNION RESULT <br />\nDEPENDENT UNION:union操作中，查询中处于内层的select，内层的select语句与外层的select语句没有依赖关系 <br />\nUNION RESULT：UNION操作的结果，id通常为null <br />\n<img src="http://img.blog.csdn.net/20150918111345740" alt="这里写图片描述" title="" /> <br />\n4、SUBQUERY/DEPENDENT SUBQUERY <br />\nSUBQUERY：子查询中首个select（如果有多个子查询存在） <br />\n<img src="http://img.blog.csdn.net/20150918111409972" alt="这里写图片描述" title="" /> <br />\nDEPENDENT SUBQUERY：子查询中首个select，但依赖于外层的表 <br />\n<img src="http://img.blog.csdn.net/20150918111434183" alt="这里写图片描述" title="" /> <br />\n5、DERIVED/MATERIALIZED <br />\nDERIVED:被驱动的select子查询（子查询位于from子句中） <br />\n<img src="http://img.blog.csdn.net/20150918111454103" alt="这里写图片描述" title="" /> <br />\nMATERIALIZED：被物化的子查询 <br />\n<strong>table</strong> <br />\n输出结果集的表 <br />\n<strong>type</strong> <br />\n表示表的连接类型 <br />\n（1）SYSTEM <br />\nCONST的特例，当表上只有一条元组匹配，当表中只有一行，type为system是最佳连接类型 <br />\n（2）CONST <br />\nWHERE条件筛选后表上至多有一条元组匹配时，比如WHERE ID = 2 （ID是主键，值为2的要么有一条要么没有） <br />\n（3）EQ_REF <br />\n参与连接运算的表是内表（在代码实现的算法中，两表连接时作为循环中的内循环遍历的对象，这样的表称为内表）。 <br />\n基于索引（连接字段上存在唯一索引或者主键索引，且操作符必须是“=”谓词，索引值不能为NULL）做扫描，使得对外表的一条元组，内表只有唯一一条元组与之对应。 <br />\n（4）REF <br />\n可以用于单表扫描或者连接。参与连接运算的表，是内表。 <br />\n基于索引（连接字段上的索引是非唯一索引，操作符必须是“=”谓词，连接字段值不可为NULL）做扫描，使得对外表的一条元组，内表可有若干条元组与之对应。 <br />\n（5）REF_OR_NULL <br />\n类似REF，只是搜索条件包括：连接字段的值可以为NULL的情况，比如 where col = 2 or col is null <br />\n（6）RANGE <br />\n范围扫描，基于索引做范围扫描，为诸如BETWEEN，IN，&gt;=，LIKE类操作提供支持 <br />\n（7）INDEX_SCAN <br />\n索引做扫描，是基于索引在索引的叶子节点上找满足条件的数据（不需要访问数据文件） <br />\n（8）ALL <br />\n全表扫描或者范围扫描：不使用索引，顺序扫描，直接读取表上的数据（访问数据文件） <br />\n（9）UNIQUE_SUBQUERY <br />\n在子查询中，基于唯一索引进行扫描，类似于EQ_REF <br />\n（10）INDEX_SUBQUERY <br />\n在子查询中，基于除唯一索引之外的索引进行扫描 <br />\n（11）INDEX_MERGE <br />\n多重范围扫描。两表连接的每个表的连接字段上均有索引存在且索引有序，结果合并在一起。适用于作集合的并、交操作。 <br />\n（12）FT <br />\nFULL TEXT，全文检索 <br />\n<strong>possible_keys</strong> <br />\n表示查询时，可以使用的索引列 <br />\n<strong>key</strong> <br />\n表示使用的索引 <br />\n<strong>key_len</strong> <br />\n索引长度 <br />\n<strong>rows</strong> <br />\n扫描范围 <br />\n<strong>Extra</strong> <br />\n执行情况的说明和描述</p>\n\n<p>通过以上我们基本可以确定sql的问题，接下来就是采取相应的优化措施</p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
