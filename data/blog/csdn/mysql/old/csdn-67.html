\n\n<p style="">使用PDO访问MySQL数据库时，真正的real prepared statements 默认情况下是不使用的。为了解决这个问题，你必须禁用 prepared statements的仿真效果。下面是使用PDO创建链接的例子：<br style="background-color:inherit" />&#13;\n</p>&#13;\n<div style="">代码如下:</div>&#13;\n<pre name="code" class="php">$dbh = new PDO('mysql:dbname=dbtest;host=127.0.0.1;charset=utf8', 'user', 'pass');\n$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</pre><br />&#13;\n<span style="">setAttribute（） 这一行是强制性的，它会告诉 PDO 禁用模拟预处理语句，并使用 real parepared statements 。这可以确保SQL语句和相应的值在传递到mysql服务器之前是不会被PHP解析的（禁止了所有可能的恶意SQL注入攻击）。虽然你可以配置文件中设置 字符集的属性(charset=utf8)，但是需要格外注意的是，老版本的 PHP（ &lt; 5.3.6）在DSN中是忽略字符参数的。</span>&#13;\n<p style="">我们来看一段完整的代码使用实例：<br style="background-color:inherit" />&#13;\n</p>&#13;\n<div style="">代码如下:</div>&#13;\n<pre name="code" class="php">$dbh = new PDO("mysql:host=localhost; dbname=dbtest", "user", "pass");\n$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //禁用prepared statements的仿真效果\n$dbh-&gt;exec("set names 'utf8'");\n$sql="select csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh from test where name = ? and password = ?";\n$stmt = $dbh-&gt;prepare($sql);\n$exeres = $stmt-&gt;execute(array($testname, $pass));\nif ($exeres) {\n while ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) {\n print_r($row);\n }\n}\n$dbh = null;</pre><br />&#13;\n<strong style=""><span style="font-size:14px; color:#ff0000; background-color:inherit">上面这段代码就可以防范sql注入。为什么呢？</span></strong>&#13;\n<p style=""><strong style="background-color:inherit"><span style="font-size:14px; color:#ff0000; background-color:inherit">当调用 prepare() 时，查询语句已经发送给了数据库服务器，此时只有占位符 ? 发送过去，没有用户提交的数据；当调用到 execute()时，用户提交过来的值才会传送给数据库，他们是分开传送的，两者独立的，SQL攻击者没有一点机会。</span></strong></p>&#13;\n<p style="">但是我们需要注意的是以下几种情况，PDO并不能帮助你防范SQL注入</p>&#13;\n<p style="">1、你不能让占位符 ? 代替一组值，如：<br style="background-color:inherit" />&#13;\n</p>&#13;\n<div style="">代码如下:</div>&#13;\n<br />&#13;\n<pre name="code" class="php">SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh FROM blog WHERE userid IN ( ? );</pre>&#13;\n<p><br />&#13;\n</p>&#13;\n<p><span style="">2、你不能让占位符代替数据表名或列名，如：</span><br style="" />&#13;\n</p>&#13;\n<div style="">代码如下:</div>&#13;\n<pre name="code" class="php">SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh FROM blog ORDER BY ?;</pre><br />&#13;\n<span style="">3、你不能让占位符 ? 代替任何其他SQL语法，如：</span><br style="" />&#13;\n<div style="">代码如下:</div>&#13;\n<br />&#13;\n<pre name="code" class="php">SELECT EXTRACT( ? FROM datetime_column) AS variable_datetime_element FROM blog;</pre><br />&#13;\n<br />&#13;\n<p></p>&#13;\n<p><br />&#13;\n</p>&#13;\n &#13;\n
