\n <div class="markdown_views"><h1 id="什么是索引">什么是索引？</h1>\n\n<p>索引(index)翻译为一个目录，用于快速定位我们想要找的数据的位置。例如：我们把一个数据库比作一本书，而索引(index)就是书中的目录，此刻要找到书的某个感兴趣的内容，我们一般是不会整本书翻完再去确认该内容在哪里，而是通过书的目录，定位到该内容章节所在页数，最后直接翻到该页面。</p>\n\n<p>我们来看看在数据库中的索引：</p>\n\n<p>全表扫描 VS 索引扫描</p>\n\n<p>以字典为例，全表扫描就是如果我们查找某个字时，那么通读一遍新华字典，然后找到我们想要找到的字，而跟全表扫描相对应的就是索引查找，索引查找就是在表的索引部分找到我们想要找的数据具体位置，然后会到表里面将我们想要找的数据全部查出。</p>\n\n<p>实例：在一张学生表找到一个名字叫Dev的学生</p>\n\n<p><img src="http://img.blog.csdn.net/20161111123012832" alt="实例" title="" /></p>\n\n<p>左边全表扫描：需要从第一行开始一行行的扫描，直到找到100008行Dev这个学生的信息为止，将这个数据返回回来，但有可能该表中还有同名的学生，因此扫描并没有结束，通常全表扫描要找到一个数据，是需要将整张表的数据遍历一遍，然后才能确定是否将所有数据返回。</p>\n\n<p>右边索引扫描：索引查找是根据首字母排序找到D开头的Dev,如果首字母相同，那么再根据第二个字母排序找到，以此类推，我们找到ID为100008，然后回表查出ID为100008的数据。</p>\n\n<p>结论：因此索引(对应InnoDB)的索引值对应的是主键ID。</p>\n\n<h1 id="如何找到索引对应的值">如何找到索引对应的值</h1>\n\n<p>InnoDB引擎主要根据 <br />\n(1)B+tree <br />\n(2)二分查找法</p>\n\n<p><img src="http://img.blog.csdn.net/20161111123113066" alt="图解" title="" /></p>\n\n<p>B+tree: B+树拥有整棵树的根节点、支节点和页节点，上层会存储下层节点的管理范围，直到页节点的具体信息</p>\n\n<p>二分查找法：根据B+树存储的各个节点的范围，进行比较，逐步缩小范围，最后定位到页节点中我们想要的位置</p>\n\n<h1 id="innodb表也是一张索引表">InnoDB表也是一张索引表</h1>\n\n<p><img src="http://img.blog.csdn.net/20161111123150682" alt="图解" title="" /></p>\n\n<p>如上图InnoDB表是聚簇表，意思是InnoDB本身是一张大的索引组织表，也是一个根据主键排序的大索引的B+树结构，我们在InnoDB里面另外建立自己想要索引的表的字段</p>\n\n<p>聚簇索引就意味着InnoDB表本身，而我们把这些根据其他字段排序的索引称为二级索引(secondery class)</p>\n\n<h1 id="在数据库中如何建立索引">在数据库中如何建立索引</h1>\n\n<p>在MySQL中主要建立两种类型的索引</p>\n\n<p>1.单列索引</p>\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">create</span> index idx_name <span class="hljs-keyword">on</span> tb_student(name);</span>\n 索引名 表名 字段名</code></pre>\n\n<p>2.联合索引</p>\n\n<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-built_in">create</span> index idx_name_age <span class="hljs-command"><span class="hljs-keyword">on</span> <span class="hljs-title">tb_student</span>(<span class="hljs-title">name</span>,<span class="hljs-title">age</span>);</span>\n<span class="hljs-comment">#索引中先根据name排序，name相同的情况下根据age排序</span></code></pre>\n\n<h1 id="索引维护">索引维护</h1>\n\n<p>首先介绍下什么是索引维护？这是一个关乎性能的重要概念</p>\n\n<p>如果索引所在字段发生了修改、删除、插入等操作，那么索引项就会发生变化，因此如果不能保证索引的有序，那么就不能索引的准确与效率，而索引的排序发生了变化的这个行为，我们称为索引维护</p>\n\n<p>在insert/delete/update操作时，为了维护索引的排序，数据库会自动的完成索引项的维护，索引的排序，这些行为对用户是透明的，感觉不到的</p>\n\n<p>在一个有索引的表中，创建它时，实际上还同时创建了索引排序的表，因此在DML中，插入等操作不再是普通的插入，MySQL将它封装成了一个事务，连着索引项的排序表一起操作</p>\n\n<p>因此，我们应当严格控制表上的索引数量，否则容易影响数据库的性能</p>\n\n<p>总结索引维护如下：</p>\n\n<ol>\n<li>索引维护由数据库自动完成</li>\n<li>插入/修改/删除每一个索引行都变成一个内部封装的事务</li>\n<li>索引越多，事务越大，代价越高</li>\n<li>索引越多，对表的插入和索引字段的修改就越慢</li>\n</ol>\n\n<p>因此可以看出索引并非是越多越好，在工作中也要慎用，尤其对于写操作较为频繁的业务</p>\n\n<h1 id="如何正确的使用索引">如何正确的使用索引？</h1>\n\n<p>1、依据where查询条件建立索引</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs vbnet">eg:\n<span class="hljs-keyword">select</span> a,b <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">where</span> c = ?;\nidx_c(c) -&gt;正确\n\n<span class="hljs-keyword">select</span> a,b <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">where</span> c = ? <span class="hljs-keyword">and</span> b = ?\nidx_cd(c,d) -&gt;正确</code></pre>\n\n<p>2、根据排序order by ,group by , distinct 字段添加索引</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs vbnet">eg:\n<span class="hljs-keyword">select</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a;\n<span class="hljs-keyword">select</span> a,count(*) <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a;\nidx_a(a) -&gt;正确\n\n<span class="hljs-keyword">select</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a,b;\nidx_a_b(a,b) -&gt;正确\n\n<span class="hljs-keyword">select</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">from</span> tb_test <span class="hljs-keyword">order</span> <span class="hljs-keyword">where</span> c = ? <span class="hljs-keyword">by</span> a;\nidx_c_a(c,a) -&gt;正确</code></pre>\n\n<h1 id="到底哪些字段适合创建索引">到底哪些字段适合创建索引？</h1>\n\n<p>1、字段值的重复程度，如图：</p>\n\n<p><img src="http://img.blog.csdn.net/20161111123443139" alt="图解" title="" /></p>\n\n<p>身份证号码由于基本上不可能重复，因此选择性非常好，而人的名字重复性较低，选择性也不错， 性别选择性较差，重复度非常高</p>\n\n<p>2、选择性很差的字段通常不适合创建索引，但也有例外</p>\n\n<p>如：男女比例相仿的表中，性别不适合创建单列索引，如果走索引不如走全表扫描，因为走索引的I/O开销更大</p>\n\n<p>但如果男女比例极度不平衡，要查询的又是少数方,如：理工学校、IT公司等可以考虑使用索引。</p>\n\n<p>3、联合索引中选择性好的字段应该排在前面</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs applescript">select csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">from</span> tab_a <span class="hljs-keyword">where</span> gender=? <span class="hljs-keyword">and</span> <span class="hljs-property">name</span>=?\nidx_name_gender(<span class="hljs-property">name</span>,gender) -&gt;正确</code></pre>\n\n<p>4、联合索引可以为单列、复列查询提供帮助</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso">idx_smp(a,b,c)\n<span class="hljs-keyword">where</span> a<span class="hljs-subst">=?</span>; <span class="hljs-subst">-&gt;</span>正确\n<span class="hljs-keyword">where</span> a<span class="hljs-subst">=?</span> <span class="hljs-literal">and</span> b<span class="hljs-subst">=?</span>; <span class="hljs-subst">-&gt;</span>正确\n<span class="hljs-keyword">where</span> a<span class="hljs-subst">=?</span> <span class="hljs-literal">and</span> c<span class="hljs-subst">=?</span>; <span class="hljs-subst">-&gt;</span>正确 （注：需要MySQL5<span class="hljs-number">.6</span>版本以上；在<span class="hljs-number">5.5</span>及以前版本，可以对a字段进行索引扫描，但c字段不行 ）\n<span class="hljs-keyword">where</span> a<span class="hljs-subst">=?</span> <span class="hljs-literal">and</span> b<span class="hljs-subst">=?</span> <span class="hljs-literal">and</span> c<span class="hljs-subst">=?</span> <span class="hljs-subst">-&gt;</span>正确</code></pre>\n\n<p>5、合理创建联合索引，避免冗余</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-function"><span class="hljs-params">(a)</span>,<span class="hljs-params">(a,b)</span>,<span class="hljs-params">(a,b,c)</span> -&gt;</span>不可取\n<span class="hljs-function"><span class="hljs-params">(a,b,c)</span> -&gt;</span>正确，可以覆盖前两个</code></pre>\n\n\n\n<h1 id="再来看看如何在长字段上建立索引呢">再来看看如何在长字段上建立索引呢</h1>\n\n<p>首先，在较长的字段上建立索引是非常影响性能的，比如文章等超大varchar或者text字段，如果不是非建不可，一般不推荐，另外对InnoDB索引单字段（utf8）只能取前767bytes</p>\n\n<p>那么如何处理长字段索引？</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs scss">主要根据类型来分别处理：\n1、Email类，可以建立前缀索引\nmail_addr <span class="hljs-function">varchar(<span class="hljs-number">2048</span>)</span>\n<span class="hljs-function">idx_mailadd(<span class="hljs-function">mail_addr(<span class="hljs-number">39</span>)</span>)</span> -&gt; 正确\n解析：由于email邮件类型字段，一般后缀都有较大可能相同，如<span class="hljs-class">.com</span> <span class="hljs-class">.cn</span>等等，而前缀相同的可能性较低，且邮箱一般长度较短，因此可以建立前缀索引\n\n2、住址类，分拆字段\nhome_addr <span class="hljs-function">varchar(<span class="hljs-number">2048</span>)</span>\n<span class="hljs-function">idx_homeadd(<span class="hljs-function">home_addr(<span class="hljs-number">30</span>)</span>)</span> -&gt;错误，很可能前半段是相同的省市区街道名\n\nprovince_add <span class="hljs-function">varchar(<span class="hljs-number">1024</span>)</span>,city_add <span class="hljs-function">varchar(<span class="hljs-number">1024</span>)</span>, district_add `<span class="hljs-function">varchar(<span class="hljs-number">1024</span>)</span>,lolcal_add <span class="hljs-function">varchar(<span class="hljs-number">1024</span>)</span> --建立联合索引或者单列索引 -&gt;正确`</code></pre>\n\n\n\n<h1 id="对核心sql索引做覆盖扫描">对核心SQL索引做覆盖扫描</h1>\n\n<p>对于最核心的SQL，我们可以考虑使用索引覆盖，什么是索引覆盖呢，下面是个例子</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> userid=?\n<span class="hljs-keyword">key</span> idx_uid_name(userid,name) -&gt;覆盖索引扫描</span></code></pre>\n\n<p>我们查询用户名这种操作频率非常高，而索引里面又存储了字段的值，因此在我们做查询时，name字段的值直接在索引中返回，而不需要回表;还有一个使用非常广泛的例子：用户登陆，我们可以将username password做覆盖索引，这样大大提高登陆验证的速度</p>\n\n<p>因此覆盖索引覆盖就是将你要查询的字段和条件字段一起建立联合索引，这样的好处是不需要回表获取name字段，IO最小，速度块</p>\n\n\n\n<h1 id="哪些情况无法使用索引">哪些情况无法使用索引？</h1>\n\n<p>1、索引列进行数据运算或者函数运算</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso">eg:\n <span class="hljs-keyword">where</span> id<span class="hljs-subst">+</span><span class="hljs-number">1</span><span class="hljs-subst">=</span><span class="hljs-number">10</span>; <span class="hljs-subst">-&gt;</span>错误，无法利用到索引\n <span class="hljs-keyword">where</span> id<span class="hljs-subst">=</span>(<span class="hljs-number">10</span><span class="hljs-subst">-</span><span class="hljs-number">1</span>) <span class="hljs-subst">-&gt;</span>正确\n\n <span class="hljs-keyword">where</span> year(id) <span class="hljs-subst">&lt;</span> <span class="hljs-number">2016</span> <span class="hljs-subst">-&gt;</span>错误，无法利用到索引\n <span class="hljs-keyword">where</span> col <span class="hljs-subst">&lt;</span> <span class="hljs-string">'2016-01-01'</span> <span class="hljs-subst">-&gt;</span>正确</code></pre>\n\n<p>2、未含复合索引的前缀字段</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso">idx_abc(a,b,c)\n<span class="hljs-keyword">where</span> b<span class="hljs-subst">=?</span> <span class="hljs-literal">and</span> c<span class="hljs-subst">=?</span> <span class="hljs-subst">-&gt;</span>错误，无法利用到索引\n正确的建立索引方式(b,c)</code></pre>\n\n<p>3、前缀通配符”_” “%”等</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs vbnet"><span class="hljs-keyword">like</span> <span class="hljs-comment">'%ttt%' -&gt;错误，无法利用到索引</span>\n<span class="hljs-keyword">like</span> <span class="hljs-string">"ttt%"</span> -&gt;正确</code></pre>\n\n<p>4、where条件使用NOT,&lt;&gt;,!= 通常也无法使用到索引</p>\n\n<p>5、字段类型不匹配</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs livecodeserver">字段类型并不绝对匹配时，可能会导致无法使用索引\n<span class="hljs-operator">a</span> int(<span class="hljs-number">11</span>) ,idx_a(<span class="hljs-operator">a</span>)\nwhere <span class="hljs-operator">a</span> = <span class="hljs-string">'123'</span> -&gt;错误，可能导致未知的错误,这个跟编码有关系\nwhere <span class="hljs-operator">a</span> = <span class="hljs-number">123</span> -&gt;正确</code></pre>\n\n\n\n<h1 id="利用索引做排序操作">利用索引做排序操作</h1>\n\n<p>以 idx_ab(a,b)索引为例 <br />\n1、能使用上述索引进行排序的操作是：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a;\na = <span class="hljs-number">3</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b;\n<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a,b;\n<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a <span class="hljs-keyword">desc</span> ,b <span class="hljs-keyword">desc</span>;\na &gt; <span class="hljs-number">5</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a;</code></pre>\n\n<p>2、不能使用索引帮助排序的查询</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b; #没有使用到联合索引的第一个字段\n\na &gt; <span class="hljs-number">5</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b; #一旦前缀操作是一个range而非＝操作，那么就无法利用到索引，\n这里 a&gt;<span class="hljs-number">5</span>无法利用索引，二联合索引的第一个字段未利用，\n因此 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b也无法利用索引查询\n\na <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b; #<span class="hljs-keyword">in</span>里面的值没有建立索引，因此无法利用索引，a未用因此<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b也无法使用\n\n<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a <span class="hljs-keyword">asc</span>, b <span class="hljs-keyword">desc</span>; #这里<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a esc是利用了索引，但是b <span class="hljs-keyword">desc</span>未利用到，因为b要和a排序方式一致才可利用到索引</code></pre>\n\n\n\n<h1 id="如何确定一个查询有没有走索引走了哪些索引">如何确定一个查询有没有走索引，走了哪些索引？</h1>\n\n<p>MySQL中自带命令行工具 explain 来查看一个sql语句是否了索引</p>\n\n<p>使用方式：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql">explain <span class="hljs-operator"><span class="hljs-keyword">select</span> csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-7.html csdn-8.html csdn-9.html mysql.sh <span class="hljs-keyword">from</span> tb_test;</span></code></pre>\n\n<p>关注的项：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-number">1</span>、<span class="hljs-keyword">type</span> : 查询access的方式，表的连接类型\n\n index <span class="hljs-subst">|</span> 索引 \n <span class="hljs-literal">full</span> <span class="hljs-subst">|</span> 全表扫描 \n ref <span class="hljs-subst">|</span> 参照查询，也就是等值查询 \n range <span class="hljs-subst">|</span> 范围查询\n<span class="hljs-number">2</span>、key : 本次查询最终选择使用哪个索引，<span class="hljs-built_in">NULL</span>为未使用索引\n<span class="hljs-number">3</span>、key_len : 选择的索引使用的前缀长度或者整个长度\n<span class="hljs-number">4</span>、<span class="hljs-keyword">rows</span> : 查询逻辑扫描过的记录行数\n<span class="hljs-number">5</span>、extra : 额外信息，主要是指fetch <span class="hljs-built_in">data</span>的具体方式</code></pre>\n\n<p>总结：索引的本质还是提升我们查询数据库的速度，减少服务器I/O开销，提供更稳定快捷的服务</p>\n\n<hr />\n\n<p><a href="https://segmentfault.com/a/1190000007445807?utm_source=tuicool&amp;utm_medium=referral">原文链接</a></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
