\n <div class="markdown_views"><p>玩过Navicat for MySQL的都应该知道这张图，这里的索引方法指的就是索引的策略。主要有两种方式，一种是Btree，一种是Hash。</p>\n\n<p><img src="http://img.blog.csdn.net/20170314195740126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<ul>\n<li>B-tree索引</li>\n</ul>\n\n<p>注: 名叫btree索引,大的方面看,都用的平衡树,但具体的实现上, 各存储引擎稍有不同,比如,严格的说,NDB引擎,使用的是T-tree <br />\nMyisam,innodb中,默认用B-tree索引，B-tree的理论查询时间复杂度为O(log2 (N-1))，N为数据表的行数</p>\n\n<ul>\n<li>hash索引 <br />\n使用memory存储引擎的表中,默认是hash索引, hash的理论查询时间复杂度为O(1)</li>\n</ul>\n\n<p><strong>既然hash的查找如此高效,为什么不都用hash索引?</strong></p>\n\n<p>（1）hash函数计算后的结果,是随机的,如果是在磁盘上放置数据，以主键为id为例, 那么随着id的增长, id对应的行,在磁盘上随机放置。 <br />\n（2）无法对范围查询进行优化 <br />\n（3）无法利用前缀索引。比如在btree中, field列的值“helloworld”,并加索引，查询 xx=helloword,自然可以利用索引, xx=hello,也可以利用索引. (左前缀索引)，因为hash(‘helloworld’),和hash(‘hello’),两者的关系仍为随机，所以无法利用前缀索引 <br />\n（4）排序也无法优化. <br />\n（5）必须回行.就是说通过索引拿到数据位置,必须回到表中取数据</p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
