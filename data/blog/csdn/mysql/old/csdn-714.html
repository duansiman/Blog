\n <div class="markdown_views"><p><strong>索引覆盖</strong></p>\n\n<p>如果查询的列恰好是索引的一部分,那么查询只需要在索引文件上进行,不需要回行到磁盘再找数据。这种查询速度非常快,称为“索引覆盖”。</p>\n\n<p>假设有一张t15表，在表中建立了一个联合索引：cp（cat_id,price）</p>\n\n<p><img src="http://img.blog.csdn.net/20170315084253076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>当我们使用下面的sql语句，会出现索引覆盖的情况。不信我们可以来查看一下，这里的Extra中显示了Using index，表示这条sql语句刚好用到了索引覆盖。</p>\n\n<p><img src="http://img.blog.csdn.net/20170315084439336?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">select</span> price <span class="hljs-keyword">from</span> t15 <span class="hljs-keyword">where</span> cat_id = <span class="hljs-number">1</span>;</span></code></pre>\n\n<p>在来看一题，创建一张t11表，在email列有一个索引</p>\n\n<p><img src="http://img.blog.csdn.net/20170315090022720?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>假设我们用这样的查询语句：</p>\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-operator"><span class="hljs-keyword">select</span> eamil <span class="hljs-keyword">from</span> t11 <span class="hljs-keyword">where</span> <span class="hljs-keyword">right</span>(email,<span class="hljs-number">4</span>)=<span class="hljs-string">'.com'</span></span></code></pre>\n\n<p>查询分析：</p>\n\n<p><img src="http://img.blog.csdn.net/20170315090306721?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>首先看一下Extra，这里有Using index，说明这里使用到了索引覆盖，而possible_keys为NULL的原因是因为，使用到了mysql中的函数，所以在查询的时候并没有使用到email索引，但是key却为email，表示了使用到了索引进行排序，不信我把数据打印看看。</p>\n\n<p><img src="http://img.blog.csdn.net/20170315091020889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>这里的数据是经过排序的。原本的数据是这样的。</p>\n\n<p><img src="http://img.blog.csdn.net/20170315091104687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p><strong>索引覆盖的问题</strong></p>\n\n<p>create table A ( <br />\n id varchar(64) primary key, <br />\n ver int, <br />\n … <br />\n) <br />\n表中有几个很长的字段varbinary(3000) ，在id、ver上有联合索引 ，共10000条数据 </p>\n\n<p>为什么select id from A order by id特别慢？ <br />\n而select id from A order by id,ver非常快 </p>\n\n<p>疑问: id, (id,ver)都有索引, select id 应该都产生”索引覆盖”的效果,为什么前者慢,而后快？</p>\n\n<p>思路：innodb聚簇与myisam索引的不同 , 索引覆盖 这2个角度来考虑</p>\n\n<p>（1）假设此表使用的是Myisam的索引，那么这两条sql语句都不需要回行查找数据，那么他们的速度应该差不多。</p>\n\n<p>（2）假设此表使用的是InnoDB的索引，那么select id from A order by id这句sql使用到了主键索引，因为InnoDB的每个主键都挂载这每行的数据，并且本题中还有几个特别大的字段，所以会在查找id的时候需要走的相对慢；而select id from A order by id,ver这句sql使用到了id,ver联合索引，在InnoDB存储引擎中，次索引保存的是对主键索引的应用，所以次索引不挂载该行的数据，那么在(id,ver)索引中查找id会快，当找到对应的节点树时，只需要再次查找到主键索引的位置，即可拿到该行的数据，这样比较快。</p>\n\n<p>推断:</p>\n\n<p>（1）表如果是myisam引擎,2个语句,速度不会有明显差异. <br />\n（2）innodb表因为聚簇索引,id索引要在磁盘上跨N多块,导致速度慢. <br />\n（3）即使innodb引擎,如果没有那几个varbinay长列, 2个语句的速度也不会有明显差异.</p>\n\n<p>t12表，存储引擎为MyISAM，有主键索引和（id,ver）符合索引，还有几个大的变长字段，测试推论1</p>\n\n<p><img src="http://img.blog.csdn.net/20170315094720272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>t13表，存储引擎为InnoDB，有主键索引和（id,ver）符合索引，还有几个大的变长字段推论2</p>\n\n<p><img src="http://img.blog.csdn.net/20170315094851013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>t14表，存储引擎为InnoDB，有主键索引和（id,ver）符合索引，没有几个大的变长字段推论3</p>\n\n<p><img src="http://img.blog.csdn.net/20170315095810401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p>\n\n<p>t12,t13,t14每张表中都有1W条数据，然后进行测试，测试结果如下，我们的推论是正确的。</p>\n\n<p><img src="http://img.blog.csdn.net/20170315095850808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFvY2hhbzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" /></p></div>&#13;\n <script type="text/javascript">&#13;\n $(function () {&#13;\n $('pre.prettyprint code').each(function () {&#13;\n var lines = $(this).text().split('\\n').length;&#13;\n var $numbering = $('&lt;ul/&gt;').addClass('pre-numbering').hide();&#13;\n $(this).addClass('has-numbering').parent().append($numbering);&#13;\n for (i = 1; i &lt;= lines; i++) {&#13;\n $numbering.append($('&lt;li/&gt;').text(i));&#13;\n };&#13;\n $numbering.fadeIn(1700);&#13;\n });&#13;\n });&#13;\n </script>&#13;\n &#13;\n
