\n\n<p>分页的具体讲解讲解请看<a target="_blank" href="http://blog.csdn.net/u011225629/article/details/46775947">http://blog.csdn.net/u011225629/article/details/46775947</a></p>&#13;\n<p>查看代码打印1 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-8.html csdn-9.html mysql.sh FROM table ORDER BY id LIMIT 1000,10;<br />&#13;\n以上SQL语句在原理上和在实际操作中是不会存在什么问题，但是当table表的数据量达到几十万以上的时候，上面的语句执行一遍，可能会要执行个十几秒的时间，并且当页数越靠后的话，执行的时间会越长，这个时候我们就需要找到一种更快的查询办法来替代这种操作了。</p>&#13;\n<p>网上已经有很多优化的方法，基本都是这样的：</p>&#13;\n<p>查看代码打印1 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-8.html csdn-9.html mysql.sh FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;<br />&#13;\n以上SQL语句是一个不错的解决方法，分页查询的速度基本会保持在1秒之内，但据经验总结得出还有一种更好的办法，如下：</p>&#13;\n<p>查看代码打印1 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-8.html csdn-9.html mysql.sh FROM table WHERE id BETWEEN 1000000 AND 1000010;<br />&#13;\n相比以上的解决办法，在速度上还会快了不少。</p>&#13;\n<p>另外分享两个关于查询的技巧：</p>&#13;\n<p>（1）如果需要查询 id 不是连续的一段，最佳的做法就是先找出 id ，然后用 in 查询：</p>&#13;\n<p>查看代码打印1 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-8.html csdn-9.html mysql.sh FROM table WHERE id IN(10000, 100000, 1000000...);<br />&#13;\n（2）当查询字段一较长字符串的时候，表设计时要为该字段多加一个字段，如存储网址的字段，在需要查询该字段的时候，不要直接查询字符串，效率低下，应该查诡该字串的crc32或md5值。</p>&#13;\n<p>如何优化Mysql千万级快速分页，以下摘抄与网上，读者自行参考。</p>&#13;\n<p>MySql 性能到底能有多高？用了php半年多，真正如此深入的去思考这个问题还是从前天开始。有过痛苦有过绝望，到现在充满信心！MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。用事实说话，看例子：</p>&#13;\n<p>数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用硬盘1.6G。OK ,看下面这条sql语句：</p>&#13;\n<p>select id,title from collect limit 1000,10; 很快；基本上0.01秒就OK，再看下面的</p>&#13;\n<p>select id,title from collect limit 90000,10; 从9万条开始分页，结果？</p>&#13;\n<p>8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句:</p>&#13;\n<p>select id from collect order by id limit 90000,10;</p>&#13;\n<p>很快，0.04秒就OK。 为什么？因为用了id主键做索引当然快。网上的改法是：</p>&#13;\n<p>select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</p>&#13;\n<p>这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句</p>&#13;\n<p>select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！</p>&#13;\n<p>到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接</p>&#13;\n<p>select id from collect where vtype=1 limit 1000,10;</p>&#13;\n<p>是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下：</p>&#13;\n<p>建一个索引表： t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。 是否可行呢？实验下就知道了。</p>&#13;\n<p>10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用</p>&#13;\n<p>select id from t where vtype=1 order by id limit 90000,10;</p>&#13;\n<p>很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？错！因为我们的limit还是9万，所以快。给个大的，90万开始</p>&#13;\n<p>select id from t where vtype=1 order by id limit 900000,10;</p>&#13;\n<p>看看结果，时间是1-2秒！why ?</p>&#13;\n<p>分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！</p>&#13;\n<p>难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？</p>&#13;\n<p>答案是： NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！<br />&#13;\n <br />&#13;\n好了，我们的测试又回到 collect表，开始测试结论是：</p>&#13;\n<p>30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！<br />&#13;\n <br />&#13;\n答 案就是：复合索引！ 有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？开始的</p>&#13;\n<p>select id from collect order by id limit 90000,10;</p>&#13;\n<p>这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。然后测试</p>&#13;\n<p>select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！</p>&#13;\n<p>再测试: select id ,title from collect where vtype=1 limit 90000,10; 非常遗憾，8-9秒，没走search索引！</p>&#13;\n<p>再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。</p>&#13;\n<p>综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！</p>&#13;\n<p>完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！<br />&#13;\n <br />&#13;\n好了，回到原题，如何将上面的研究成功快速应用于开发呢？如果用复合查询，我的轻量级框架就没的用了。分页字符串还得自己写，那多麻烦？这里再看一个例子，思路就出来了：</p>&#13;\n<p>select csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-8.html csdn-9.html mysql.sh from collect where id in (9000,12,50,7000); 竟然 0秒就可以查完！</p>&#13;\n<p>mygod ，mysql 的索引竟然对于in语句同样有效！看来网上说in无法用索引是错误的！</p>&#13;\n<p>有了这个结论，就可以很简单的应用于轻量级框架了：</p>&#13;\n<p style="text-align:center"><img alt="" src="http://www.bjbenet.com/uploads/allimg/140321/1-1403211FUcM.png" style="width:605px; height:405px" /></p>&#13;\n<p> 通过简单的变换，其实思路很简单：</p>&#13;\n<p>（1）通过优化索引，找出id，并拼成 “123,90000,12000″ 这样的字符串。</p>&#13;\n<p>（2）第2次查询找出结果。小小的索引+一点点的改动就使mysql 可以支持百万甚至千万级的高效分页！</p>&#13;\n<p>通过这里的例子，我反思了一点：对于大型系统，PHP千万不能用框架，尤其是那种连sql语句都看不到的框架！因为开始对于我的轻量级框架都差点崩溃！只适合小型应用的快速开发，对于ERP,OA，大型网站，数据层包括逻辑层的东西都不能用框架。如果程序员失去了对sql语句的把控，那项目的风险将会成几何级数增加！尤其是用mysql 的时候，mysql 一定需要专业的dba 才可以发挥他的最佳性能。一个索引所造成的性能差别可能是上千倍！</p>&#13;\n &#13;\n
