\n\n<p> </p>&#13;\n<p>1. 为查询缓存优化你的查询</p>&#13;\n<p>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p>&#13;\n<p>这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：</p>&#13;\n<pre>// 查询缓存不开启$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= CURDATE()");// 开启查询缓存$today = date("Y-m-d");$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= '$today'");</pre>&#13;\n<p>上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。</p>&#13;\n<p></p>&#13;\n<h4>2. EXPLAIN 你的 SELECT 查询</h4>&#13;\n<p>使用 <a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/explain.html" style="color:rgb(41,112,166)">EXPLAIN</a> 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。</p>&#13;\n<p>EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。</p>&#13;\n<p>挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：</p>&#13;\n<div><img alt="" src="http://nettuts.s3.amazonaws.com/500_mysql/unoptimized_explain.jpg" border="0" /></div>&#13;\n<p>当我们为 group_id 字段加上索引后：</p>&#13;\n<div><img alt="" src="http://nettuts.s3.amazonaws.com/500_mysql/optimized_explain.jpg" border="0" /></div>&#13;\n<p>我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。</p>&#13;\n<h4>3. 当只要一行数据时使用 LIMIT 1</h4>&#13;\n<p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p>&#13;\n<p>在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>&#13;\n<p>下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）</p>&#13;\n<pre>// 没有效率的：$r = mysql_query("SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-8.html csdn-9.html mysql.sh FROM user WHERE country = 'China'");if (mysql_num_rows($r) &gt; 0) {\t// ...}// 有效率的：$r = mysql_query("SELECT 1 FROM user WHERE country = 'China' LIMIT 1");if (mysql_num_rows($r) &gt; 0) {\t// ...}</pre>&#13;\n<h4><span style="color:#000000"></span>&#13;\n</h4><p><strong>4. 存储引擎优化</strong></p>&#13;\n<p>　　MySQL支持不同的存储引擎，主要使用的有MyISAM和InnoDB。</p>&#13;\n<p>　　4.1 MyISAM</p>&#13;\n<p>　　MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非配置MySQL默认使用另外一个引擎。</p>&#13;\n<p>　　4.1.1 MyISAM特性</p>&#13;\n<p>　　4.1.1.1 MyISAM Properties</p>&#13;\n<p>　　1) 不支持事务，宕机会破坏表</p>&#13;\n<p>　　2) 使用较小的内存和磁盘空间</p>&#13;\n<p>　　3) 基于表的锁，并发更新数据会出现严重性能问题</p>&#13;\n<p>　　4) MySQL只缓存Index，数据由<a target="_blank" href="http://www.chinabyte.com/keyword/OS/">OS</a>缓存</p>&#13;\n<p>　　4.1.1.2 Typical MyISAM usages</p>&#13;\n<p>　　1) 日志系统</p>&#13;\n<p>　　2) 只读或者绝大部分是读操作的应用</p>&#13;\n<p>　　3) 全表扫描</p>&#13;\n<p>　　4) 批量导入数据</p>&#13;\n<p>　　5) 没有事务的低并发读/写</p>&#13;\n<p>　　4.1.2 MyISAM优化要点</p>&#13;\n<p>　　1) 声明列为NOT NULL，可以减少磁盘存储。</p>&#13;\n<p>　　2) 使用optimize table做碎片整理，回收空闲空间。注意仅仅在非常大的数据变化后运行。</p>&#13;\n<p>　　3) Deleting/updating/adding大量数据的时候禁止使用index。使用ALTER TABLE t DISABLE KEYS。</p>&#13;\n<p>　　4) 设置myisam_max_[extra]_sort_file_size足够大，可以显著提高repair table的速度。</p>&#13;\n<p>　　4.1.3 MyISAM Table Locks</p>&#13;\n<p>　　1) 避免并发insert，update。</p>&#13;\n<p>　　2) 可以使用insert delayed，但是有可能丢失数据。</p>&#13;\n<p>　　3) 优化查询语句。</p>&#13;\n<p>　　4) 水平分区。</p>&#13;\n<p>　　5) 垂直分区。</p>&#13;\n<p>　　6) 如果都不起作用，使用InnoDB。</p>&#13;\n<p>　　4.1.4 MyISAM Key Cache</p>&#13;\n<p>　　1) 设置key_buffer_size variable。MyISAN最主要的cache设置，用于缓存MyISAM表格的index数据，该参数只对MyISAM有影响。通常在只使用 MyISAM的Server中设置25-33%的内存大小。</p>&#13;\n<p>　　2) 可以使用几个不同的Key Caches(对一些hot data)。</p>&#13;\n<p>　　a) SET GLOBAL test.key_buffer_size=512*1024;</p>&#13;\n<p>　　b) CACHE INDEX t1.i1, t2.i1, t3 IN test;</p>&#13;\n<p>　　2) Preload index到Cache中可以提高查询速度。因为preloading index是顺序的，所以非常快。</p>&#13;\n<p>　　a) LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</p>&#13;\n<p>　　4.2 InnoDB</p>&#13;\n<p>　　InnoDB 给MySQL提供了具有提交，回滚和崩溃恢复能力的事务安全(ACID兼容)存储引擎。InnoDB提供row level lock，并且也在SELECT语句提供一个Oracle风格一致的非锁定读。这些特色增加了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中row level lock适合非常小的空间。InnoDB也支持FOREIGN KEY约束。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。</p>&#13;\n<p>　　InnoDB 是为在处理巨大数据量时获得最大性能而设计的。它的CPU使用效率非常高。</p>&#13;\n<p>　　InnoDB存储引擎已经完全与MySQL服务器整合，InnoDB存储引擎为在内存中缓存数据和索引而维持它自己的缓冲池。 InnoDB存储它的表&amp;索引在一个表空间中，表空间可以包含数个文件(或原始磁盘分区)。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何大小，即使在文件尺寸被限制为2GB的<a target="_blank" href="http://soft.chinabyte.com/czxt/">操作系统</a>上。</p>&#13;\n<p>　　许多需要高性能的大型数据库站点上使用了 InnoDB引擎。著名的Internet新闻站点Slashdot.org运行在InnoDB上。 Mytrix, Inc.在InnoDB上存储超过1TB的数据，还有一些其它站点在InnoDB上处理平均每秒800次插入/更新的负荷。</p>&#13;\n<p>　　4.2.1 InnoDB特性</p>&#13;\n<p>　　4.2.1.1 InnoDB Properties</p>&#13;\n<p>　　1) 支持事务，ACID，外键。</p>&#13;\n<p>　　2) Row level locks。</p>&#13;\n<p>　　3) 支持不同的隔离级别。</p>&#13;\n<p>　　4) 和MyISAM相比需要较多的内存和磁盘空间。</p>&#13;\n<p>　　5) 没有键压缩。</p>&#13;\n<p>　　6) 数据和索引都缓存在内存hash表中。</p>&#13;\n<p>　　4.2.1.2 InnoDB Good For</p>&#13;\n<p>　　1) 需要事务的应用。</p>&#13;\n<p>　　2) 高并发的应用。</p>&#13;\n<p>　　3) 自动恢复。</p>&#13;\n<p>　　4) 较快速的基于主键的操作。</p>&#13;\n<p>　　4.2.2 InnoDB优化要点</p>&#13;\n<p>　　1) 尽量使用short，integer的主键。</p>&#13;\n<p>　　2) Load/Insert数据时按主键顺序。如果数据没有按主键排序，先排序然后再进行数据库操作。</p>&#13;\n<p>　　3) 在Load数据是为设置SET UNIQUE_CHECKS=0，SET FOREIGN_KEY_CHECKS=0，可以避免外键和唯一性约束检查的开销。</p>&#13;\n<p>　　4) 使用prefix keys。因为InnoDB没有key压缩功能。</p>&#13;\n<p>　　4.2.3 InnoDB服务器端设定</p>&#13;\n<p>　　innodb_buffer_pool_size：这是InnoDB最重要的设置，对InnoDB性能有决定性的影响。默认的设置只有8M，所以默认的数据库设置下面InnoDB性能很差。在只有InnoDB存储引擎的数据库服务器上面，可以设置60-80%的内存。更精确一点，在内存容量允许的情况下面设置比InnoDB tablespaces大10%的内存大小。</p>&#13;\n<p>　　innodb_data_file_path：指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也只有最后一个文件允许自动扩充。这样，当空间用完后，自动扩充数据文件就会自动增长(以8MB为单位)以容纳额外的数据。例如： innodb_data_file_path=/disk1/ibdata1:900M;/disk2/ibdata2:50M:autoextend两个数据文件放在不同的磁盘上。数据首先放在ibdata1中，当达到900M以后，数据就放在ibdata2中。一旦达到50MB，ibdata2将以&#13;\n 8MB为单位自动增长。如果磁盘满了，需要在另外的磁盘上面增加一个数据文件。</p>&#13;\n<p>　　innodb_autoextend_increment: 默认是8M, 如果一次insert数据量比较多的话, 可以适当增加.</p>&#13;\n<p>　　innodb_data_home_dir：放置表空间数据的目录，默认在mysql的数据目录，设置到和MySQL安装文件不同的分区可以提高性能。</p>&#13;\n<p>　　innodb_log_file_size：该参数决定了recovery speed。太大的话recovery就会比较慢，太小了影响查询性能，一般取256M可以兼顾性能和recovery的速度。</p>&#13;\n<p>　　innodb_log_buffer_size：磁盘速度是很慢的，直接将log写道磁盘会影响InnoDB的性能，该参数设定了log buffer的大小，一般4M。如果有大的blob操作，可以适当增大。</p>&#13;\n<p>　　innodb_flush_logs_at_trx_commit=2： 该参数设定了事务提交时内存中log信息的处理。</p>&#13;\n<p>　　1) =1时，在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新。Truly ACID。速度慢。</p>&#13;\n<p>　　2) =2时，在每个事务提交时，日志缓冲被写到文件，但不对日志文件做到磁盘操作的刷新。只有操作系统崩溃或掉电才会删除最后一秒的事务，不然不会丢失事务。</p>&#13;\n<p>　　3) =0时， 日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新。任何mysqld进程的崩溃会删除崩溃前最后一秒的事务</p>&#13;\n<p>　　innodb_file_per_table：可以存储每个InnoDB表和它的索引在它自己的文件中。</p>&#13;\n<p>　　transaction-isolation=READ-COMITTED: 如果应用程序可以运行在READ-COMMITED隔离级别，做此设定会有一定的性能提升。</p>&#13;\n<p>　　innodb_flush_method： 设置InnoDB同步IO的方式：</p>&#13;\n<p>　　1) Default – 使用fsync()。</p>&#13;\n<p>　　2) O_SYNC 以sync模式打开文件，通常比较慢。</p>&#13;\n<p>　　3) O_DIRECT，在Linux上使用Direct IO。可以显著提高速度，特别是在<a target="_blank" href="http://www.chinabyte.com/keyword/RAID/">RAID</a>系统上。避免额外的数据复制和double buffering(mysql buffering 和OS buffering)。</p>&#13;\n<p>　　innodb_thread_concurrency： InnoDB kernel最大的线程数。</p>&#13;\n<p>　　1) 最少设置为(num_disks+num_cpus)*2。</p>&#13;\n<p>　　2) 可以通过设置成1000来禁止这个限制</p>&#13;\n&#13;\n<h4>5. 在Join表的时候使用相当类型的例，并将其索引</h4>&#13;\n<p>如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。</p>&#13;\n<p>而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</p>&#13;\n<pre>// 在state中查找company$r = mysql_query("SELECT company_name FROM users\tLEFT JOIN companies ON (users.state = companies.state)\tWHERE users.id = $user_id");// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。</pre>&#13;\n<h4>6. 千万不要 ORDER BY RAND()</h4>&#13;\n<p>想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。</p>&#13;\n<p>如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）</p>&#13;\n<p>下面的示例是随机挑一条记录</p>&#13;\n<pre>// 千万不要这样做：$r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1");// 这要会更好：$r = mysql_query("SELECT count(*) FROM user");$d = mysql_fetch_row($r);$rand = mt_rand(0,$d[0] - 1);$r = mysql_query("SELECT username FROM user LIMIT $rand, 1");</pre>&#13;\n<h4>7. 避免 SELECT *</h4>&#13;\n<p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p>&#13;\n<p>所以，你应该养成一个需要什么就取什么的好的习惯。</p>&#13;\n<pre>// 不推荐$r = mysql_query("SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-8.html csdn-9.html mysql.sh FROM user WHERE user_id = 1");$d = mysql_fetch_assoc($r);echo "Welcome {$d['username']}";// 推荐$r = mysql_query("SELECT username FROM user WHERE user_id = 1");$d = mysql_fetch_assoc($r);echo "Welcome {$d['username']}";</pre>&#13;\n<h4>8. 永远为每张表设置一个ID</h4>&#13;\n<p>我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p>&#13;\n<p>就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。</p>&#13;\n<p>而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</p>&#13;\n<p>在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。</p>&#13;\n<h4>9. 使用 ENUM 而不是 VARCHAR</h4>&#13;\n<p><a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/enum.html" style="color:rgb(41,112,166)">ENUM</a> 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>&#13;\n<p>如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p>&#13;\n<p>MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</p>&#13;\n<h4>10. 从 PROCEDURE ANALYSE() 取得建议</h4>&#13;\n<p><a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/procedure-analyse.html" style="color:rgb(41,112,166)">PROCEDURE ANALYSE()</a> 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</p>&#13;\n<p>例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</p>&#13;\n<p>在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议</p>&#13;\n<div><img alt="" src="http://nettuts.s3.amazonaws.com/500_mysql/suggestions.jpg" border="0" /></div>&#13;\n<p>一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。</p>&#13;\n<h4>11. 尽可能的使用 NOT NULL</h4>&#13;\n<p>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。</p>&#13;\n<p>首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)</p>&#13;\n<p>不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。</p>&#13;\n<p>下面摘自MySQL自己的文档：</p>&#13;\n<blockquote>&#13;\n<p>“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</p>&#13;\n</blockquote>&#13;\n<h4>12. Prepared Statements</h4>&#13;\n<p>Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p>&#13;\n<p>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。</p>&#13;\n<p>在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。</p>&#13;\n<p>虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。</p>&#13;\n<p>当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。</p>&#13;\n<p>在PHP中要使用prepared statements，你可以查看其使用手册：<a target="_blank" href="http://php.net/manual/en/book.mysqli.php" style="color:rgb(41,112,166)">mysqli 扩展</a> 或是使用数据库抽象层，如： <a target="_blank" href="http://us.php.net/manual/en/book.pdo.php" style="color:rgb(41,112,166)">PDO</a>.</p>&#13;\n<pre>// 创建 prepared statementif ($stmt = $mysqli-&gt;prepare("SELECT username FROM user WHERE state=?")) {\t// 绑定参数 $stmt-&gt;bind_param("s", $state);\t// 执行 $stmt-&gt;execute();\t// 绑定结果 $stmt-&gt;bind_result($username);\t// 移动游标 $stmt-&gt;fetch(); printf("%s is from %s\\n", $username, $state); $stmt-&gt;close();}</pre>&#13;\n<h4>13. 无缓冲的查询</h4>&#13;\n<p>正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。</p>&#13;\n<p>关于这个事情，在PHP的文档中有一个非常不错的说明： <a target="_blank" href="http://php.net/manual/en/function.mysql-unbuffered-query.php" style="color:rgb(41,112,166)">mysql_unbuffered_query()</a> 函数：</p>&#13;\n<blockquote>&#13;\n<p>“mysql_unbuffered_query() sends the SQL query query to MySQL without automatically fetching and buffering the result rows as mysql_query() does. This saves a considerable amount of memory with SQL queries that produce large result sets, and you can start&#13;\n working on the result set immediately after the first row has been retrieved as you don’t have to wait until the complete SQL query has been performed.”</p>&#13;\n</blockquote>&#13;\n<p>上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。</p>&#13;\n<p>然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用<a target="_blank" href="http://us2.php.net/manual/en/function.mysql-free-result.php" style="color:rgb(41,112,166)">mysql_free_result()</a> 清除结果。而且， <a target="_blank" href="http://us2.php.net/manual/en/function.mysql-num-rows.php" style="color:rgb(41,112,166)">mysql_num_rows()</a> 或 <a target="_blank" href="http://us2.php.net/manual/en/function.mysql-data-seek.php" style="color:rgb(41,112,166)">mysql_data_seek()</a> 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。</p>&#13;\n<h4>14. 把IP地址存成 UNSIGNED INT</h4>&#13;\n<p>很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。</p>&#13;\n<p>我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。</p>&#13;\n<p>而你的查询，你可以使用 <a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-aton" style="color:rgb(41,112,166)">INET_ATON()</a> 来把一个字符串IP转成一个整形，并使用 <a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-ntoa" style="color:rgb(41,112,166)">INET_NTOA()</a> 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 <a target="_blank" href="http://php.net/manual/en/function.ip2long.php" style="color:rgb(41,112,166)">ip2long()</a> 和 <a target="_blank" href="http://us.php.net/manual/en/function.long2ip.php" style="color:rgb(41,112,166)">long2ip()</a>。</p>&#13;\n<pre>$r = "UPDATE users SET ip = INET_ATON('{$_SERVER['REMOTE_ADDR']}') WHERE user_id = $user_id";</pre>&#13;\n<h4>15. 固定长度的表会更快</h4>&#13;\n<p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 <a target="_blank" href="http://dev.mysql.com/doc/refman/5.1/en/static-format.html" style="color:rgb(41,112,166)">“static” 或 “fixed-length”</a>。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL&#13;\n 引擎会用另一种方法来处理。</p>&#13;\n<p>固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p>&#13;\n<p>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>&#13;\n<p>使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。</p>&#13;\n<h4>16. 垂直分割</h4>&#13;\n<p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）</p>&#13;\n<p><strong>示例一</strong>：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</p>&#13;\n<p><strong>示例二</strong>： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</p>&#13;\n<p>另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p>&#13;\n<h4>17. 拆分大的 DELETE 或 INSERT 语句</h4>&#13;\n<p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p>&#13;\n<p>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p>&#13;\n<p>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。</p>&#13;\n<p>所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</p>&#13;\n<pre>while (1) { //每次只做1000条\tmysql_query("DELETE FROM logs WHERE log_date &lt;= '2009-11-01' LIMIT 1000");\tif (mysql_affected_rows() == 0) {\t\t// 没得可删了，退出！\t\tbreak;\t}\t// 每次都要休息一会儿\tusleep(50000);}</pre>&#13;\n<h4>18. 越小的列会越快</h4>&#13;\n<p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</p>&#13;\n<p>参看 MySQL 的文档 <a target="_blank" href="http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html" style="color:rgb(41,112,166)">Storage Requirements</a> 查看所有的数据类型。</p>&#13;\n<p>如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</p>&#13;\n<p>当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看<a target="_blank" href="http://news.slashdot.org/article.pl?sid=06/11/09/1534204" style="color:rgb(41,112,166)">Slashdot的例子</a>（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。</p>&#13;\n<h4>19. 选择正确的存储引擎</h4>&#13;\n<p>在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《<a target="_blank" href="http://coolshell.cn/articles/652.html" style="color:rgb(41,112,166)">MySQL: InnoDB 还是 MyISAM?</a>》讨论和这个事情。</p>&#13;\n<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>&#13;\n<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>&#13;\n<p>下面是MySQL的手册</p>&#13;\n<ul>&#13;\n<li><a target="_blank" href="http://dev.mysql.com/doc/refman/5.1/en/myisam-storage-engine.html" style="color:rgb(41,112,166)">target=”_blank”MyISAM Storage Engine</a></li><li><a target="_blank" href="http://dev.mysql.com/doc/refman/5.1/en/innodb.html" style="color:rgb(41,112,166)">InnoDB Storage Engine</a></li></ul>&#13;\n<h4>20. 使用一个对象关系映射器（Object Relational Mapper）</h4>&#13;\n<p>使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。</p>&#13;\n<p>ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</p>&#13;\n<p>ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。</p>&#13;\n<p>目前，个人最喜欢的PHP的ORM是：<a target="_blank" href="http://www.doctrine-project.org/" style="color:rgb(41,112,166)">Doctrine</a>。</p>&#13;\n<h4>21. 小心“永久链接”</h4>&#13;\n<p>“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。</p>&#13;\n<p> </p>&#13;\n<p> </p>&#13;\n<p><strong>22、分库分表</strong></p>&#13;\n<p>很明显，一个主表（也就是很重要的表，例如用户表）无限制的增长势必严重影响性能，分库与分表是一个很不错的解决途径，也就是性能优化途径，现在的案例是我们有一个1000多万条记录的用户表members,查询起来非常之慢，同事的做法是将其散列到100个表中，分别从members0到members99，然后根据mid分发记录到这些表中，牛逼的代码大概是这样子：</p>&#13;\n<div style="color:rgb(17,0,0)">&#13;\n<div>&#13;\n<pre><span style="color:#000000">&lt;?php</span><span style="color:#b1b10">for</span><span style="color:#0990">(</span><span style="color:#0088">$i</span><span style="color:#339933">=</span><span style="color:#cc66cc">0</span><span style="color:#339933">;</span><span style="color:#0088">$i</span><span style="color:#339933">&lt;</span> <span style="color:#cc66cc">100</span><span style="color:#339933">;</span> <span style="color:#0088">$i</span><span style="color:#339933">++</span> <span style="color:#0990">)</span><span style="color:#0990">{</span>\t<span style="color:#666666">//echo "CREATE TABLE db2.members{$i} LIKE db1.members&lt;br&gt;";</span>\t<span style="color:#b1b10">echo</span> <span style="color:#00ff">"INSERT INTO members<span style="color:#06699">{$i}</span> SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-8.html csdn-9.html mysql.sh FROM members WHERE mid%100=<span style="color:#06699">{$i}</span>&lt;br&gt;"</span><span style="color:#339933">;</span><span style="color:#0990">}</span><span style="color:#000000">?&gt;</span></pre>&#13;\n</div>&#13;\n</div>&#13;\n<p> </p>&#13;\n<p><strong>23、不停机修改mysql表结构</strong></p>&#13;\n<p>同样还是members表，前期设计的表结构不尽合理，随着数据库不断运行，其冗余数据也是增长巨大，同事使用了下面的方法来处理：</p>&#13;\n<p>先创建一个临时表：</p>&#13;\n<div style="color:rgb(17,0,0)">&#13;\n<div>&#13;\n<pre><span style="color:#808080">/*创建临时表*/</span><span style="color:#993333">CREATE</span> <span style="color:#993333">TABLE</span> members_tmp <span style="color:#993333">LIKE</span> members</pre>&#13;\n</div>&#13;\n</div>&#13;\n<p>然后修改members_tmp的表结构为新结构，接着使用上面那个for循环来导出数据，因为1000万的数据一次性导出是不对的，mid是主键，一个区间一个区间的导，基本是一次导出5万条吧，这里略去了<br />&#13;\n接着重命名将新表替换上去：</p>&#13;\n<div style="color:rgb(17,0,0)">&#13;\n<div>&#13;\n<pre><span style="color:#808080">/*这是个颇为经典的语句哈*/</span><span style="color:#993333">RENAME</span> <span style="color:#993333">TABLE</span> members <span style="color:#993333">TO</span> members_bak<span style="color:#66cc66">,</span>members_tmp <span style="color:#993333">TO</span> members;</pre>&#13;\n</div>&#13;\n</div>&#13;\n<p>就是这样，基本可以做到无损失，无需停机更新表结构，但实际上RENAME期间表是被锁死的，所以选择在线少的时候操作是一个技巧。经过这个操作，使得原先8G多的表，一下子变成了2G多</p>&#13;\n<p>另外还讲到了mysql中float字段类型的时候出现的诡异现象，就是在pma中看到的数字根本不能作为条件来查询.感谢zj同学的新鲜分享。</p>&#13;\n<p>24、MySQL性能优化的参数</p>&#13;\n<p> </p>&#13;\n<p style="color:rgb(51,51,51)">公司网站访问量越来越大，MySQL自然成为瓶颈，因此最近我一直在研究 MySQL 的优化，第一步自然想到的是 MySQL 系统参数的优化，作为一个访问量很大的网站（日20万人次以上）的数据库系统，不可能指望 MySQL 默认的系统参数能够让 MySQL运行得非常顺畅。 <br />&#13;\n通过在网络上查找资料和自己的尝试，我认为以下系统参数是比较关键的： <br />&#13;\n(1)、back_log：</p>&#13;\n<p style="color:rgb(51,51,51)">要求 MySQL 能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。</p>&#13;\n<p style="color:rgb(51,51,51)">back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。你的操作系统在这个队列大小上有它自己的限制。 试图设定back_log高于你的操作系统的限制将是无效的。 </p>&#13;\n<p style="color:rgb(51,51,51)">当你观察你的主机进程列表，发现大量 264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大 back_log 的值了。默认数值是50，我把它改为500。 <br />&#13;\n(2)、interactive_timeout：</p>&#13;\n<p style="color:rgb(51,51,51)">服务器在关闭它前在一个交互连接上等待行动的秒数。一个交互的客户被定义为对 mysql_real_connect()使用 CLIENT_INTERACTIVE 选项的客户。 默认数值是28800，我把它改为7200。 <br />&#13;\n(3)、key_buffer_size：</p>&#13;\n<p style="color:rgb(51,51,51)">索引块是缓冲的并且被所有的线程共享。key_buffer_size是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，系统将开始换页并且真的变慢了。默认数值是8388600(8M)，我的MySQL主机有2GB内存，所以我把它改为402649088(400MB)。 <br />&#13;\n(4)、max_connections：</p>&#13;\n<p style="color:rgb(51,51,51)">允许的同时客户的数量。增加该值增加 mysqld 要求的文件描述符的数量。这个数字应该增加，否则，你将经常看到 Too many connections 错误。 默认数值是100，我把它改为1024 。 <br />&#13;\n(5)、record_buffer：</p>&#13;\n<p style="color:rgb(51,51,51)">每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。默认数值是131072(128K)，我把它改为16773120 (16M) <br />&#13;\n(6)、sort_buffer：</p>&#13;\n<p style="color:rgb(51,51,51)">每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。默认数值是2097144(2M)，我把它改为 16777208 (16M)。 <br />&#13;\n(7)、table_cache：</p>&#13;\n<p style="color:rgb(51,51,51)">为所有线程打开表的数量。增加该值能增加mysql要求的文件描述符的数量。MySQL对每个唯一打开的表需要2个文件描述符。默认数值是64，我把它改为512。 <br />&#13;\n(8)、thread_cache_size： </p>&#13;\n<p style="color:rgb(51,51,51)">可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。我把它设置为 80。 <br />&#13;\n(10)、wait_timeout：</p>&#13;\n<p style="color:rgb(51,51,51)">服务器在关闭它之前在一个连接上等待行动的秒数。 默认数值是28800，我把它改为7200。 <br />&#13;\n注：参数的调整可以通过修改 /etc/my.cnf 文件并重启 MySQL 实现。这是一个比较谨慎的工作，上面的结果也仅仅是我的一些看法，你可以根据你自己主机的硬件情况（特别是内存大小）进一步修改。<img height="1" alt="" src="http://bbs.8s8s.com/down_info.%3Ca%20href=" />asp?id=482" width=1 border=0&gt;</p>&#13;\n<p style="color:rgb(51,51,51)"></p>&#13;\n<h4>25. 为搜索字段建索引</h4>&#13;\n<p></p>&#13;\n<p></p>&#13;\n<p>margin-top: 0px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left:</p>&#13;\n<p> </p>&#13;\n &#13;\n
