\n\n<p> </p>&#13;\n<span style="line-height:1.5"></span>&#13;\n<p> </p>&#13;\n<p><span style="color:#00ff">一、 什么是事务</span></p>&#13;\n<p>事务就是一段<span style="font-family:Times New Roman">sql </span><span style="font-family:宋体">语句的批处理，但是这个批处理</span>是一个<span style="font-family:Times New Roman">atom</span><span style="font-family:宋体">（原子） ，不可分割，要么都执行，要</span>么回滚（<span style="font-family:Times New Roman">rollbac</span>k<span style="font-family:宋体">）都不执行。</span></p>&#13;\n<p><span style="color:#00ff">二、为什么出现这种技术</span></p>&#13;\n<p>为什么要使用事务这个技术呢？ 现在的很多软件都是多用户，多程序，多线程的，对同一个表可能同时有很多人在用，为保持数据的一致性，所以提出了事务的概念。这样很抽象，举个例子： </p>&#13;\n<p>A <span style="font-family:宋体">给</span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">要划钱，</span><span style="font-family:Times New Roman">A </span><span style="font-family:宋体">的账户</span><span style="font-family:Times New Roman">-1000</span><span style="font-family:宋体">元， </span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">的账户就要</span><span style="font-family:Times New Roman">+1000</span><span style="font-family:宋体">元，这两个</span><span style="font-family:Times New Roman">update </span><span style="font-family:宋体">语句必须作为一个整体来执行，不然</span><span style="font-family:Times New Roman">A </span><span style="font-family:宋体">扣钱了，</span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">没有加钱这种情况很难处理（找出原因）。</span></p>&#13;\n<p><span style="color:#00ff">三、如何在<span style="font-family:Times New Roman">MYSQL </span><span style="font-family:宋体">中使用事务</span></span></p>&#13;\n<p>1<span style="font-family:宋体">、谁可以使用</span></p>&#13;\n<p>只有<span style="font-family:Times New Roman">InnoDB /BDB</span><span style="font-family:宋体">　的之类的</span><span style="font-family:Times New Roman">transaction_safe table </span><span style="font-family:宋体">才能支持。</span></p>&#13;\n<p>默认的<span style="font-family:Times New Roman">engine MyISAM </span><span style="font-family:宋体">是不支持事务的，</span><span style="font-family:Times New Roman">show engine </span><span style="font-family:宋体">可以看到支持的和默认的</span><span style="font-family:Times New Roman">engine</span>。可以在<span style="font-family:Times New Roman">[mysqld] </span><span style="font-family:宋体">加入：</span> default_storage_engine=InnoDB;  InnoDB <span style="font-family:宋体">就是建立表的默认引擎</span>。</p>&#13;\n<p>建立<span style="font-family:Times New Roman">InnoDB </span><span style="font-family:宋体">表</span>：Create table .... type=InnoDB； Alter table table_name type=InnoDB;（如何查看已有表的类型： show create table table_name)</p>&#13;\n<p>这样我们就可以在InnoDB <span style="font-family:宋体">表上进行事务操作了！</span></p>&#13;\n<p>2<span style="font-family:宋体">、如何使用</span></p>&#13;\n<p>启动事务的方法：</p>&#13;\n<p>认为分为两种：</p>&#13;\n<p>1、begin <span style="font-family:宋体">，</span><span style="font-family:Times New Roman">rollback,commit .</span><span style="font-family:宋体">当然有的人用</span><span style="font-family:Times New Roman">begin /begin work .</span><span style="font-family:宋体">推荐用</span><span style="font-family:Times New Roman">START TRANSACTION </span><span style="font-family:宋体">是</span><span style="font-family:Times New Roman">SQL-99</span><span style="font-family:宋体">标准启动一个事务。</span></p>&#13;\n<p>    start transaction<span style="font-family:宋体">；</span></p>&#13;\n<p>update from account set money=money-100 where name='a';</p>&#13;\n<p>update from account set money=money+100 where name='b';</p>&#13;\n<p>commit<span style="font-family:宋体">；</span></p>&#13;\n<p>解释： 这样<span style="font-family:Times New Roman">start transaction </span><span style="font-family:宋体">手动开启事务，</span><span style="font-family:Times New Roman">commit </span><span style="font-family:宋体">手动关闭事务。</span></p>&#13;\n<p>2、默认的时候<span style="font-family:Times New Roman">autocommit=1 </span><span style="font-family:宋体">自动提交是开启的，所以你可以理解为每条语句一输入到</span><span style="font-family:Times New Roman">mysql</span><span style="font-family:宋体">就</span><span style="font-family:Times New Roman">commit </span><span style="font-family:宋体">了。</span>当你 set autocommit=0 <span style="font-family:宋体">时候，你可以这样：</span></p>&#13;\n<p>update from account set money=money-100 where name='a';</p>&#13;\n<p>update from account set money=money+100 where name='b';</p>&#13;\n<p>commit<span style="font-family:宋体">；</span></p>&#13;\n<p>// <span style="font-family:宋体">默认都不提交，只有手动键入</span><span style="font-family:Times New Roman">commit </span><span style="font-family:宋体">时候才上述都提交。</span></p>&#13;\n<p>综述：一般使用１　方法。</p>&#13;\n<p><span style="color:#00ff">四、举例</span></p>&#13;\n<p><span style="background:rgb(255,255,255)"><br />&#13;\n</span><span style="background:rgb(255,255,255)">mysql&gt; select * from employee;</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">+------------+------------+------------+--------------+</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">| employeeID | name       | job        | departmentID |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">+------------+------------+------------+--------------+</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       6651 | Ajay Patel | Programmer |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       7513 | Nora Edwar | Programmer |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9006 | Candy Burn | Systems Ad |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9842 | Ben Smith  | DBA        |           42 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9843 | Pert Park  | DBA        |           42 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9845 | Ben Patel  | DBA        |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9846 | Red Right  | x          |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9847 | Run Wild   | x          |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9848 | Rip This J | x          |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9849 | Rip This J | x          |          128 |</span></p>&#13;\n<p><span style="background:rgb(255,255,255)">|       9850 | Reader U   | x          |          128 |</span></p>&#13;\n<p></p>&#13;\n<p>set auotcommit =0;</p>&#13;\n<p>insert into employee values(null,"test1",null,128);</p>&#13;\n<p>savepoint s1;</p>&#13;\n<p></p>&#13;\n<p>insert into employee values(null,"test2",null,128);</p>&#13;\n<p>savepoint s2;</p>&#13;\n<p></p>&#13;\n<p>insert into employee values(null,"test3",null,128);</p>&#13;\n<p>savepoint s3;</p>&#13;\n<p></p>&#13;\n<p>执行完三个插入语句，<span style="font-family:Times New Roman">select * from employee </span><span style="font-family:宋体">可以看到三条。如果你想回滚到最初</span><span style="font-family:Times New Roman">rollback </span><span style="font-family:宋体">就是最初什么都没有做的状态。 如果你想回到</span><span style="font-family:Times New Roman">savepoint s1 </span><span style="font-family:宋体">的状态（也就是插入一条</span><span style="font-family:Times New Roman">test1 </span><span style="font-family:宋体">的那里） </span><span style="font-family:Times New Roman">rollback to savpoint s1 .  </span><span style="font-family:宋体">同理什么都可以做了。</span></p>&#13;\n<p></p>&#13;\n<p>附录： 事务的<span style="font-family:Times New Roman">ACID(</span>Atomicity \\Consistency \\Isolation \\Durablility) </p>&#13;\n<p>A: <span style="font-family:宋体">事务必须是原子（不可分割），要么执行成功进入下一个状态，要么失败</span><span style="font-family:Times New Roman">rollback </span><span style="font-family:宋体">到最初状态。</span></p>&#13;\n<p>C<span style="font-family:宋体">：</span>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 这个一般通过外键来约束。</p>&#13;\n<p>I<span style="font-family:宋体">：一个事务不能知道另外一个事务的执行情况（中间状态）</span></p>&#13;\n<p>D<span style="font-family:宋体">：</span>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 </p>&#13;\n<p>mysql <span style="font-family:宋体">自己的</span><span style="font-family:Times New Roman">MyISAM </span><span style="font-family:宋体">没有通过</span><span style="font-family:Times New Roman">acid </span><span style="font-family:宋体">测试，但是</span><span style="font-family:Times New Roman">InnoDB </span><span style="font-family:宋体">可以做到。</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">在分布式的系统中，通常会有多个线程连接到数据库中同时对一个表进行操作<span style="font-family:Helvetica">(</span><span style="font-family:宋体">这里的同时并不表示同一个时间点，而是同时竞争</span><span style="font-family:Helvetica">cpu</span><span style="font-family:宋体">的资源，至于如何调度，就要看线程和操作系统如何进行调度了</span><span style="font-family:Helvetica">)</span><span style="font-family:宋体">，这种情况下如果会话的事物设置不当，就会导致数据混乱，常常会出现以下三种情况</span><span style="font-family:Helvetica">(</span><span style="font-family:宋体">假设现在系统中有两个会话</span><span style="font-family:Helvetica">A</span><span style="font-family:宋体">和</span><span style="font-family:Helvetica">B</span><span style="font-family:宋体">，同时对表</span><span style="font-family:Helvetica">T_Test</span><span style="font-family:宋体">操作</span><span style="font-family:Helvetica">)</span><span style="font-family:宋体">：</span></span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">1.<span style="font-family:宋体">脏读：</span></span><span style="color:#000000; background:rgb(255,255,255)">如果有</span><span style="color:#000000; background:rgb(255,255,255)">A<span style="font-family:宋体">向</span><span style="font-family:Helvetica">B </span><span style="font-family:宋体">做了这个操作：</span></span><span style="color:#000000; background:rgb(255,255,255)">update account set money=money+100 where name='B'<span style="font-family:宋体">；</span></span><span style="color:#000000; background:rgb(255,255,255)">在没有</span><span style="color:#000000; background:rgb(255,255,255)">commit <span style="font-family:宋体">之前</span><span style="font-family:Helvetica">B </span><span style="font-family:宋体">查询：</span></span>select money from account where name='B'<span style="font-family:宋体">；</span>找到了没有提交的money <span style="font-family:宋体">，之后</span><span style="font-family:Times New Roman">A</span><span style="font-family:宋体">在此时有</span><span style="font-family:Times New Roman">rollback </span><span style="font-family:宋体">，</span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">再查询，</span><span style="font-family:Times New Roman">100 </span><span style="font-family:宋体">不见了。为了避免提高级别：</span><span style="font-family:Times New Roman">read committed </span><span style="font-family:宋体">。就是只能读取提交后的东东。</span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">2.<span style="font-family:宋体">不可重复读：</span></span><span style="color:#000000; background:rgb(255,255,255)">1<span style="font-family:宋体">中说明的就是我们不能读取一个事务的中间状态。 而重复读是指我们每次读取到的结果都要一直。 这个也是</span><span style="font-family:Helvetica">mysql </span><span style="font-family:宋体">默认的级别。</span></span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">mysql&gt;  select @@tx_isolation ;</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">+-----------------+</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">| @@tx_isolation  |</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">+-----------------+</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">| REPEATABLE-READ |</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">+-----------------+</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">3.</span><span style="color:#000000; background:rgb(255,255,255)">幻读：</span>在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。和不可重复读的区别是：不可重复读是读取到了别人对表中的某一条记录进行了修改，导致前后读取的数据不一致。  虚读是前后读取到表中的记录总数不一样，读取到了其它事务插入的数据。比如现在有 <span style="font-family:Times New Roman">A </span><span style="font-family:宋体">和 </span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">两个应用程序，他们并发访问了数据库中的某一张表，假设表中有 </span><span style="font-family:Times New Roman">3 </span><span style="font-family:宋体">条记录，</span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">执行查询操作， 第一次查询表得到了 </span><span style="font-family:Times New Roman">3 </span><span style="font-family:宋体">条记录。此时 </span><span style="font-family:Times New Roman">A </span><span style="font-family:宋体">对表进行了修改，增加了一条记录，当 </span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">再次查询表的时候，发现多了一条数据。这种情况就造成了 </span><span style="font-family:Times New Roman">B </span><span style="font-family:宋体">的虚读。但是虚读是不一定每次都发生的，这种情况是不确定的。为了避免虚读，我们可以将事物隔离级别设置为 </span><span style="font-family:Times New Roman">serializable </span><span style="font-family:宋体">如果设置成了这种级别，那么数据库就变成了单线程访问的数据库，导致性能降低很多。</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)">summary<span style="font-family:宋体">：</span></span></p>&#13;\n<p>（<span style="font-family:Times New Roman">1</span><span style="font-family:宋体">）</span><span style="font-family:Times New Roman">Serializable</span><span style="font-family:宋体">：可避免脏读、不可重复读、虚读情况的发生。             </span></p>&#13;\n<p>（2<span style="font-family:宋体">）</span>Repeatable read<span style="font-family:宋体">：可避免脏读、不可重复读情况的发生。（可重复读，是 </span><span style="font-family:Times New Roman">mysql </span><span style="font-family:宋体">默认的事务隔离级别）</span></p>&#13;\n<p>（<span style="font-family:Times New Roman">3</span><span style="font-family:宋体">）</span><span style="font-family:Times New Roman">Read committed</span><span style="font-family:宋体">：可避免脏读情况发生。（读取已提交的数据）</span></p>&#13;\n<p>（<span style="font-family:Times New Roman">4</span><span style="font-family:宋体">）</span><span style="font-family:Times New Roman">Read uncommitted</span><span style="font-family:宋体">：最低级别，以上情况均无法保证。（读取到了未提交的数据）</span></p>&#13;\n<p> </p>&#13;\n<p>  当我们将数据库的隔离级别设置为：<span style="font-family:Times New Roman">Serializable </span><span style="font-family:宋体">的时候，虽然可以避免所有并发访问的问题，但是 </span><span style="font-family:Times New Roman">Serializable </span><span style="font-family:宋体">采用的是单线程来解决并发访问的问题，也就是说在某一段时间内，只能有一个用户对数据库进行操作，导致其它用户阻塞。导致数据库的访问性能很差。</span></p>&#13;\n<p style="background:rgb(255,255,255)"><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">1.<span style="font-family:宋体">读未提交（</span><span style="font-family:Helvetica">Read Uncommitted</span><span style="font-family:宋体">）：这种隔离级别可以让当前事务读取到其它事物还没有提交的数据。这种读取应该是在回滚段中完成的。通过上面的分析，这种隔离级别是最低的，会导致引发脏读，不可重复读，和幻读。</span></span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">2.<span style="font-family:宋体">读已提交（</span><span style="font-family:Helvetica">Read Committed</span><span style="font-family:宋体">）：这种隔离级别可以让当前事务读取到其它事物已经提交的数据。通过上面的分析，这种隔离级别会导致引发不可重复读，和幻读。</span></span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">3.<span style="font-family:宋体">可重复读取（</span><span style="font-family:Helvetica">Repeatable Read</span><span style="font-family:宋体">）：这种隔离级别可以保证在一个事物中多次读取特定记录的时候都是一样的。通过上面的分析，这种隔离级别会导致引发幻读。</span></span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span><span style="color:#000000; background:rgb(255,255,255)">4.<span style="font-family:宋体">串行（</span><span style="font-family:Helvetica">Serializable</span><span style="font-family:宋体">）：这种隔离级别将事物放在一个队列中，每个事物开始之后，别的事物被挂起。同一个时间点只能有一个事物能操作数据库对象。这种隔离级别对于数据的完整性是最高的，但是同时大大降低了系统的可并发性。</span></span><span style="color:#000000; background:rgb(255,255,255)"><br />&#13;\n</span></p>&#13;\n<p></p>&#13;\n<p><span style="color:#00ff">五、非<span style="font-family:Times New Roman">InnoDB</span><span style="font-family:宋体">怎么办？</span></span></p>&#13;\n<p>妈的，肯定有人会说那我<span style="font-family:Times New Roman">mysql </span><span style="font-family:宋体">的默认</span><span style="font-family:Times New Roman">MyISAM </span><span style="font-family:宋体">怎么办？ 没有事务这样的事情怎么处理呢？ 这个要用到另外一种技术叫做</span><span style="font-family:Times New Roman">LOCK ! </span><span style="font-family:宋体">实际上实现上边那</span><span style="font-family:Times New Roman">4 </span><span style="font-family:宋体">个安全级别的所用的技术就是</span><span style="font-family:Times New Roman">LOCK </span><span style="font-family:宋体">！</span></p>&#13;\n<p>我怎么在处理锁的问题上，经常听到：共享锁、排它锁、悲观锁、乐观锁、行级锁、表级锁。</p>&#13;\n<p>共享锁： 就是在读取数据的时候，给数据添加一个共享锁。共享和共享直接是不冲突的，但是和排他锁是冲突的。</p>&#13;\n<p>排他锁： 更新数据的时候，安装排他锁，禁止其他一切行为。</p>&#13;\n<p><span style="color:#00ff">场景：老公去在 ATM 上取钱，老婆在柜台存钱，假设这个账户中有 1000 元。老公首先执行查询操作，查询到账户余额为 1000 此时程序将 1000 拿到内存中，老公取了 200 元，程序就执行了更新操作将账户余额改为 800，但是当老公的程序没有 commit 的时候，老婆查询账户，此时账户余额还是 1000 元，老婆存入 200 元，程序执行了更新操作将账户余额改为 1200，然后老公将更新语句提交，接着老婆也将更新语句提交。最后导致的结果就是该账户的余额为 1200，这就是更新丢失的问题。引发更新丢失的根源就是查询上，因为双方都是根据从数据库查询到的数据再对数据库中的数据进行更新的。解决更新丢失有三个方案：(1) 将事务隔离级别设置为最高，采用死锁策略。(2) </span><span style="color:#00ff">采用悲观锁</span><span style="color:#00ff">，悲观锁不是数据库中真正的锁，是人们看待事务的态度。(3)</span><span style="color:#00ff"> 采用乐观锁</span><span style="color:#00ff">，乐观锁也不是数据库中真正的锁。</span></p>&#13;\n<p><span style="color:#0800">如果我们采用的是第一个方案时，老公进行查询操作，数据库为表增加了共享锁，老婆进行查询操作时数据库也增加了一个共享锁。但是当老公进行更新数据库操作时，由于老婆拿着共享锁，导致老公不能增加排它锁，老婆进行更新操作时，因为老公拿着共享锁，导致老婆也拿不到排它锁，这就发生了死锁现象，你等我，我等你。在 <span style="font-family:Times New Roman">mysql </span><span style="font-family:宋体">中，处理死锁的方案是释放掉一方的锁。这样就保证了一方更新成功，但是这种性能极低，因为数据库频繁在解决死锁问题。</span></span></p>&#13;\n<p><span style="color:#0800">悲观锁（更新多，查询少时用）</span></p>&#13;\n<p><span style="color:#0800">如果我们采用的是第二个方案时，即采用悲观锁。就是我们在操作数据库时采用悲观的态度，认为别人会在此时并发访问数据库。我们在查询语句中 <span style="font-family:Times New Roman">select * from account where name='aaa' for update; </span><span style="font-family:宋体">等于加了排它锁。当老公查询余额的时候，</span><span style="font-family:Times New Roman">select money from account where name='aaa' for update; </span><span style="font-family:宋体">增加了排它锁，老婆查询账户余额的时候， </span><span style="font-family:Times New Roman">select money from account where name='aaa' for update</span><span style="font-family:宋体">；也要求对数据库加排它锁，因为老公已经拿到了排它锁，导致老婆不能加锁，所以老婆只有等待老公执行完毕，释放掉锁以后才能继续操作。</span></span></p>&#13;\n<p><span style="color:#0800">乐观锁（更新少，查询多时用）</span></p>&#13;\n<p><span style="color:#0800">如果我们采用的是第三个方案时，即采用乐观锁，就是我们在操作数据库的时候会认为没有其它用户并发访问，但是乐观锁也不是完全乐观的，乐观锁是采用版本号的方式进行控制的。在数据库表中有一列版本号。从数据库中查询的时候，将版本号也查询过来，在进行更新操作的时候，将版本号加<span style="font-family:Times New Roman">1</span><span style="font-family:宋体">，查询条件的版本号还是查询过来的版本号。比如，老公执行查询操作的时候，</span><span style="font-family:Times New Roman">select money,version from account where name='aaa'; </span><span style="font-family:宋体">假设此时查询到的版本号为 </span><span style="font-family:Times New Roman">0</span><span style="font-family:宋体">，老公在进行更新操作的时候 </span><span style="font-family:Times New Roman">update account set money=money+100,version=version+1 where name='aaa' and version=0; </span><span style="font-family:宋体">未提交时老婆来查询，查询到的版本号依然是 </span><span style="font-family:Times New Roman">0</span><span style="font-family:宋体">，老婆也执行更新操作 </span><span style="font-family:Times New Roman">update account set money=money+100,version=version+1 where name='aaa' and version=0; </span><span style="font-family:宋体">现在老公提交了事务，老婆再提交事务的时候发现版本号为 </span><span style="font-family:Times New Roman">0 </span><span style="font-family:宋体">的记录没有了，所以就避免了数据丢失的问题。不过这种情况也导致了多个用户更新操作时，只有一个用户的更新被执行。</span></span></p>&#13;\n<p><span style="color:#0800">行级别的锁：</span></p>&#13;\n<p><span style="color:#0800">select * from employee where employeeID=9857 for update;  where <span style="font-family:宋体">后边是索引列</span></span></p>&#13;\n<p><span style="color:#0800">不是索引列那么就为</span><span style="color:#0800">表级别的锁</span></p>&#13;\n<p></p>&#13;\n<p><span style="line-height:1.5"></span> </p>&#13;\n<p><span style="line-height:1.5"></span> </p>&#13;\n<p><span style="line-height:1.5">MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关1.MyISAM：不支持事务，用于只读程序提高性能 2.InnoDB：支持ACID事务、行级锁、并发 3.Berkeley DB：支持事务</span></p>&#13;\n<div class="bodyContent">&#13;\n<div class="floatAd"> </div>&#13;\n<div class="floatAd" id="c_ads5"> 一个事务是一个连续的一组<a target="_blank" href="http://www.111cn.net/database/database.html">数据库</a>操作，就好像它是一个单一的工作单元进行。换言之，永远不会是完整的事务，除非该组内的每个单独的操作是成功的。如果在事务的任何操作失败，则整个事务将失败。</div>&#13;\n<p>实际上，会俱乐部许多SQL查询到一个组中，将执行所有的人都一起作为事务的一部分。</p>&#13;\n<p>事务的特性： <br />&#13;\n事务有以下四个标准属性的缩写ACID，通常被称为：</p>&#13;\n<p>原子性: 确保工作单元内的所有操作都成功完成，否则事务将被中止在故障点，和以前的操作将回滚到以前的状态。</p>&#13;\n<p>一致性: 确保<a target="_blank" href="http://www.111cn.net/list-55/">数据库</a>正确地改变状态后，成功提交的事务。</p>&#13;\n<p>隔离性: 使事务操作彼此独立的和透明的。</p>&#13;\n<p>持久性: 确保提交的事务的结果或效果的系统出现故障的情况下仍然存在。</p>&#13;\n<p>在MySQL中，事务开始使用COMMIT或ROLLBACK语句开始工作和结束。开始和结束语句的SQL命令之间形成了大量的事务。</p>&#13;\n<p>COMMIT &amp; ROLLBACK: <br />&#13;\n这两个关键字提交和回滚主要用于MySQL的事务。</p>&#13;\n<p>当一个成功的事务完成后，发出COMMIT命令应使所有参与表的更改才会生效。</p>&#13;\n<p>如果发生故障时，应发出一个ROLLBACK命令返回的事务中引用的每一个表到以前的状态。</p>&#13;\n<p>可以控制的事务行为称为AUTOCOMMIT设置会话变量。如果AUTOCOMMIT设置为1（默认值），然后每一个SQL语句（在事务与否）被认为是一个完整的事务，并承诺在默认情况下，当它完成。 AUTOCOMMIT设置为0时，发出SET AUTOCOMMIT =0命令，在随后的一系列语句的作用就像一个事务，直到一个明确的COMMIT语句时，没有活动的提交。</p>&#13;\n<p>可以通过使用mysql_query()函数在PHP中执行这些SQL命令。</p>&#13;\n<p>通用事务例子 <br />&#13;\n这一系列事件是独立于所使用的编程语言，可以建立在任何使用的语言来创建应用程序的逻辑路径。<br />&#13;\n可以通过使用mysql_query()函数在PHP中执行这些SQL命令。</p>&#13;\n<p><br />&#13;\nBEGIN WORK开始事务发出SQL命令</p>&#13;\n<p>发出一个或多个SQL命令，如SELECT，INSERT，UPDATE或DELETE</p>&#13;\n<p>检查是否有任何错误，一切都依据的需要。</p>&#13;\n<p>如果有任何错误，那么问题ROLLBACK命令，否则发出COMMIT命令。</p>&#13;\n<p>在MySQL中的事务安全表类型：</p>&#13;\n<p>如果打算使用MySQL事务编程，那么就需要一种特殊的方式创建表。有很多支持事务但最流行的是InnoDB表类型。</p>&#13;\n<p>从源代码编译MySQL时，InnoDB表支持需要特定的编译参数。如果MySQL版本没有InnoDB支持，请互联网服务提供商建立一个版本的MySQL支持InnoDB表类型，或者下载并安装Windows或Linux/UNIX的MySQL-Max二进制分发和使用的表类型在开发环境中。<br />&#13;\n如果MySQL安装支持InnoDB表，只需添加一个的TYPE=InnoDB 定义表创建语句。例如，下面的代码创建InnoDB表tcount_tbl：</p>&#13;\n<p> </p>&#13;\n<table align="center" border="0" cellspacing="1" cellpadding="1" style="width:620px">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td width="464" height="27" bgcolor="#ffe7ce"> 代码如下</td>&#13;\n<td width="109" align="center" bgcolor="#ffe7ce">复制代码</td>&#13;\n</tr>&#13;\n<tr>&#13;\n<td height="auto" class="copyclass" id="copy9312" valign="top" bgcolor="#ffffff" colspan="2">&#13;\nroot@host# mysql -u root -p pass<a target="_blank" href="http://www.111cn.net/list-189/">word</a>;<br />&#13;\nEnter password:*******<br />&#13;\nmysql&gt; use TUTORIALS;<br />&#13;\nDatabase changed<br />&#13;\nmysql&gt; create table tcount_tbl<br />&#13;\n    -&gt; (<br />&#13;\n    -&gt; tutorial_author varchar(40) NOT NULL,<br />&#13;\n    -&gt; tutorial_count  INT<br />&#13;\n    -&gt; ) TYPE=InnoDB;<br />&#13;\nQuery OK, 0 rows affected (0.05 sec)</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n<p>可以使用其他GEMINI或BDB表类型，但它取决于您的安装，如果它支持这两种类型。</p>&#13;\n<p><br />&#13;\n由于项目设计里面，牵扯到了金钱的转移，于是就要用到MYSQL的事务处理，来保证一组处理结果的正确性。用了事务，就不可避免的要牺牲一部分速度，来保证数据的正确性。<br />&#13;\n只有InnoDB支持事务</p>&#13;\n<p>事务 ACID Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）</p>&#13;\n<p>1、事务的原子性<br />&#13;\n一组事务，要么成功；要么撤回。</p>&#13;\n<p>2、稳定性<br />&#13;\n有非法数据（外键约束之类），事务撤回。</p>&#13;\n<p>3、隔离性<br />&#13;\n事务独立运行。<br />&#13;\n一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。<br />&#13;\n事务的100%隔离，需要牺牲速度。</p>&#13;\n<p>4、可靠性<br />&#13;\n软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。<br />&#13;\n可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit选项 决定什么时候吧事务保存到日志里。<br />&#13;\n开启事务<br />&#13;\nSTART TRANSACTION 或 BEGIN</p>&#13;\n<p>提交事务（关闭事务）<br />&#13;\nCOMMIT</p>&#13;\n<p>放弃事务（关闭事务）<br />&#13;\nROLLBACK</p>&#13;\n<p>折返点<br />&#13;\nSAVEPOINT adqoo_1<br />&#13;\nROLLBACK TO SAVEPOINT adqoo_1<br />&#13;\n发生在折返点 adqoo_1 之前的事务被提交，之后的被忽略</p>&#13;\n<p>事务的终止</p>&#13;\n<p>设置“自动提交”模式<br />&#13;\nSET AUTOCOMMIT = 0<br />&#13;\n每条SQL都是同一个事务的不同命令，之间由 COMMIT 或 ROLLBACK隔开<br />&#13;\n掉线后，没有 COMMIT 的事务都被放弃</p>&#13;\n<p>事务锁定模式</p>&#13;\n<p>系统默认： 不需要等待某事务结束，可直接查询到结果，但不能再进行修改、删除。<br />&#13;\n缺点：查询到的结果，可能是已经过期的。<br />&#13;\n优点：不需要等待某事务结束，可直接查询到结果。</p>&#13;\n<p>需要用以下模式来设定锁定模式</p>&#13;\n<p>1、SELECT …… LOCK IN SHARE MODE（共享锁）<br />&#13;\n查询到的数据，就是数据库在这一时刻的数据（其他已commit事务的结果，已经反应到这里了）<br />&#13;\nSELECT 必须等待，某个事务结束后才能执行</p>&#13;\n<p>2、SELECT …… FOR UPDATE（排它锁）<br />&#13;\n例如 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-9.html mysql.sh FROM tablename WHERE id&lt;200<br />&#13;\n那么id&lt;200的数据，被查询到的数据，都将不能再进行修改、删除、SELECT …… LOCK IN SHARE MODE操作<br />&#13;\n一直到此事务结束</p>&#13;\n<p>共享锁 和 排它锁 的区别：在于是否阻断其他客户发出的 SELECT …… LOCK IN SHARE MODE命令</p>&#13;\n<p>3、INSERT / UPDATE / DELETE<br />&#13;\n所有关联数据都会被锁定，加上排它锁</p>&#13;\n<p>4、防插入锁<br />&#13;\n例如 SELECT csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-9.html mysql.sh FROM tablename WHERE id&gt;200<br />&#13;\n那么id&gt;200的记录无法被插入</p>&#13;\n<p>5、死锁<br />&#13;\n自动识别死锁<br />&#13;\n先进来的进程被执行，后来的进程收到出错消息，并按ROLLBACK方式回滚<br />&#13;\ninnodb_lock_wait_timeout = n 来设置最长等待时间，默认是50秒</p>&#13;\n<p>事务隔离模式</p>&#13;\n<p>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL<br />&#13;\nREAD UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE<br />&#13;\n1、不带SESSION、GLOBAL的SET命令<br />&#13;\n只对下一个事务有效<br />&#13;\n2、SET SESSION<br />&#13;\n为当前会话设置隔离模式<br />&#13;\n3、SET GLOBAL<br />&#13;\n为以后新建的所有MYSQL连接设置隔离模式（当前连接不包括在内）</p>&#13;\n<p>隔离模式</p>&#13;\n<p>   READ UNCOMMITTED<br />&#13;\n不隔离SELECT<br />&#13;\n其他事务未完成的修改（未COMMIT），其结果也考虑在内</p>&#13;\n<p>   READ COMMITTED<br />&#13;\n把其他事务的 COMMIT 修改考虑在内<br />&#13;\n同一个事务中，同一 SELECT 可能返回不同结果</p>&#13;\n<p>   REPEATABLE READ（默认）<br />&#13;\n不把其他事务的修改考虑在内，无论其他事务是否用COMMIT命令提交过<br />&#13;\n同一个事务中，同一 SELECT 返回同一结果（前提是本事务，不修改）</p>&#13;\n<p>   SERIALIZABLE<br />&#13;\n和REPEATABLE READ类似，给所有的SELECT都加上了 共享锁</p>&#13;\n<p>出错处理<br />&#13;\n根据出错信息，执行相应的处理</p>&#13;\n<p><br />&#13;\n<strong>mysql事物处理实例</strong></p>&#13;\n<p><span style="color:#ff00">MYSQL的事务处理主要有两种方法<br />&#13;\n1.用begin,rollback,commit来实现<br />&#13;\n    begin开始一个事务<br />&#13;\n    rollback事务回滚<br />&#13;\n    commit 事务确认<br />&#13;\n2.直接用set来改变mysql的自动提交模式<br />&#13;\n    mysql默认是自动提交的，也就是你提交一个query，就直接执行！可以通过<br />&#13;\n    set autocommit = 0 禁止自动提交<br />&#13;\n    set autocommit = 1 开启自动提交<br />&#13;\n</span>    来实现事务的处理。<br />&#13;\n但要注意当用set autocommit = 0 的时候，你以后所有的sql都将作为事务处理，直到你用commit确认或 rollback结束，注意当你结束这个事务的同时也开启了新的事务！按第一种方法只将当前的做为一个事务!<br />&#13;\nMYSQL只有 INNODB和BDB类型的数据表才支持事务处理，其他的类型是不支持的!<br />&#13;\nMYSQL5.0 WINXP下测试通过～  ^_^</p>&#13;\n<table align="center" border="0" cellspacing="1" cellpadding="1" style="width:620px">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td width="464" height="27" bgcolor="#ffe7ce"> 代码如下</td>&#13;\n<td width="109" align="center" bgcolor="#ffe7ce">复制代码</td>&#13;\n</tr>&#13;\n<tr>&#13;\n<td height="auto" class="copyclass" id="copy3777" valign="top" bgcolor="#ffffff" colspan="2">&#13;\n<p>    mysql&gt; use test;<br />&#13;\n    Database changed<br />&#13;\n    mysql&gt; CREATE TABLE `dbtest`(<br />&#13;\n    -&gt; id int(4)<br />&#13;\n    -&gt; ) TYPE=INNODB;<br />&#13;\nQuery OK, 0 rows affected, 1 warning (0.05 sec)</p>&#13;\n<p>mysql&gt; <a target="_blank" href="http://www.111cn.net/tags.php/select/">select</a> * from dbtest<br />&#13;\n    -&gt; ;<br />&#13;\nEmpty set (0.01 sec)</p>&#13;\n<p>mysql&gt; begin;<br />&#13;\nQuery OK, 0 rows affected (0.00 sec)</p>&#13;\n<p>mysql&gt; insert into dbtest values(5);<br />&#13;\nQuery OK, 1 row affected (0.00 sec)</p>&#13;\n<p>mysql&gt; insert into dbtest value(6);<br />&#13;\nQuery OK, 1 row affected (0.00 sec)</p>&#13;\n<p>mysql&gt; commit;<br />&#13;\nQuery OK, 0 rows affected (0.00 sec)</p>&#13;\n<p>mysql&gt; select csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-9.html mysql.sh from dbtest;<br />&#13;\n+------+<br />&#13;\n| id   |<br />&#13;\n+------+<br />&#13;\n|    5 |<br />&#13;\n|    6 |<br />&#13;\n+------+<br />&#13;\n2 rows in set (0.00 sec)</p>&#13;\n<p>mysql&gt; begin;<br />&#13;\nQuery OK, 0 rows affected (0.00 sec)</p>&#13;\n<p>mysql&gt; insert into dbtest values(7);<br />&#13;\nQuery OK, 1 row affected (0.00 sec)</p>&#13;\n<p>mysql&gt; rollback;<br />&#13;\nQuery OK, 0 rows affected (0.00 sec)</p>&#13;\n<p>mysql&gt; select csdn-10.html csdn-11.html csdn-12.html csdn-13.html csdn-14.html csdn-15.html csdn-16.html csdn-17.html csdn-18.html csdn-19.html csdn-1.html csdn-20.html csdn-21.html csdn-22.html csdn-23.html csdn-24.html csdn-25.html csdn-26.html csdn-27.html csdn-28.html csdn-29.html csdn-2.html csdn-30.html csdn-31.html csdn-32.html csdn-33.html csdn-34.html csdn-35.html csdn-36.html csdn-37.html csdn-38.html csdn-39.html csdn-3.html csdn-40.html csdn-41.html csdn-42.html csdn-43.html csdn-44.html csdn-45.html csdn-46.html csdn-47.html csdn-48.html csdn-49.html csdn-4.html csdn-50.html csdn-51.html csdn-52.html csdn-53.html csdn-54.html csdn-55.html csdn-56.html csdn-57.html csdn-58.html csdn-59.html csdn-5.html csdn-60.html csdn-61.html csdn-62.html csdn-63.html csdn-64.html csdn-65.html csdn-66.html csdn-67.html csdn-68.html csdn-69.html csdn-6.html csdn-70.html csdn-71.html csdn-72.html csdn-73.html csdn-74.html csdn-75.html csdn-76.html csdn-77.html csdn-78.html csdn-79.html csdn-7.html csdn-80.html csdn-81.html csdn-82.html csdn-83.html csdn-84.html csdn-85.html csdn-86.html csdn-87.html csdn-88.html csdn-89.html csdn-8.html csdn-90.html csdn-9.html mysql.sh from dbtest;<br />&#13;\n+------+<br />&#13;\n| id   |<br />&#13;\n+------+<br />&#13;\n|    5 |<br />&#13;\n|    6 |<br />&#13;\n+------+<br />&#13;\n2 rows in set (0.00 sec)</p>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n<p>mysql&gt; mysql事务处理</p>&#13;\n<p><strong>php代码实现事务的处理可以通过PHP预定义类mysqli的以下方法实现。<br />&#13;\n</strong>autocommit(boolean)：该方法用于限定查询结果是否自动提交，如果该方法的参数为true则自动提交，如果参数为false则关闭自动提交。MySQL数据库默认为自动提交。<br />&#13;\nrollback()：利用mysqli类中的该方法可以实现事务的回滚。<br />&#13;\ncommit()：利用该方法可以实现提交所有查询。</p>&#13;\n<table align="center" border="0" cellspacing="1" cellpadding="1" style="width:620px">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td width="464" height="27" bgcolor="#ffe7ce"> 代码如下</td>&#13;\n<td width="109" align="center" bgcolor="#ffe7ce">复制代码</td>&#13;\n</tr>&#13;\n<tr>&#13;\n<td height="auto" class="copyclass" id="copy1574" valign="top" bgcolor="#ffffff" colspan="2">&#13;\n<p>&lt;?php<br />&#13;\n<a target="_blank" href="http://www.111cn.net/tags.php/include/">include</a>_once("conn.php");</p>&#13;\n<p>$id=$_GET[id];<br />&#13;\n$conn-&gt;autocommit(false);<br />&#13;\nif(!$conn-&gt;query("delete from tb_sco where id='".$id."'"))<br />&#13;\n{<br />&#13;\n  $conn-&gt;rollback();<br />&#13;\n}<br />&#13;\nif(!$conn-&gt;query("delete from tb_stu where id='".$id."'"))<br />&#13;\n{<br />&#13;\n  $conn-&gt;rollback();<br />&#13;\n}<br />&#13;\n  $conn-&gt;commit();<br />&#13;\n  $conn-&gt;autocommit(true);<br />&#13;\n  echo "ok"<br />&#13;\n?&gt;</p>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n<p>列二</p>&#13;\n<table align="center" border="0" cellspacing="1" cellpadding="1" style="width:620px">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td width="464" height="27" bgcolor="#ffe7ce"> 代码如下</td>&#13;\n<td width="109" align="center" bgcolor="#ffe7ce">复制代码</td>&#13;\n</tr>&#13;\n<tr>&#13;\n<td height="auto" class="copyclass" id="copy9475" valign="top" bgcolor="#ffffff" colspan="2">&#13;\n&lt;?php<br />&#13;\nrequire('connectDB.php'); //建立数据库连接<br />&#13;\nmssql_query("BEGIN TRANSACTION DEPS02_DEL"); //开始事务<br />&#13;\n$delete_dep_sql="DELETE FROM TBLDEPARTMENT WHERE DEPTID='{$_GET[deptid]}'";<br />&#13;\n// echo $delete_dep_sql."&lt;br&gt;";<br />&#13;\nmssql_query($delete_dep_sql); //操作数据库<br />&#13;\n// var_dump($del_result);<br />&#13;\n$delete_result = mssql_query("select @@ROWCOUNT as id");<br />&#13;\n$delete_info = mssql_fetch_array($delete_result);<br />&#13;\n$delete_rows = $delete_info[0];<br />&#13;\n// var_dump($delete_rows);<br />&#13;\nmssql_free_result($delete_result);<br />&#13;\necho "&lt;script language=<a target="_blank" href="http://www.111cn.net/js_a/js.html">javascript</a>&gt;";<br />&#13;\nif(true){    //判断是否回滚提交<br />&#13;\nmssql_query("COMMIT TRANSACTION DEPS02_DEL"); //提交事务<br />&#13;\necho "alert('delete success!');";<br />&#13;\n}else{<br />&#13;\nmssql_query("ROLLBACK TRANSACTION DEPS02_DEL"); //回滚事务<br />&#13;\necho "alert('delete faile!');";<br />&#13;\n}<br />&#13;\necho "&lt;/script&gt;";mssql_close();<br />&#13;\n?&gt;</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n<p>例3</p>&#13;\n<p>  MySQL的事务处理在处理实际问题中有着广泛且重要的应用，最常见的应用如银行转账业务、电子商务支付业务等等。但是，值得注意的是，MySQL的事务处理功能在MYSIAM存储引擎中是不支持的，在InnoDB存储引擎中是支持的。现在上传一段代码，作为引导认识MySQL事务处理的开始，简单的实例，但融汇思想，相信会有很大的帮助。</p>&#13;\n<table align="center" border="0" cellspacing="1" cellpadding="1" style="width:620px">&#13;\n<tbody>&#13;\n<tr>&#13;\n<td width="464" height="27" bgcolor="#ffe7ce"> 代码如下</td>&#13;\n<td width="109" align="center" bgcolor="#ffe7ce">复制代码</td>&#13;\n</tr>&#13;\n<tr>&#13;\n<td height="auto" class="copyclass" id="copy1347" valign="top" bgcolor="#ffffff" colspan="2">&#13;\n<p>&lt;?php<br />&#13;\n$conn=mysql_connect('localhost','root','yourpassword')or die(mysql_error());<br />&#13;\nmysql_select_db('transaction',$conn);<br />&#13;\nmysql_query('set names utf8');</p>&#13;\n<p>//创建事务<br />&#13;\nmysql_query('START TRANSACTION') or die(mysql_error());<br />&#13;\n$sqlA="update A set account=account-1";<br />&#13;\nif(!mysql_query($sqlA)){<br />&#13;\n&amp;nbsp;&amp;nbsp;&amp;nbsp; mysql_query('ROLLBACK') or exit(mysql_error());//判断当执行失败时回滚<br />&#13;\n&amp;nbsp;   exit();<br />&#13;\n}<br />&#13;\n$sqlB="update B set account=account+1";<br />&#13;\nif(!mysql_query($sqlB)){<br />&#13;\n&amp;nbsp;&amp;nbsp;&amp;nbsp; mysql_query('ROLLBACK') or exit(mysql_error());//判断当执行失败时回滚<br />&#13;\n&amp;nbsp;   exit();<br />&#13;\n}<br />&#13;\nmysql_query('COMMIT')or die(mysql_error());//执行事务<br />&#13;\nmysql_close($conn);<br />&#13;\n?&gt;</p>&#13;\n</td>&#13;\n</tr>&#13;\n</tbody>&#13;\n</table>&#13;\n<p>  以上代码可以作为模拟银行转账业务的事务流程。以表A、B分别表示两个已在银行开户的账户，当账户A执行转出1元给账户B的操作时，如果操作执行失败，转出将会回滚至原始状态，不继续向下执行动作。反之，如果操作执行成功，则账户B可用余额将增加1元，否则事务回滚至原始状态。</p>&#13;\n</div>&#13;\n &#13;\n
